<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 石记</title>
    <link>https://stoneepigraph.github.io/posts/</link>
    <description>Recent content in Posts on 石记</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Thu, 19 Dec 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://stoneepigraph.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>DDIA</title>
      <link>https://stoneepigraph.github.io/posts/ddia/</link>
      <pubDate>Thu, 19 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/ddia/</guid>
      <description>&lt;h2 id=&#34;数据密集型应用设计&#34;&gt;数据密集型应用设计&lt;/h2&gt;&#xA;&lt;h3 id=&#34;数据系统基础&#34;&gt;数据系统基础&lt;/h3&gt;&#xA;&lt;h4 id=&#34;可靠-可扩展与可维护的应用系统&#34;&gt;可靠、可扩展与可维护的应用系统&lt;/h4&gt;&#xA;&lt;p&gt;对于数据密集型应用，CPU的处理能力往往不是第一限制性因素，在于数据量、数据的复杂度及数据的快速多变性。数据密集型应用通常也是基于标准模块构建而成，每个模块负责单一的常用功能。例如，许多应用系统都包含以下模块：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;数据库： 用以存储数据，这样之后应用可以再次访问&lt;/li&gt;&#xA;&lt;li&gt;调整缓存：缓存那些复杂或操作代价昂贵的结果，以加快下一次访问。&lt;/li&gt;&#xA;&lt;li&gt;索引：用户可以按安搜索数据并支持各种过滤。&lt;/li&gt;&#xA;&lt;li&gt;流式处理：持续发送消息臻另一个进程，处理采用异步方式&lt;/li&gt;&#xA;&lt;li&gt;批处理：定期处理大量的累积数据。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;可靠性&lt;/p&gt;&#xA;&lt;p&gt;当出现意外情况，如硬件、软件故障、人为失误等，系统应可以继续正常运转：虽然性能可能有所降低，但确保功能正确。对于软件,典型的可靠性期望包括:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;应用程序执行用户据期望的功能.&lt;/li&gt;&#xA;&lt;li&gt;可以容忍用户出现错误或者不正确的软件使用方法&lt;/li&gt;&#xA;&lt;li&gt;性能可以应对典型场景, 合理负载原动力和数据量&lt;/li&gt;&#xA;&lt;li&gt;系统可防止任何示经授权的访问和滥用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;硬件故障&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;软件故障&lt;/p&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;原因&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;由于软件错误&lt;/li&gt;&#xA;&lt;li&gt;一个应用进程使用了某些共享资源,但却不幸失控&lt;/li&gt;&#xA;&lt;li&gt;系统统带于某些服务,但该服务突然或无响应&lt;/li&gt;&#xA;&lt;li&gt;级联故障&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;人为失误&lt;/p&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;如果假定人是不可靠的,那么该如何保证系统的可靠性?&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;以最小出错的方式来设计系统.&lt;/li&gt;&#xA;&lt;li&gt;想办法分离最容易出错的地方,容易引发故障的接口.&lt;/li&gt;&#xA;&lt;li&gt;充分的测试&lt;/li&gt;&#xA;&lt;li&gt;当出现人为失误时,提供快速的恢复机制以尽量减少故障影响&lt;/li&gt;&#xA;&lt;li&gt;设置详细而清晰的监控子系统&lt;/li&gt;&#xA;&lt;li&gt;推行管理流程并加以培训.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可靠性的重要性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;可扩展性&lt;/p&gt;&#xA;&lt;p&gt;随着规模的增长，例如数据量、流量或复杂性，系统应以合理的方式来匹配这种增长。可扩展性是描述系统应对负载增加能力的术语。它并不是衡量一个系统的一维指标，谈论“x是可扩展的”或“y不扩展”没有太大意义。相反，讨论可扩展性通常要考虑这类问题：“如果系统以某种方式增长，我们应对增长的措施有哪些”，“我们该如何添加计算资源来处理额外的负载”。&lt;/p&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;描述负载&lt;/p&gt;&#xA;&lt;p&gt;负载可以用称为负载参数的若干数字来描述，参数的最佳选择取决于系统的体系结构。如Web服务器的每秒请示处理次数，数据库中定稿的比例等。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;描述性能&lt;/p&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;延迟和响应时间&lt;/p&gt;&#xA;&lt;p&gt;延迟和响应时间容易混淆使用，通常响应时间是客户端看到的：除了处理请示时间外还包括来回网络延迟和各种排除延迟。延迟是请示花费在处理上的时间。有时，即使所有请示都相同，也会由于其他变量因素而引入一些延迟拉动，这些因素包括上下文切换和进程调度、网络数据包丢失和TCP重传、垃圾回收暂停、缺页中断和磁盘IO,甚至服务器机架的机械振动等。我们经常考察的是服务请示的平均响应时间，然后如果想知道更典型的响应时间，平均值并不是合适的指标，因为它掩盖了一些信息，无法告诉有多少用户实际经历了多少延迟。因此最好使用百分位数(percentiles)。如果已经搜集到了响应时间信息，将其从最快到最慢排序，中位数(median)就是列表中间的响应时间。中位数指标非常适合描述多少用户需要等待多长时间，通常缩写为p50。为了弄清楚异常值有多糟糕，需要关注更大的百分位数，如觉的p95, p99和p999。采用较高的响应时间百分位数很重要，因为它们直接影响用户的总体服务体验。百分位数通常用于描述、定义服务质量目标（Service Level Objectives, SLO）和服务质量协议（Service Level Agreements, SLA），这些是规定服务预期质量和可用性的合同。排队延迟往往在高百分数响应时间中影响很大。由于服务器并行处理的请示有限，正在处理的少数请示可能会阻挡后续请示，这种情况有时被称为队头阻塞。即使后续请示可能处理很简单，但它阻塞在等待先前请示的完成，客户端会观察到极慢的响应时间。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;应对负载增加的方法&lt;/p&gt;&#xA;&lt;p&gt;把无状态服务分布然后扩展臻多台机器相对比较容易，而有状态服务从单个节点扩展到分布式多机环境的复杂性会大大增加。出于这个原因，址到最近通常的做法一直是，将数据库运行在一个节点上（采用垂直扩展策略），直到高扩展性或高可用性的要求近使不得不做水平扩展。超大规模的系统往往针对特定应用而高度定制，很验证有一种通用的架构。背后取舍因素包括数据读取量、写入量、待存储的数据量、的复杂程度、响应时间要求、访问模式等，或者更多的是上述所有因素的叠加，再加上其他更复杂的问题。对于特定应用来说，扩展能力好的架构通常会做出某些假设，然后有针对性地优化设计，如哪些操作是最频繁的，哪 些负载是少数情况。可扩展架构通常都是从通用模块逐步构建而来， 背后往往有规律可循。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;可维护性&lt;/p&gt;&#xA;&lt;p&gt;随着时间的失衡，许多新的人员参与到系统开发和运维，以维护现有功能或甜酸新场景等，可维护性包括维护与缺陷修复，监控系统来保持正常运行、故障排查、适配新平台、搭配新场景、技术担风险的完善以及增加新功能等。&lt;/p&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;我们需要特别关注软件系统的三个设计原则&lt;/p&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;可运维性&lt;/p&gt;</description>
    </item>
    <item>
      <title>csapp</title>
      <link>https://stoneepigraph.github.io/posts/csapp/</link>
      <pubDate>Wed, 04 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/csapp/</guid>
      <description>&lt;h2 id=&#34;计算机系统漫游&#34;&gt;计算机系统漫游&lt;/h2&gt;&#xA;&lt;h3 id=&#34;信息就是位-plus-上下文&#34;&gt;信息就是位+上下文&lt;/h3&gt;&#xA;&lt;h3 id=&#34;程序被其他程序翻译成不同的格式&#34;&gt;程序被其他程序翻译成不同的格式&lt;/h3&gt;&#xA;&lt;p&gt;hello程序的生命周期是从一个高级C语言开始的，因为这种形式能够被人读懂。然而，为了在系统上运行hello.c程序，每条C诗句都必须被其他程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为可执行目标程序的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为可执行目标文件。&lt;/p&gt;&#xA;&lt;h3 id=&#34;了解编译系统如何工作是大有益处的&#34;&gt;了解编译系统如何工作是大有益处的&lt;/h3&gt;&#xA;&lt;h4 id=&#34;优化程序性能&#34;&gt;优化程序性能&lt;/h4&gt;&#xA;&lt;h4 id=&#34;理解链接时出现的错误&#34;&gt;理解链接时出现的错误&lt;/h4&gt;&#xA;&lt;h4 id=&#34;避免安全漏洞&#34;&gt;避免安全漏洞&lt;/h4&gt;&#xA;&lt;h3 id=&#34;处理器读并解释储存在中的指令&#34;&gt;处理器读并解释储存在中的指令&lt;/h3&gt;&#xA;&lt;h4 id=&#34;系统的硬件组成&#34;&gt;系统的硬件组成&lt;/h4&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;总线&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;I/O设备&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主存&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;处理器&lt;/p&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;加载&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;存储&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;操作&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;跳转&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;高速缓存至关重要&#34;&gt;高速缓存至关重要&lt;/h3&gt;&#xA;&lt;h3 id=&#34;存储设备形成层次结构&#34;&gt;存储设备形成层次结构&lt;/h3&gt;&#xA;&lt;p&gt;在处理器和一个较大较慢的设备（例如主存）之间插入一个更小更快的存储设备（例如高速红艳艳）的想法已经成为一个普通的观念。实际上，每个计算机系统中的存储设备都被组织成了一个存储器层次结构，在这个层次结构中， 从上至下，设备的访问速度起来越慢，容量越来越大，并且每字节的造价也越来越便宜。&lt;/p&gt;&#xA;&lt;h3 id=&#34;操作系统管理硬件&#34;&gt;操作系统管理硬件&lt;/h3&gt;&#xA;&lt;p&gt;所有应用程序对硬件的操作深度都必须通过操作系统。&lt;/p&gt;&#xA;&lt;h4 id=&#34;操作系统有两个基本功能&#34;&gt;操作系统有两个基本功能&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;防止硬件被失控的应用程序滥用&lt;/li&gt;&#xA;&lt;li&gt;向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;操作系统通过几个基本的抽象概念来实现这两个功能&#34;&gt;操作系统通过几个基本的抽象概念来实现这两个功能&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;进程进程则是对处理器、主存和I/O设备的抽象表示。&lt;/li&gt;&#xA;&lt;li&gt;虚拟内存虚拟内存是对主存和磁盘I/O设备的抽象表示&lt;/li&gt;&#xA;&lt;li&gt;文件文件是对I/O设备的抽象表示&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;进程&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;线程&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;虚拟内存&lt;/p&gt;&#xA;&lt;p&gt;虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。在Linux中，地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都是一样。地址空间的底部区域存放用户进程定义的代码和数据。注意，地址是从下往上增大的。从下往上依次是：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;程序代码和数据。&lt;/li&gt;&#xA;&lt;li&gt;堆&lt;/li&gt;&#xA;&lt;li&gt;共享库&lt;/li&gt;&#xA;&lt;li&gt;栈&lt;/li&gt;&#xA;&lt;li&gt;内核虚拟内存&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;文件&lt;/p&gt;&#xA;&lt;p&gt;文件就是字节序列，每个I/O设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;系统之间利用网络通信&#34;&gt;系统之间利用网络通信&lt;/h3&gt;&#xA;&lt;h2 id=&#34;程序结构和执行&#34;&gt;程序结构和执行&lt;/h2&gt;&#xA;&lt;h3 id=&#34;信息的表示和处理&#34;&gt;信息的表示和处理&lt;/h3&gt;&#xA;&lt;h4 id=&#34;信息存储&#34;&gt;信息存储&lt;/h4&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;十六进制表示法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;字数据大小&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;寻址和字节顺序&lt;/p&gt;&#xA;&lt;p&gt;大端法小端法&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;表示字符串&lt;/p&gt;&#xA;&lt;p&gt;C语言中字符串被编码为一个以null(其值为0)字符结尾的字符数组。每个字符都同某个标准编码来表示，最常见的是ASCII字符码。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;表示代码&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;布尔代数简介&lt;/p&gt;</description>
    </item>
    <item>
      <title>如何设计程序</title>
      <link>https://stoneepigraph.github.io/posts/book/common/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Wed, 04 Sep 2024 16:35:00 +0800</pubDate>
      <guid>https://stoneepigraph.github.io/posts/book/common/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A8%8B%E5%BA%8F/</guid>
      <description>&lt;h2 id=&#34;如何设计程序&#34;&gt;如何设计程序&lt;/h2&gt;&#xA;&lt;h3 id=&#34;base&#34;&gt;Base&lt;/h3&gt;&#xA;&lt;h4 id=&#34;基本程序设计步骤&#34;&gt;基本程序设计步骤&lt;/h4&gt;&#xA;&lt;!--list-separator--&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;六个基本的程序设计步骤&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;问题分析和数据定义&lt;/li&gt;&#xA;&lt;li&gt;合约,用途说明与结果的描述,函数头部&lt;/li&gt;&#xA;&lt;li&gt;例子&lt;/li&gt;&#xA;&lt;li&gt;函数模板&lt;/li&gt;&#xA;&lt;li&gt;函数定义&lt;/li&gt;&#xA;&lt;li&gt;测试&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;六个步骤产生定义明确的中间结果&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;问题数据类型描述&lt;/li&gt;&#xA;&lt;li&gt;程序行为的非形式描述&lt;/li&gt;&#xA;&lt;li&gt;说明程序行为的例子&lt;/li&gt;&#xA;&lt;li&gt;开发程序的模板或视图&lt;/li&gt;&#xA;&lt;li&gt;把模板转换成完整的定义&lt;/li&gt;&#xA;&lt;li&gt;通过测试发现错误&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;要正确的设计程序需要做到&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;分析通常使用文字表述的问题&lt;/li&gt;&#xA;&lt;li&gt;在抽象表达问题实质的同时使用例子进行说明&lt;/li&gt;&#xA;&lt;li&gt;用精确的语言阐明所表述的语句和注释&lt;/li&gt;&#xA;&lt;li&gt;通过检查,测试对上述活动进行评价和修改&lt;/li&gt;&#xA;&lt;li&gt;关注细节&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;简单数据的处理&#34;&gt;简单数据的处理&lt;/h3&gt;&#xA;&lt;h4 id=&#34;学生-教师和计算机&#34;&gt;学生,教师和计算机&lt;/h4&gt;&#xA;&lt;p&gt;程序只是计算速度非常快的学生,不过程序并不能理解自然语言,所以我们需要学会一门计算机语言将自然语言翻译给计算机.但程序设计需要耐心和专心,保能关注每个微小的细节,并严格规划和对规划忠诚,才能避免错误.&lt;/p&gt;&#xA;&lt;h4 id=&#34;数-表达式和简单程序&#34;&gt;数,表达式和简单程序&lt;/h4&gt;&#xA;&lt;!--list-separator--&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;数和算术运算&lt;/p&gt;&#xA;&lt;p&gt;讲述了数和Scheme的一些基本知识&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;变量和程序&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;字处理问题&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;错误&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;设计程序&lt;/p&gt;&#xA; &lt;!--list-separator--&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;设计程序至少需要如下4个步骤&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;理解程序的目的程序设计的目标是创建一个接收输入并产生结果的机制.因此在开发程序时应该给每一个程序一个有意义的名字,并且说明输入数据和所产生的数据的类型,这称为程序的合约.&lt;/li&gt;&#xA;&lt;li&gt;构造并标注例子构造一个例子,并将其写入注释&lt;/li&gt;&#xA;&lt;li&gt;程序体写出程序&lt;/li&gt;&#xA;&lt;li&gt;测试检查程序计算所得的结果与预期数值是否相符.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;设计诀窍并不能解决程序设计过程中所遇到的所有问题,它提供的是完成程序设计过程中不可避免的步骤的指导.&lt;/p&gt;&#xA; &lt;!--list-separator--&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;领域知识&lt;/p&gt;&#xA;&lt;p&gt;阐明程序体通常需要与问题相关的知识,这种形式的知识称为领域知识.它可能来自简单或复杂的数学,或来自非数学学科.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;程序就是函数加上变量定义&#34;&gt;程序就是函数加上变量定义&lt;/h4&gt;&#xA;&lt;!--list-separator--&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;函数的复合&lt;/p&gt;&#xA;&lt;p&gt;辅助函数原则: 对问题表述中所提到的或在进行实例计算中所发现的每种依赖关系都使用一个辅助函数进行明确表达.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;变量定义&lt;/p&gt;&#xA;&lt;p&gt;如果一个数值在程序中多次出现,应该使用变量定义给它一个名字.变量定义将一个名字与一个值相关联.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;条件表达式和函数&#34;&gt;条件表达式和函数&lt;/h4&gt;&#xA;&lt;!--list-separator--&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;布尔类型和关系&lt;/p&gt;&#xA;&lt;p&gt;复合条件: and or not&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;函数和测试条件&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;条件和条件函数&lt;/p&gt;</description>
    </item>
    <item>
      <title>Awk入门</title>
      <link>https://stoneepigraph.github.io/posts/awk/</link>
      <pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/awk/</guid>
      <description>&lt;h2 id=&#34;awk语言&#34;&gt;AWK语言&lt;/h2&gt;&#xA;&lt;h2 id=&#34;变量&#34;&gt;变量&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;NF： awk计算当前行的字段数量&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;NR： awk计算到目前为止，读取到的行的数量&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;$0: 整行内容&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;$1: 第一个字段&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;$N: 第N个字段&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;#: 注释&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;逻辑&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&amp;amp;&amp;amp;&lt;/li&gt;&#xA;&lt;li&gt;||&lt;/li&gt;&#xA;&lt;li&gt;!&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;模式&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;BEGIN&#xA;在第一个输入文件的第一行之前被匹配&lt;/li&gt;&#xA;&lt;li&gt;END&#xA;在最后一个输入文件的最后一行被处理之后匹配例：&#xA;awk -F &amp;lsquo;:&amp;rsquo; &amp;lsquo;BEGIN {print &amp;ldquo;id    name    shell&amp;rdquo;; print &amp;ldquo;&amp;rdquo;}&#xA;{emp = emp + 1; print NF, $1, $NF}&#xA;END {print &amp;ldquo;total rows: &amp;ldquo;, emp}&amp;rsquo; /etc/passwd&lt;/li&gt;&#xA;&lt;li&gt;expression { statements}&#xA;每碰到一个使expression为真的输入行，statements就执行， expression为真指的是其值非零或非空&lt;/li&gt;&#xA;&lt;li&gt;&lt;em&gt;regular expression&lt;/em&gt; {statements}&#xA;当碰到这样一个输入行时， statements就执行： 输入行含有一段字符串，而该字符串可以被regular expression匹配&lt;/li&gt;&#xA;&lt;li&gt;compound parttern {statements}&#xA;一个复合模式将表达式用 &amp;amp;&amp;amp;(AND), ||(OR), !(NOT), 以及括号组合起来；当compound parttern为真时， statements执行。&lt;/li&gt;&#xA;&lt;li&gt;pattern1, pattern2 { statemtnts }&#xA;一个范围模式匹配多个输入行，这些输入行从匹配pattern1的行开始，到匹配pattern2的行结束（包括这两行）， 对这其中的每一行执行statements.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;流程控制&lt;/p&gt;</description>
    </item>
    <item>
      <title>Docker笔记</title>
      <link>https://stoneepigraph.github.io/posts/docker/</link>
      <pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/docker/</guid>
      <description>&lt;h2 id=&#34;入门&#34;&gt;入门&lt;/h2&gt;&#xA;&lt;h3 id=&#34;什么是docker&#34;&gt;什么是Docker&lt;/h3&gt;&#xA;&lt;p&gt;docker是一个容器技术。&lt;/p&gt;&#xA;&lt;h3 id=&#34;docker的优势&#34;&gt;Docker的优势&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;一致的运行环境， 更轻松的迁移。&lt;/li&gt;&#xA;&lt;li&gt;对进程进行封装隔离，容器与容器之间互不影响，更高效的利用系统资源。&lt;/li&gt;&#xA;&lt;li&gt;通过镜像复制多个环境一致的容器。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;docker与虚拟机的对比&#34;&gt;Docker与虚拟机的对比&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Docker占用磁盘少&lt;/li&gt;&#xA;&lt;li&gt;Docker的引擎比虚拟机系统占用CPU资源低&lt;/li&gt;&#xA;&lt;li&gt;Docker启动速度快&lt;/li&gt;&#xA;&lt;li&gt;Docker安装管理方便&lt;/li&gt;&#xA;&lt;li&gt;Docker从第二次部署开始轻松简捷&lt;/li&gt;&#xA;&lt;li&gt;Docker可以每个应用使用一个服务，服务隔离&lt;/li&gt;&#xA;&lt;li&gt;Docker推荐使用Linux，不推荐使用Windows&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;安装及配置&#34;&gt;安装及配置&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;下载安装&lt;/li&gt;&#xA;&lt;li&gt;配置&#xA;&lt;ol&gt;&#xA;&lt;li&gt;启动Docker&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo systemctl enable docker&#xA;sudo systemctl start docker&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;创建Docker用户组&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo groupadd docker&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;将当前用户添加到docker组&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo usermod -aG docker $USER&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;测试Docker是否安装正确&lt;/li&gt;&#xA;&lt;li&gt;重启Docker&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo systemctl restart docker&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;docker核心概念&#34;&gt;Docker核心概念&lt;/h3&gt;&#xA;&lt;h4 id=&#34;整体架构图&#34;&gt;整体架构图&lt;/h4&gt;&#xA;&lt;figure&gt;&lt;img src=&#34;https://stoneepigraph.github.io/ox-hugo/2021-01-10_17-34-07_screenshot.png&#34;&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;h4 id=&#34;仓库-repository&#34;&gt;仓库 Repository&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;定义： 用来存储Docker中的镜像。&lt;/li&gt;&#xA;&lt;li&gt;分类：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;远程仓库&lt;/li&gt;&#xA;&lt;li&gt;本地仓库： 当前自己机器中下载镜像存储位置。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;镜像-image&#34;&gt;镜像 Image&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;定义： 一个镜像代表一个软件安装包。&lt;/li&gt;&#xA;&lt;li&gt;特点： 只读&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;容器-container&#34;&gt;容器 Container&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;定义： 基于某个镜像启动的实例，称之为一个服务。&lt;/li&gt;&#xA;&lt;li&gt;特定： 可读可写&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;常用命令&#34;&gt;常用命令&lt;/h3&gt;&#xA;&lt;h4 id=&#34;引擎-以及镜像相关的操作&#34;&gt;引擎， 以及镜像相关的操作&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;docker info&lt;/li&gt;&#xA;&lt;li&gt;docker &amp;ndash;help || docker 查看docker所有帮助命令&lt;/li&gt;&#xA;&lt;li&gt;docker version&lt;/li&gt;&#xA;&lt;li&gt;docker 执行命令格式： docker [options] command&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;操作镜像images的相关命令&#34;&gt;操作镜像images的相关命令&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;查看本地的镜像&#xA;docker images&lt;/li&gt;&#xA;&lt;li&gt;下载新的镜像&#xA;docker pull dockerImageName:dockerVersion&#xA;docker pull dockerImageName:@digest(摘要)&lt;/li&gt;&#xA;&lt;li&gt;搜索镜像&#xA;docker search dockerImageName&lt;/li&gt;&#xA;&lt;li&gt;删除镜像&#xA;docker image rm dockerImageName:dockerVersion&#xA;docker image rm dockerImageId&#xA;docker rmi &amp;hellip;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;容器相关-container&#34;&gt;容器相关 Container&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;运行容器&#xA;docker run dockerImageName:tag | 镜像ID&#xA;&lt;ol&gt;&#xA;&lt;li&gt;映射端口&#xA;docker run -p 宿主机端口:容器内服务端口 dockerImageName&lt;/li&gt;&#xA;&lt;li&gt;后台运行&#xA;-d&lt;/li&gt;&#xA;&lt;li&gt;给容器命名，唯一&#xA;&amp;ndash;name containerName&lt;/li&gt;&#xA;&lt;li&gt;-it&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;导入容器&#xA;docker load -i dockerTag.tar&lt;/li&gt;&#xA;&lt;li&gt;查看当前运行的容器&#xA;docker ps&#xA;&lt;ul&gt;&#xA;&lt;li&gt;查看所有的容器，包括已停止的&#xA;docker ps -a&lt;/li&gt;&#xA;&lt;li&gt;返回正在运行的容器ID&#xA;docker ps -q&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;重启，停止容器&#xA;docker start dockerContainerId | dockerName&#xA;docker restart dockerContainerid | dockerName&#xA;docker stop dockerCOntainerid | dockerName&lt;/li&gt;&#xA;&lt;li&gt;删除容器&#xA;docker rm dockerContainerId | dockerName&#xA;&lt;ol&gt;&#xA;&lt;li&gt;强制删除， 包括正在运行的容器&#xA;docker rm -f dockerContainerid | dockerName&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;查看容器内运行日志&#xA;docker log dockerContainerid | dockerName&#xA;&lt;ol&gt;&#xA;&lt;li&gt;实时查看日志&#xA;-f&lt;/li&gt;&#xA;&lt;li&gt;加入时间戳实时展示日志&#xA;-t&lt;/li&gt;&#xA;&lt;li&gt;显示指定行数的日志&#xA;&amp;ndash;tail Number&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;查看容器内的进程&#xA;docker top dockerContainerid | dockerName&lt;/li&gt;&#xA;&lt;li&gt;与容器内部进行交互&#xA;docker exec -it dockerCOntainerid | dockerName Command [args]&lt;/li&gt;&#xA;&lt;li&gt;宿主与容器的传输文件&#xA;&lt;ol&gt;&#xA;&lt;li&gt;从容器到操作系统&#xA;docker cp dockerContainerid | dockerName :/path/file ./file&lt;/li&gt;&#xA;&lt;li&gt;从宿主到容器&#xA;docker cp 文件 | 目录 dockerContainerid | dockerName: 容器内目录&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;查看容器内部细节&#xA;docker inspect dockerContainerid | dockerName&lt;/li&gt;&#xA;&lt;li&gt;数据卷 Volume&#xA;&lt;ol&gt;&#xA;&lt;li&gt;使用： 实现襥机系统与容器之间的文件共享&lt;/li&gt;&#xA;&lt;li&gt;特点：&#xA;&lt;ol&gt;&#xA;&lt;li&gt;数据卷可以在容器之间共享和重用。&lt;/li&gt;&#xA;&lt;li&gt;对数据卷的修改会立即影响到对应容器。&lt;/li&gt;&#xA;&lt;li&gt;对数据卷的更新修改，不会影响镜像。&lt;/li&gt;&#xA;&lt;li&gt;数据卷默认会一直存在， 即使容器被删除。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;使用&#xA;&lt;ol&gt;&#xA;&lt;li&gt;自定义数据卷&#xA;docker run -v 宿主机目录:容器目录:ro dockerImageId&lt;/li&gt;&#xA;&lt;li&gt;自动创建数据卷&#xA;docker run -v 卷名:容器内路径 dockerImageId&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;查看卷&#xA;docker volume inspect volumeName&#xA;docker volume ls&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;将正在运行的容器打包成镜像&#xA;docker commit -m &amp;rsquo;&amp;rsquo; -a &amp;rsquo;&amp;rsquo; dockerContainerid dockerImageName:dockerTag&lt;/li&gt;&#xA;&lt;li&gt;将镜像备份&#xA;docker save 镜像名称:tag -o dockerBak-tag.tar&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;网络配置&#34;&gt;网络配置&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;docker容器与操作系统通信机制默认使用网桥&lt;/p&gt;</description>
    </item>
    <item>
      <title>Flask Web开发实战</title>
      <link>https://stoneepigraph.github.io/posts/flask-web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</link>
      <pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/flask-web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</guid>
      <description>&lt;h2 id=&#34;flask-web开发实战&#34;&gt;Flask Web开发实战&lt;/h2&gt;&#xA;&lt;h3 id=&#34;基础&#34;&gt;基础&lt;/h3&gt;&#xA;&lt;h4 id=&#34;初识&#34;&gt;初识&lt;/h4&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;开发环境&lt;/p&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;pipenv工作流&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;pip install pipenv&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA; &lt;!--quoteend--&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;pipenv install # 创建虚拟环境&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA; &lt;!--quoteend--&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;pipenv shell # 进入虚拟环境&#xA;pipenv run command #使用虚拟环境执行命令&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA; &lt;!--quoteend--&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;pipenv graph # 查看当前环境的依赖&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Hello，Flask&lt;/p&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;创建程序实例&lt;/p&gt;&#xA;&lt;p&gt;新建app.py(可以是除flask.py之外任意名字)&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;from flask import Flask&#xA;app = Flask(&lt;span class=&#34;underline&#34;&gt;&lt;span class=&#34;underline&#34;&gt;&lt;span class=&#34;underline&#34;&gt;&lt;span class=&#34;underline&#34;&gt;name&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;)&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;注册路由&lt;/p&gt;&#xA;&lt;p&gt;概括：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;用户在浏览器输入URL访问某个资源&lt;/li&gt;&#xA;&lt;li&gt;Flask接收用户请求并分析请求的URL&lt;/li&gt;&#xA;&lt;li&gt;为这个URL找到对应的处理函数&lt;/li&gt;&#xA;&lt;li&gt;执行函数并生成响应，浏览器&lt;/li&gt;&#xA;&lt;li&gt;浏览器接收并解析响应，将信息显示在页面中。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;?? (????)(&amp;rsquo;/&amp;rsquo;)&#xA;def index():&#xA;​return &#39;&lt;/p&gt;&#xA;&lt;div class=&#34;html&#34;&gt;&#xA;&lt;p&gt;&amp;lt;h1&amp;gt;&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;hello, world&lt;/p&gt;&#xA;&lt;div class=&#34;html&#34;&gt;&#xA;&lt;p&gt;&amp;lt;/h1&amp;gt;&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;&#39;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;可以为视图绑定多个URL&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;?? ()(&amp;lsquo;hi&amp;rsquo;)&#xA;?? ()(&amp;rsquo;/hello&amp;rsquo;)&#xA;def say_hello():&#xA;​return &#39;&lt;/p&gt;&#xA;&lt;div class=&#34;html&#34;&gt;&#xA;&lt;p&gt;&amp;lt;h1&amp;gt;&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;Hello, Flask!&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java8函数式编程</title>
      <link>https://stoneepigraph.github.io/posts/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</guid>
      <description>&lt;h2 id=&#34;函数式编程&#34;&gt;函数式编程&lt;/h2&gt;&#xA;&lt;p&gt;函数式编程中没有赋值语句,因此变量一旦有了值,就不会再改变了.更通俗地说,函数式编程完全没有副作用.&lt;/p&gt;&#xA;&lt;h2 id=&#34;lambda表达式&#34;&gt;Lambda表达式&lt;/h2&gt;&#xA;&lt;h3 id=&#34;格式&#34;&gt;格式&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;() -&amp;gt; {}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;参数：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;(): 表式没有参数&lt;/li&gt;&#xA;&lt;li&gt;单个参数可不加括号&lt;/li&gt;&#xA;&lt;li&gt;参数可以不加类型，由编译器去推断类型，也可以加上类型。加类型的话需要使用小括号包起来。&lt;/li&gt;&#xA;&lt;li&gt;参数引用的值而不是变量。但不必须写final变量。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;主体：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可以是一个表达式，也可以是一段代码块，如果是一段代码块需要使用大括号包起来。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;函数式接口&#34;&gt;函数式接口&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Java里函数式接口的主要类型&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;接口&lt;/th&gt;&#xA;          &lt;th&gt;参数&lt;/th&gt;&#xA;          &lt;th&gt;返回类型&lt;/th&gt;&#xA;          &lt;th&gt;示例&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&lt;/td&gt;&#xA;          &lt;td&gt;&amp;mdash;-&lt;/td&gt;&#xA;          &lt;td&gt;&amp;mdash;&amp;mdash;&amp;ndash;&lt;/td&gt;&#xA;          &lt;td&gt;&amp;mdash;-&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Predicate&amp;lt;T&amp;gt;&lt;/td&gt;&#xA;          &lt;td&gt;T&lt;/td&gt;&#xA;          &lt;td&gt;boolean&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Consumer&amp;lt;T&amp;gt;&lt;/td&gt;&#xA;          &lt;td&gt;T&lt;/td&gt;&#xA;          &lt;td&gt;void&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Function&amp;lt;T, R&amp;gt;&lt;/td&gt;&#xA;          &lt;td&gt;T&lt;/td&gt;&#xA;          &lt;td&gt;R&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Supplier&amp;lt;T&amp;gt;&lt;/td&gt;&#xA;          &lt;td&gt;None&lt;/td&gt;&#xA;          &lt;td&gt;T&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;UnaryOperator&amp;lt;T&amp;gt;&lt;/td&gt;&#xA;          &lt;td&gt;T&lt;/td&gt;&#xA;          &lt;td&gt;T&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;BinaryOperator&amp;lt;T&amp;gt;&lt;/td&gt;&#xA;          &lt;td&gt;T, T&lt;/td&gt;&#xA;          &lt;td&gt;T&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;流-stream&#34;&gt;流（Stream）&lt;/h2&gt;&#xA;&lt;p&gt;Stream是用函数式编程方式 在集合类上进行复杂操作的工具。&lt;/p&gt;&#xA;&lt;h3 id=&#34;特点&#34;&gt;特点：&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;惰性求值。看返回值是Stream就是惰性求值。如果返回值是另一个值 或空，那么就是及早求值。&lt;/li&gt;&#xA;&lt;li&gt;可链式操作。&lt;/li&gt;&#xA;&lt;li&gt;和Iterator类似，Stream是一种内部迭代试。内部迭代将更多的控制权交给了集合类。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;常用流操作&#34;&gt;常用流操作&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;collect(toList())&#xA;生成一个列表，及早求值操作。&lt;/li&gt;&#xA;&lt;li&gt;map&#xA;将一个流中的值转换成一个新的流。参数是一个只接受一个String类型参数并返回一个新的String的Lambda（Function）。&lt;/li&gt;&#xA;&lt;li&gt;filter&#xA;过滤流中的数据。参数是一个Predicate式的Lambda表达式。&lt;/li&gt;&#xA;&lt;li&gt;flatMap&#xA;可用Stream替换值，然后并多个Stream连接成一个Stream。参数 是一个Function接口的Lambda表达式。&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;multiList.stream()&#xA;  .flatmap(item -&amp;gt; item.getSubList())&#xA;        .filter(obj -&amp;gt; obj.getLength() &amp;gt; 100)&#xA;        .map(obj -&amp;gt; obj.getName())&#xA;        .collect(Collections.toList());&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;max和min&#xA;参数是一个Comparator对象。&lt;/li&gt;&#xA;&lt;li&gt;reduce&#xA;实现从一组值中生成一个值。参数是BinaryOperator式的Lambda表达式。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;类库&#34;&gt;类库&lt;/h2&gt;&#xA;&lt;h3 id=&#34;基本类型&#34;&gt;基本类型&lt;/h3&gt;&#xA;&lt;p&gt;Stream类的某些方法对基本类型和装箱类型做了区分。&#xA;&amp;gt; e.g. ToLongFunction(), LongFunction()&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linux命令行与Shell脚本大全</title>
      <link>https://stoneepigraph.github.io/posts/os/linux/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E5%A4%A7%E5%85%A8/</link>
      <pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/os/linux/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E5%A4%A7%E5%85%A8/</guid>
      <description>&lt;h2 id=&#34;linux命令行&#34;&gt;Linux命令行&lt;/h2&gt;&#xA;&lt;h3 id=&#34;初识linux-shell&#34;&gt;初识Linux Shell&lt;/h3&gt;&#xA;&lt;h4 id=&#34;什么是linux&#34;&gt;什么是Linux&lt;/h4&gt;&#xA;&lt;p&gt;Linux可划分为以下四部分：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Linux内核&lt;/li&gt;&#xA;&lt;li&gt;GNU工具&lt;/li&gt;&#xA;&lt;li&gt;图形化桌面环境&lt;/li&gt;&#xA;&lt;li&gt;应用软件&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;深入探究Linux内核&lt;/p&gt;&#xA;&lt;p&gt;内核主要负责以下四种功能：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;系统内存管理&lt;/li&gt;&#xA;&lt;li&gt;软件程序管理&lt;/li&gt;&#xA;&lt;li&gt;硬件设备管理&lt;/li&gt;&#xA;&lt;li&gt;文件系统管理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;系统内存管理&lt;/p&gt;&#xA;&lt;p&gt;不公管理服务器上的可用物理内存，还可以创建和不容易理虚拟内存。内核通过硬盘上的存储空间来实现虚拟内存，这块区域称为交换空间（swap space）。内丰存储单元按组划分成很多块，这些块称作页面（page）。内核将每个存在 页面放在物理内存或交换空间。然后， 内核 会维护一个内存页面表。指明哪些页面位于物理内存内，哪些页面被换到硬盘上。内核会记录哪些内存页面正在使用中，并自动把一段时间未访问的内存页面复制 到交换空间区域（称为换出，swapping out_）即使不宜可用内存。当程序要访问一个已被换出的内存页面时，内核必需从物理内存换出另外一个内存页面给它让出空间，然后从交换空间换入请求的内存页面。显然，这个过程 要花时间，拖慢运行的进程。只要Linux系统在运行，为运行中的程序换出内存面对面的的过程 就不会停歇。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;软件程序管理&lt;/p&gt;&#xA;&lt;p&gt;Linux操作系统将运行中的程序称为进程。可分为前台运行和后台运行。内核控制着Linux系统管理运行在系统上的所有进程。内核创建了第一个进程（称为init进程）来启动系统上所有的其他进程。当内核启动时，它会将init进程加载到虚拟 内存中。内核 在启动任何其他进程时，都 会在虚拟 内存中给新进程分配 一块发你的区域 来存储该 进程用到的数据和代码。一些Linux发行版使用一个表来管理在系统开机时要自动 启动的进程。在Linux系统上，这个表通常位于专门文件/etc/inittab中。有的系统（如Ubuntu）则采用/etc/init.d目录将开机时启动或停止某个应用的脚本 放在之个目录 下。这些脚本通过/etc/rcX.d目录下的入口 启动。X代表运行级别。运行级别：​&#x9;1.单用户​&#x9;3.标准启动​&#x9;5.X Windows&#xA;​&#x9;6.重启&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;硬件设备管理&lt;/p&gt;&#xA;&lt;p&gt;内核的另一职责 是管理硬件设备。任何Linux系统需要 与之通信的设备，都需要在内核 代码 中加入其驱动程序 代码。程序 代码相当 于应用程序 和硬件设备的中间人，允许内核 与设备之间交换数据。在Linux内核 中有两种方法用于插入设备驱动代码：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;编译进内核 的设备驱动 代码&lt;/li&gt;&#xA;&lt;li&gt;可插入内核 的设备驱动 模块&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Linxu系统将硬件设备当成特殊 的文件，称为设备文件，设备文件有3种分类：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;字符型 设备谁的指处理数据时每次只能处理一个字符 的设备。大多数类型的调制解调器和终端都是作为字符型设备文件创建 的。&lt;/li&gt;&#xA;&lt;li&gt;块设备文件块设备是指处理数据时每次能处理大块数据 的设备，比如硬盘。&lt;/li&gt;&#xA;&lt;li&gt;网络设备文件是指采用数据包发送和接收数据 的设备，包括各种网卡和一个特殊 的回环设备。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Linux为系统上的每个设备都创建 一种称为节点的特殊文件。与设备的所有通信都 通过设备节点完成。每个节点都 有唯一 的数值 对供Linux内核 标识 它。数值 对包括一个主设备号和一个次设备号。类似的设备被划分到同样的主设备号下。次设备号用于标识 主设备组下的某个特定设备。&lt;/p&gt;</description>
    </item>
    <item>
      <title>maven基础</title>
      <link>https://stoneepigraph.github.io/posts/language/java/maven/</link>
      <pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/language/java/maven/</guid>
      <description>&lt;h2 id=&#34;maven库&#34;&gt;Maven库：&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://repo2.maven.org/maven2/&#34;&gt;http://repo2.maven.org/maven2/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;maven依赖查询&#34;&gt;Maven依赖查询：&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://mvnrepository.com/&#34;&gt;http://mvnrepository.com/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;maven常用命令&#34;&gt;Maven常用命令：&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;创建Maven的普通java项目：&#xA;mvn archetype:create&#xA;-DgroupId=packageName&#xA;-DartifactId=projectName&lt;/li&gt;&#xA;&lt;li&gt;创建Maven的Web项目：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;​    mvn archetype:create&#xA;​    -DgroupId=packageName&#xA;​    -DartifactId=webappName&#xA;​    -DarchetypeArtifactId=maven-archetype-webapp&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;编译源代码： mvn compile&lt;/li&gt;&#xA;&lt;li&gt;编译测试代码：mvn test-compile&lt;/li&gt;&#xA;&lt;li&gt;运行测试：mvn test&lt;/li&gt;&#xA;&lt;li&gt;产生site：mvn site&lt;/li&gt;&#xA;&lt;li&gt;打包：mvn package&lt;/li&gt;&#xA;&lt;li&gt;在本地Repository中安装jar：mvn install&lt;/li&gt;&#xA;&lt;li&gt;清除产生的项目：mvn clean&lt;/li&gt;&#xA;&lt;li&gt;生成eclipse项目：mvn eclipse:eclipse&lt;/li&gt;&#xA;&lt;li&gt;生成idea项目：mvn idea:idea&lt;/li&gt;&#xA;&lt;li&gt;组合使用goal命令，如只打包不测试：mvn -Dtest package&lt;/li&gt;&#xA;&lt;li&gt;编译测试的内容：mvn test-compile&lt;/li&gt;&#xA;&lt;li&gt;只打jar包: mvn jar:jar&lt;/li&gt;&#xA;&lt;li&gt;只测试而不编译，也不测试编译：mvn test -skipping compile -skipping test-compile&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;​      ( -skipping 的灵活运用，当然也可以用于其他组合命令)&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;清除eclipse的一些系统设置:mvn eclipse:clean&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;ps：一 般使用情况是这样，首先通过cvs或svn下载代码到本机，然后执行mvn eclipse:eclipse生成ecllipse项目文件，然后导入到eclipse就行了；修改代码后执行mvn compile或mvn test检验，也可以下载eclipse的maven插件。&#xA;mvn -version/-v  显示版本信息&#xA;mvn archetype:generate        创建mvn项目&#xA;mvn archetype:create -DgroupId=com.oreilly -DartifactId=my-app   创建mvn项目&#xA;mvn package            生成target目录，编译、测试代码，生成测试报告，生成jar/war文件&#xA;mvn jetty:run            运行项目于jetty上,&#xA;mvn compile                    编译&#xA;mvn test                    编译并测试&#xA;mvn clean                    清空生成的文件&#xA;mvn site                    生成项目相关信息的网站&#xA;mvn -Dwtpversion=1.0 eclipse:eclipse        生成Wtp插件的Web项目&#xA;mvn -Dwtpversion=1.0 eclipse:clean        清除Eclipse项目的配置信息(Web项目)&#xA;mvn eclipse:eclipse                将项目转化为Eclipse项目在应用程序用使用多个存储库&lt;/p&gt;</description>
    </item>
    <item>
      <title>Nginx-note</title>
      <link>https://stoneepigraph.github.io/posts/middle/nginx-note/</link>
      <pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/middle/nginx-note/</guid>
      <description>&lt;h2 id=&#34;Nginx基础&#34;&gt;Nginx基础1&lt;/h2&gt;&#xA;&lt;h3 id=&#34;nginx架构&#34;&gt;Nginx架构&lt;/h3&gt;&#xA;&lt;h4 id=&#34;nginx事件模型&#34;&gt;nginx事件模型&lt;/h4&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;nginx是采用的异步非阻塞。&lt;/p&gt;&#xA;&lt;p&gt;拿epoll为例，当事件没准备好时，放到epoll里，事件准备好了，我们就去读写，当读写返回EAGAIN时，我们将它再次加入到epoll里。这样，只要有事件准备好了，我们就去处理它，只有当所有事件都没准备好时，才在epoll里等着。这样我们就可以并发处理大量的并发了，当然，这里的并发请求，是指未处理完的请求，线程只有一个，所以同时能处理的请求当然只有一个，只是在请求间进行不断切换而已，切换也是因为异步事件未准备好，而主动让出的。这里的切换是没有任何代价的，你可以理解为循环处理多个准备好的事件，事实上就是这样的。与多线程相比，这事事件处理方式是有很大的优势的，不需要创建线程，每个请求占用的内存也很少，没有上下文切换，事件处理非常轻量级。并发数再多也不会导致无谓的资源浪费（上下文切换）。更多的并发数，只是会占用更多的内存而已。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Nginx的worker数最好设置为CPU的核数。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;nginx基本概念&#34;&gt;Nginx基本概念&lt;/h4&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;connection&lt;/p&gt;&#xA;&lt;p&gt;在Nginx中connection就是对tcp连接的封闭，其中包括连接的socket, 读事件，写事件。利用Nginx封闭的Connection，我们可以很方便的使用Nginx来处理与连接相关的事情，比如，建立连接，发送与接受数据等。而Nginx中的http请求的处理就是建立在Connection之上的，所以Nginx不公可以作为一个web服务器， 也可以作为邮件服务器。当然，利用Nginx提供的Connection,我们可以与任何后端服务打交道。&lt;/p&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Nginx处理连接的流程&lt;/p&gt;&#xA;&lt;p&gt;首先Nginx在启动时，会解析配置文件，得到需要监听的端口与IP地址，然后在Nginx的master进程里面，先初始化好这个监控的socket（创建Socket， 设置Addrreuse等选项，绑定到指定的IP地址端口，再Listen），然后再fork出多个子进程出来，然后子进程会竞争accept新的连接。此时，客户端就可以向Nginx发起连接了。当客户端与服务端通过三次握手建立好一个连接后，Nginx的某一个子进程会Accept成功，得到这个建立好的连接的Socket，然后创建Nginx对连接的封闭，即ngx_connection_t结构体。接着，设置读写事件处理函数并添加读写事件来与客户端进行数据的交换。最后，Nginx或客户端主动关掉连接，到此，一个连接就结束了。&#xA;Nginx在实现时，是通过一个连接池来管理的，这里的连接池里保存的其实不是真实的连接，它只是一个worker_connections(不大于系统对fd的限制)大小的ngx_connection_t结构体的数组。并且，Nginx会通过一个链表free_connections来保存所有的空闲ngx_connection_t，每次获取一个连接时，就从空闲连接链表里获取一个，用完后，再放回空间连接链表里。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;request&lt;/p&gt;&#xA;&lt;p&gt;在Ningx中request我们指的是http请求，具体到Nginx中的数据结构是ngx_http_request_t。它是对一个Http请求的封装。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;指令&#34;&gt;指令&lt;/h3&gt;&#xA;&lt;h4 id=&#34;server&#34;&gt;server&lt;/h4&gt;&#xA;&lt;p&gt;用于定义服务，http中可以有多个server块&lt;/p&gt;&#xA;&lt;h4 id=&#34;listen&#34;&gt;listen&lt;/h4&gt;&#xA;&lt;p&gt;指定服务器侦听请求的IP地址和端口，如果省略地址，服务器将侦听所有地址，如果省略端口，则使用标准端口&lt;/p&gt;&#xA;&lt;h4 id=&#34;server-name&#34;&gt;server_name&lt;/h4&gt;&#xA;&lt;p&gt;服务名称，用于配置域名使用_表示不做域名匹配.&lt;/p&gt;&#xA;&lt;h4 id=&#34;location&#34;&gt;location&lt;/h4&gt;&#xA;&lt;p&gt;用于配置映射路径uri对应的配置，一个server中可以有多个location, location后面跟一个uri,可以是一个正则表达式，/表示匹配任意路径，当客户端访问的路径满足这个uri时就会执行location块里的代码&lt;/p&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;修饰符&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;= 进行普通字符精确匹配。也就是完全匹配&lt;/li&gt;&#xA;&lt;li&gt;^~ 前缀匹配。如果匹配成功，则不再匹配其他location.&lt;/li&gt;&#xA;&lt;li&gt;~ 表示执行一个正则匹配，区分大小写&lt;/li&gt;&#xA;&lt;li&gt;~* 表示执行一个正则匹配，不区分大小写&lt;/li&gt;&#xA;&lt;li&gt;&lt;em&gt;xxx&lt;/em&gt; 常规字符串路径匹配&lt;/li&gt;&#xA;&lt;li&gt;/ 通用匹配， 任何请求都会匹配到&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;检查顺序&lt;/p&gt;&#xA;&lt;p&gt;location = &amp;gt; location 完整路径 &amp;gt; location ^~ &amp;gt; location ~, ~* &amp;gt; location 部分起始路径 &amp;gt; /&#xA;注意： location的优先级与location配置的位置无关&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;正则表达式&lt;/p&gt;</description>
    </item>
    <item>
      <title>Python CookBook</title>
      <link>https://stoneepigraph.github.io/posts/python-cookbook/</link>
      <pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/python-cookbook/</guid>
      <description>&lt;h2 id=&#34;数据结构与算法&#34;&gt;数据结构与算法&lt;/h2&gt;&#xA;&lt;h3 id=&#34;解压序列赋值给多个变量&#34;&gt;解压序列赋值给多个变量&lt;/h3&gt;&#xA;&lt;p&gt;注意_, /, /_, 级别的使用&lt;/p&gt;&#xA;&lt;h3 id=&#34;保留最后n个元素&#34;&gt;保留最后N个元素&lt;/h3&gt;&#xA;&lt;p&gt;collections deque&lt;/p&gt;&#xA;&lt;h3 id=&#34;查找最大或最小的n个元素&#34;&gt;查找最大或最小的N个元素&lt;/h3&gt;&#xA;&lt;p&gt;heapq.nlargest(count, list)&#xA;heapq.nsmallest(count, list)&lt;/p&gt;&#xA;&lt;h3 id=&#34;实现一个优先级队列&#34;&gt;实现一个优先级队列&lt;/h3&gt;&#xA;&lt;p&gt;heapq.heappush()&#xA;heapq.heappop()&lt;/p&gt;&#xA;&lt;h3 id=&#34;字典中的键映射多个值&#34;&gt;字典中的键映射多个值&lt;/h3&gt;&#xA;&lt;p&gt;可以将多个值放到另外的容器中。也可以全用collections模块中的defaultdict来构造这样的字典&lt;/p&gt;&#xA;&lt;h3 id=&#34;字典排序&#34;&gt;字典排序&lt;/h3&gt;&#xA;&lt;p&gt;可以使用collections模块中的OrderedDict类，它会保持元素被插入时的顺序。&lt;/p&gt;&#xA;&lt;h3 id=&#34;字典的运算&#34;&gt;字典的运算&lt;/h3&gt;&#xA;&lt;p&gt;对字典运算，通常需要使用zip()函数先将键值反转过来。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;zip(dict.values(), dict.keys())&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;可以使用sorted()对反转后的字典进行排序。因为你在一个字典上执行普通的数字运算，它们仅仅作用于键，而不是值 。&lt;/p&gt;&#xA;&lt;h3 id=&#34;查找两个字典的相同点&#34;&gt;查找两个字典的相同点&lt;/h3&gt;&#xA;&lt;p&gt;可以简单的在两字典的keys()或者items()方法返回结果上执行集合操作。&lt;/p&gt;&#xA;&lt;h3 id=&#34;删除序列相同元素并保持顺序&#34;&gt;删除序列相同元素并保持顺序&lt;/h3&gt;&#xA;&lt;p&gt;如果序列上的值都是hashable类型，那么可以简单的利用集合或者生成器来解决问题。&lt;/p&gt;&#xA;&lt;h3 id=&#34;命令切片&#34;&gt;命令切片&lt;/h3&gt;&#xA;&lt;p&gt;使用s = slice(start, stop, step)避免大量无法理解 的硬编码下标。你还可以使用s.start, s.stop, s.step获取它的属性。&lt;/p&gt;&#xA;&lt;h3 id=&#34;序列中出现次数最多的元素&#34;&gt;序列中出现次数最多的元素&lt;/h3&gt;&#xA;&lt;p&gt;collections.Counter类&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;words = [&amp;hellip;]&#xA;from collections import Counter&#xA;word_counts = Counter(words)&#xA;#出现频率最高的3个单词&#xA;top_three = word_counts.most_common(3)&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;Counter实例还可以很容易的跟数学运算操作相结合。&lt;/p&gt;&#xA;&lt;h3 id=&#34;通过一个关键字排序一个字典列表&#34;&gt;通过一个关键字排序一个字典列表&lt;/h3&gt;&#xA;&lt;p&gt;通过全用operator模块的itemgetter函数。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;rows = [&#xA;{&#39;fname&#39;: &#39;Brian&#39;, &#39;lname&#39;: &#39;Jones&#39;, &#39;uid&#39;: 1003},&#xA;{&#39;fname&#39;: &#39;David&#39;, &#39;lname&#39;: &#39;Beazley&#39;, &#39;uid&#39;: 1002},&#xA;{&#39;fname&#39;: &#39;John&#39;, &#39;lname&#39;: &#39;Cleese&#39;, &#39;uid&#39;: 1001},&#xA;{&#39;fname&#39;: &#39;Big&#39;, &#39;lname&#39;: &#39;Jones&#39;, &#39;uid&#39;: 1004}&#xA;]&#xA;from operator import itemgetter&#xA;rows_by_fname = sorted(rows, key=itemgetter(&#39;fname&#39;))&#xA;rows_by_uid = sorted(rows, key=itemgetter(&#39;uid&#39;))&#xA;rows_by_lfname = sorted(rows, key=itemgetter(&#39;lname&#39;, &#39;fname&#39;))&#xA;# itemgetter也可以使用lambda表达式代替&#xA;rows_by_fname_lambda = sorted(rows, key=lambda r: r[&#39;fname&#39;])&#xA;rows_by_lfname_lambda = sorted(rows, key=lambda r: (r[&#39;lname&#39;], r[&#39;fname&#39;]))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;排序不支持原生比较的对象&#34;&gt;排序不支持原生比较的对象&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class User:&#xA;def __init__(self, user_id):&#xA;self.user_id = user_id&#xA;def __repr__(self):&#xA;return &#39;User({})&#39;.format(self.user_id)&#xA;def sort_notcompare():&#xA;users = [User(23), User(3), User(99)]&#xA;print(users)&#xA;print(sorted(users, key=lambda u: u.user_id))&#xA;# 或者使用operator&#xA;from operator import attrgetter&#xA;sorted(users, key=attrgetter(&#39;user_id&#39;))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;通过某个字段将记录分组&#34;&gt;通过某个字段将记录分组&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;rows = [&#xA;{&#39;address&#39;: &#39;5412 N CLARK&#39;, &#39;date&#39;: &#39;07/01/2012&#39;},&#xA;{&#39;address&#39;: &#39;5148 N CLARK&#39;, &#39;date&#39;: &#39;07/04/2012&#39;},&#xA;{&#39;address&#39;: &#39;5800 E 58TH&#39;, &#39;date&#39;: &#39;07/02/2012&#39;},&#xA;{&#39;address&#39;: &#39;2122 N CLARK&#39;, &#39;date&#39;: &#39;07/03/2012&#39;},&#xA;{&#39;address&#39;: &#39;5645 N RAVENSWOOD&#39;, &#39;date&#39;: &#39;07/02/2012&#39;},&#xA;{&#39;address&#39;: &#39;1060 W ADDISON&#39;, &#39;date&#39;: &#39;07/02/2012&#39;},&#xA;{&#39;address&#39;: &#39;4801 N BROADWAY&#39;, &#39;date&#39;: &#39;07/01/2012&#39;},&#xA;{&#39;address&#39;: &#39;1039 W GRANVILLE&#39;, &#39;date&#39;: &#39;07/04/2012&#39;},&#xA;]&#xA;from operator import itemgetter&#xA;from itertools import groupby&#xA;# Sorted by the desired field first, because groupby only check continuous elements.&#xA;rows.sort(key=itemgetter(&#39;date&#39;))&#xA;# Iterate in groups&#xA;for date, items in groupby(rows, key=itemgetter(&#39;date&#39;)):&#xA;    print(date)&#xA;    for in in items:&#xA;        print(&#39; &#39;, i)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;过滤序列元素&#34;&gt;过滤序列元素&lt;/h3&gt;&#xA;&lt;p&gt;最简单的过滤序列元素的方法就是使用列表推导。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Python核心编程（3）</title>
      <link>https://stoneepigraph.github.io/posts/python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B3/</link>
      <pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B3/</guid>
      <description>&lt;h2 id=&#34;正则表达式&#34;&gt;正则表达式&lt;/h2&gt;&#xA;&lt;h2 id=&#34;网络编程&#34;&gt;网络编程&lt;/h2&gt;&#xA;&lt;h2 id=&#34;因特网客户端编程&#34;&gt;因特网客户端编程&lt;/h2&gt;&#xA;&lt;h3 id=&#34;因特网客户端简介&#34;&gt;因特网客户端简介&lt;/h3&gt;&#xA;&lt;h3 id=&#34;文件传输&#34;&gt;文件传输&lt;/h3&gt;&#xA;&lt;h4 id=&#34;文件传输因特协议&#34;&gt;文件传输因特协议&lt;/h4&gt;&#xA;&lt;p&gt;在当下，HTTP,FTP,scp/rsync的应用仍然广泛。&lt;/p&gt;&#xA;&lt;h4 id=&#34;python和ftp&#34;&gt;Python和FTP&lt;/h4&gt;&#xA;&lt;h4 id=&#34;ftplib.ftp类&#34;&gt;ftplib.FTP类&lt;/h4&gt;&#xA;&lt;h4 id=&#34;客户端ftp程序实例&#34;&gt;客户端FTP程序实例&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#! /usr/bin/env python&#xA;# coding: utf-8&#xA;import ftplib&#xA;import os&#xA;import socket&#xA;HOST = &#39;ftp.mozilla.org&#39;&#xA;DIRN = &#39;pub/mozilla.org/webtools&#39;&#xA;FILE = &#39;bugzilla-LATEST.tar.gz&#39;&#xA;def main():&#xA;    try:&#xA;        f = ftplib.FTP(HOST)&#xA;    except (socket.error, socket.gaierror) as e:&#xA;        print(&amp;quot;ERROR: can&#39;t reach &#39;%s&#39; &amp;quot; % HOST)&#xA;        return&#xA;    print(&amp;quot;*** Connected to host &#39;%s&#39;&amp;quot; % HOST)&#xA;    try:&#xA;        f.login()&#xA;    except ftplib.error_perm:&#xA;        print(&amp;quot;ERROR: can&#39;t login anonymously&amp;quot;)&#xA;        f.quit()&#xA;        return&#xA;    print(&amp;quot;*** Logged in as &#39;anonymous&amp;quot;)&#xA;    try:&#xA;        f.cwd(DIRN)&#xA;    except ftplib.error_perm:&#xA;        print(&amp;quot;ERROR: can&#39;t CD to &#39;%s&amp;quot; % DIRN)&#xA;        f.quit()&#xA;        return&#xA;    print(&amp;quot;*** Change to &#39;%s&#39; folder&amp;quot; % DIRN )&#xA;    try:&#xA;        f.retrbinary(&amp;quot;RETR %s&amp;quot; % FILE, open(FILE, &#39;wb&#39;).write())&#xA;    except ftplib.error_perm:&#xA;        print(&amp;quot;ERROR: can&#39;t read file &#39;%s&#39;&amp;quot; % FILE)&#xA;        os.unlink(FILE)&#xA;    else:&#xA;        print(&amp;quot;*** Download &#39;%s&#39; to CWD&amp;quot; % FILE)&#xA;        f.quit()&#xA;if __name__ == &#39;__main__&#39;:&#xA;    main()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;ftp的其他内容&#34;&gt;Ftp的其他内容&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;命令行客户端程序&lt;/li&gt;&#xA;&lt;li&gt;GUI客户端程序&lt;/li&gt;&#xA;&lt;li&gt;Web浏览器&lt;/li&gt;&#xA;&lt;li&gt;自定义应用程序&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;网络新闻&#34;&gt;网络新闻&lt;/h3&gt;&#xA;&lt;h4 id=&#34;usenet与新闻组&#34;&gt;Usenet与新闻组&lt;/h4&gt;&#xA;&lt;h4 id=&#34;网络新闻传输协议&#34;&gt;网络新闻传输协议&lt;/h4&gt;&#xA;&lt;p&gt;NNTP&lt;/p&gt;</description>
    </item>
    <item>
      <title>SICP</title>
      <link>https://stoneepigraph.github.io/posts/sicp/</link>
      <pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/sicp/</guid>
      <description>&lt;h2 id=&#34;构造过程抽象&#34;&gt;构造过程抽象&lt;/h2&gt;&#xA;&lt;h3 id=&#34;程序设计的基本元素&#34;&gt;程序设计的基本元素&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基本表达式用于表示语言所关心的最简单的个体&lt;/li&gt;&#xA;&lt;li&gt;组合的方法通过它们可以从较简单的东西出发构造出复合的元素&lt;/li&gt;&#xA;&lt;li&gt;抽象的方法通过它们可以为复合对象命名，并将它们当作单元去操作。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;命名环境&#34;&gt;命名环境&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define variable value)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;组合式的求值&#34;&gt;组合式的求值&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;求值该组合式的各个子表达式。&lt;/li&gt;&#xA;&lt;li&gt;将作为最左子表达式的值 的那个过程应用于相应的实际参数。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;复合过程&#34;&gt;复合过程&lt;/h4&gt;&#xA;&lt;p&gt;包括：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;数和算术运算是基本的数据和过程&#xA;&lt;ol&gt;&#xA;&lt;li&gt;组合式的嵌套提供了一种组织起多个操作的方法&lt;/li&gt;&#xA;&lt;li&gt;定义是一种受限的抽象手段，它为名字关联相应的值。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;抽象过程的定义&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (funcName params) body)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;过程应用的代换模型&#34;&gt;过程应用的代换模型&lt;/h4&gt;&#xA;&lt;p&gt;为了求值一个组合式，解释器将对组合式的各个元素求值，而后将得到的那个过程应用于那些实际参数。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;应用序求值先求值参数而后应用&lt;/li&gt;&#xA;&lt;li&gt;正则序求值指“完全展开而后紧约”的求值模型&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;条件表达式和谓词&#34;&gt;条件表达式和谓词&lt;/h4&gt;&#xA;&lt;p&gt;条件表达式的一般形式&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(cond (p1 e1)&#xA;      (p2 e2)&#xA;      .&#xA;      .&#xA;      (pn en))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;受限形式&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(if predicate consequent alternative)&#xA;(define (abs x)&#xA;(if (&amp;lt; x 0)&#xA;(- x)&#xA;x))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;谓词&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-nil&#34;&gt;(and e1 e2)&#xA;(or e1 e2)&#xA;(not e)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;过程作为黑箱的抽象&#34;&gt;过程作为黑箱的抽象&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;局部名过程的意义应该不依赖于其作者为其形式参数所选用的名字&lt;/li&gt;&#xA;&lt;li&gt;内部定义和块结构我们要允许一个过程里带有一些内部定义，使它们是局部于这一过程的。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;!--listend--&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (sqrt x)&#xA;    (define (good-enough? guess x)&#xA;        (&amp;lt; (abs (- (square guess) x)) 0.0001))&#xA;    (define (improve guess x)&#xA;        (average guess (/ x guess)))&#xA;    (define (sqrt-iter guess x)&#xA;        (if (good-enough? guess x)&#xA;            guess&#xA;            (sqrt-iter (improve guess x) x)))&#xA;    (define (square x)&#xA;        (* x x))&#xA;    (define (average x y)&#xA;        (/ (+ x y) 2))&#xA;    (sqrt-iter 1.0 x))&#xA;&#xA;(define (square x)&#xA;    (* x x))&#xA;&#xA;(display (sqrt 8))&#xA;(newline)&#xA;(display (square (sqrt 8)))&#xA;(exit)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;过程与它们所产生的计算&#34;&gt;过程与它们所产生的计算&lt;/h3&gt;&#xA;&lt;h4 id=&#34;增长的阶&#34;&gt;增长的阶&lt;/h4&gt;&#xA;&lt;p&gt;描述不同计算过程在消耗计算资源的速率上可能存在 的差异。一般来说，定义一个不变量，要求它在状态之间保持不变，这一技术是思考迭代算法设计问题时的一种非常强有力的方法。&lt;/p&gt;</description>
    </item>
    <item>
      <title>VIM</title>
      <link>https://stoneepigraph.github.io/posts/vim/</link>
      <pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/vim/</guid>
      <description>&lt;h2 id=&#34;移动光标&#34;&gt;移动光标&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;h j k l&lt;/li&gt;&#xA;&lt;li&gt;{ 移动到上一段&lt;/li&gt;&#xA;&lt;li&gt;}: 移动到下一段&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;搜索&#34;&gt;搜索&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;f加上你想在本行光标往后搜索的字母&lt;/li&gt;&#xA;&lt;li&gt;在想要搜索的word上按*&lt;/li&gt;&#xA;&lt;li&gt;/&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;移动页面&#34;&gt;移动页面&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;zz将光标所在行移动到屏幕中间&lt;/li&gt;&#xA;&lt;li&gt;zt： 将光标所在行移动到行首&lt;/li&gt;&#xA;&lt;li&gt;ab: 将光标所在行移动到行尾&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;选择&#34;&gt;选择&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;v: 进入visual 模式&lt;/li&gt;&#xA;&lt;li&gt;V: 进入visual line模式&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;操作&#34;&gt;操作&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;y: 复制选中的内容&lt;/li&gt;&#xA;&lt;li&gt;yy: 复制一整行&lt;/li&gt;&#xA;&lt;li&gt;p： 在光标后边粘贴&lt;/li&gt;&#xA;&lt;li&gt;P: 在光标前边粘贴&lt;/li&gt;&#xA;&lt;li&gt;u: 撤消上一步操作&lt;/li&gt;&#xA;&lt;li&gt;U：撤消光标落在此行后的所有修改&lt;/li&gt;&#xA;&lt;li&gt;.：重做上一步，&lt;/li&gt;&#xA;&lt;li&gt;c - r : 重作上一步, 重做上一步撤消的内容&lt;/li&gt;&#xA;&lt;li&gt;n. 重做N次上一步&lt;/li&gt;&#xA;&lt;li&gt;&amp;ldquo;ay: 将内容放到a暂存区&lt;/li&gt;&#xA;&lt;li&gt;&amp;ldquo;ap: 将a暂存区的内容粘贴到当前&lt;/li&gt;&#xA;&lt;li&gt;d： 删除选中的内容&lt;/li&gt;&#xA;&lt;li&gt;D：删除光标到行尾的内容&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;11.dd: 删除当前行内容&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;c: 删除选中内容后进入插入模式&lt;/li&gt;&#xA;&lt;li&gt;C：删除光标到行尾的内容并进入插入模式&lt;/li&gt;&#xA;&lt;li&gt;r：替换光标的内容为下一次输入的内容&lt;/li&gt;&#xA;&lt;li&gt;&amp;gt;&amp;gt;: 将当前行向右缩排 shiftwidth 个字符&lt;/li&gt;&#xA;&lt;li&gt;&amp;lt;&amp;lt;: 将当前行向左缩排 shiftwidth 个字符&lt;/li&gt;&#xA;&lt;li&gt;=： 将选中的代码做自动缩排&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;多视窗&#34;&gt;多视窗&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;使用:e filename 打开一个新的文件&lt;/li&gt;&#xA;&lt;li&gt;:tabe filename 新开一个tab&lt;/li&gt;&#xA;&lt;li&gt;gt: 移动到下一个tab&lt;/li&gt;&#xA;&lt;li&gt;gT: 移动到上一个tab&lt;/li&gt;&#xA;&lt;li&gt;:new 开一个新的水平视窗&lt;/li&gt;&#xA;&lt;li&gt;c - w w： 移动到下一个视窗&lt;/li&gt;&#xA;&lt;li&gt;:vnew: 开一个垂直视窗&lt;/li&gt;&#xA;&lt;li&gt;vim -p: 以tabe方式打开多个文件&lt;/li&gt;&#xA;&lt;li&gt;vim -o 以水平分隔方式打开多个文件&lt;/li&gt;&#xA;&lt;li&gt;vim -O 以垂直方式打开多个文件&lt;/li&gt;&#xA;&lt;li&gt;:ls： 查看当前开了哪些文件&lt;/li&gt;&#xA;&lt;li&gt;:bN: 切换到第N个buffer&lt;/li&gt;&#xA;&lt;li&gt;c - 6: 切换到上一个buffer&lt;/li&gt;&#xA;&lt;li&gt;:bn 切换到下一个buffer&lt;/li&gt;&#xA;&lt;li&gt;:b filename 切换到指定的buffer&lt;/li&gt;&#xA;&lt;li&gt;:bd: 关闭当前buffer&lt;/li&gt;&#xA;&lt;li&gt;:tabe ba：将所有的文件以tab形式打开&lt;/li&gt;&#xA;&lt;li&gt;C - v 进入 visual block模式&lt;/li&gt;&#xA;&lt;li&gt;viw: 选中当前光标所在的单词&lt;/li&gt;&#xA;&lt;li&gt;vaw： 选中当前光标所在的单词（大）&lt;/li&gt;&#xA;&lt;li&gt;vit: 选择tag内的内容&lt;/li&gt;&#xA;&lt;li&gt;vat: 选择当前tag整个内容&lt;/li&gt;&#xA;&lt;li&gt;v}： 选中当前到段尾&lt;/li&gt;&#xA;&lt;li&gt;vi&amp;rdquo;: 选中双引号之间的内容&lt;/li&gt;&#xA;&lt;li&gt;vi&amp;rdquo;: 选择双引号连还双引号的内容&lt;/li&gt;&#xA;&lt;li&gt;di&amp;quot;: 删除双引号之间的内容,其中双引号可以替换成单引号，括号等&lt;/li&gt;&#xA;&lt;li&gt;vip: 选中当前段落&lt;/li&gt;&#xA;&lt;li&gt;yip: 复制当前段落&lt;/li&gt;&#xA;&lt;li&gt;dip: 删除当前段落&lt;/li&gt;&#xA;&lt;li&gt;vNw: 选中之后的N个单词&lt;/li&gt;&#xA;&lt;li&gt;^: 移动光标到行首，去除空格&lt;/li&gt;&#xA;&lt;li&gt;0： 移动光标到行乎，含空格&lt;/li&gt;&#xA;&lt;li&gt;:h key-notation: 查看key的的一些说明&lt;/li&gt;&#xA;&lt;li&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;常用设置&#34;&gt;常用设置&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;set nu&lt;/li&gt;&#xA;&lt;li&gt;set cursorline&lt;/li&gt;&#xA;&lt;li&gt;set noswapfile&lt;/li&gt;&#xA;&lt;li&gt;set hlsearch&lt;/li&gt;&#xA;&lt;li&gt;set ignorecase&lt;/li&gt;&#xA;&lt;li&gt;set incsearch&lt;/li&gt;&#xA;&lt;li&gt;set softtabstop=2&lt;/li&gt;&#xA;&lt;li&gt;set shiftwidth=2&lt;/li&gt;&#xA;&lt;li&gt;set expandtab&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;9 set showtabline=2&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java Stream简单了解</title>
      <link>https://stoneepigraph.github.io/posts/language/java/stream/</link>
      <pubDate>Tue, 03 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/language/java/stream/</guid>
      <description>&lt;h2 id=&#34;stream&#34;&gt;Stream&lt;/h2&gt;&#xA;&lt;h3 id=&#34;stream的创建方式&#34;&gt;Stream的创建方式&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;通过Collection系列集合提供&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();&#xA;Stream&amp;lt;String&amp;gt; stream1 = list.stream();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;通过Arrays中的静态方法获取数组流&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String[] emps = new String[10];&#xA;Stream&amp;lt;String&amp;gt; stream2 = Arrays.stream(emps);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;通过Stream类中的静态方法of()&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Stream&amp;lt;String&amp;gt; stream3 = Stream.of(&amp;quot;aa&amp;quot;, &amp;quot;bb&amp;quot;, &amp;quot;cc&amp;quot;);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;创建无限流&#xA;&lt;ol&gt;&#xA;&lt;li&gt;迭代&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Stream&amp;lt;Integer&amp;gt; stream4 = Stream.iterate(0, x -&amp;gt; x + 2);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;生成&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Stream.generate(() -&amp;gt; Math.random())&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;中间操作&#34;&gt;中间操作&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;筛选与切片&#xA;&lt;ol&gt;&#xA;&lt;li&gt;filter&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;stream.filter(Predicate)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;limit&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;stream.filter(long)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;skip&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;stream.skip(long)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;distinct&#xA;通过hashcode(),equals()进行去重&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;stream.distinct()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;映射&#xA;&lt;ol&gt;&#xA;&lt;li&gt;map&#xA;将元素转换成其他形式或提取信息。map中的Function本身也会返回一个流。&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;map(Function)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;flatMap&#xA;会整合Function本身返回的流。&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;flatMap(Function)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;排序&#xA;&lt;ol&gt;&#xA;&lt;li&gt;sorted()&#xA;自然排序&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;stream.sorted()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;sorted(Comparator)&#xA;定制排序，指定Comparator&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;stream.sorted(Comparator)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;终止操作&#34;&gt;终止操作&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;查找与匹配&lt;/li&gt;&#xA;&lt;li&gt;allMatch&#xA;检查是否匹配所有元素&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;!--listend--&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;stream.allMatch()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;anyMatch&#xA;检查是否至少匹配一个元素&lt;/li&gt;&#xA;&lt;li&gt;nonMatch&#xA;检查是否没有匹配所有元素&lt;/li&gt;&#xA;&lt;li&gt;findFisrt()&#xA;返回第一个元素&lt;/li&gt;&#xA;&lt;li&gt;findAny&#xA;返回当前流中的任意元素&lt;/li&gt;&#xA;&lt;li&gt;count&#xA;返回流中的元素的个数&lt;/li&gt;&#xA;&lt;li&gt;max(Comparator)&#xA;返回流中的最大值&lt;/li&gt;&#xA;&lt;li&gt;min(Comparator)&#xA;返回流中的最小值&lt;/li&gt;&#xA;&lt;li&gt;归约&#xA;&lt;ul&gt;&#xA;&lt;li&gt;reduce(T, BinaryOperator)&#xA;将流中的元素反复结合起来，得到一个新值。&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Stream.of(1,2,3,4,5).reduce(0, (x, y) -&amp;gt; x + y)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;收集&#xA;&lt;ul&gt;&#xA;&lt;li&gt;collect(Collector)&#xA;将流转换为其他形式,包括转换，分组，分区等&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Stream.of(&amp;quot;11&amp;quot;, &amp;quot;aa&amp;quot;, &amp;quot;bb&amp;quot;).collect(Collectors.toSet());&#xA;Stream.of(&amp;quot;11&amp;quot;, &amp;quot;aa&amp;quot;, &amp;quot;bb&amp;quot;).collect(Collectors.coutning());&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;并行流与串行流&#34;&gt;并行流与串行流&lt;/h3&gt;&#xA;&lt;p&gt;了解使用Fork/Join框架&#xA;Stream可以使用parallel()与sequential()切换并行流与顺序流。&lt;/p&gt;</description>
    </item>
    <item>
      <title>修管日常FQ</title>
      <link>https://stoneepigraph.github.io/posts/%E4%BF%AE%E7%AE%A1%E6%97%A5%E5%B8%B8fq/</link>
      <pubDate>Sat, 25 May 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/%E4%BF%AE%E7%AE%A1%E6%97%A5%E5%B8%B8fq/</guid>
      <description>&lt;h2 id=&#34;企业平台&#34;&gt;企业平台&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;用户名密码错误企业平台账号为备案编号去掉修备的12位数字, 忘记密码联系企业所属修管科重置密码.&lt;/li&gt;&#xA;&lt;li&gt;下载企业平台群文件有最新的企业平台安装包&lt;/li&gt;&#xA;&lt;li&gt;企业平台提示网络异常或者老版本的(参数不是字符串)&#xA;确认一下电脑的internet Explorer浏览器能不能正常访问: &lt;a href=&#34;https://weixiu.bjysgl.cn/bjvmpsf/f/&#34;&gt;https://weixiu.bjysgl.cn/bjvmpsf/f/&lt;/a&gt;&#xA;正常情况下确认一下internet Explorer浏览器能不能正常上网就可以,如果能正常上网企业平台还是提示网络有问题,那么试一下上边儿的地址.&lt;/li&gt;&#xA;&lt;li&gt;企业平台提示网络异常&#xA;&lt;ol&gt;&#xA;&lt;li&gt;确认一下是不是XP系统,企业平台已经不再支持XP系统了&lt;/li&gt;&#xA;&lt;li&gt;确认一下internet Explorer浏览器能不能正常访问: &lt;a href=&#34;https://weixiu.bjysgl.cn/bjvmpsf/f/&#34;&gt;https://weixiu.bjysgl.cn/bjvmpsf/f/&lt;/a&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;无法访问,核实一下internet选项里的TLS1.2是不是勾选了, 现在企业平台最低要求TLS1.2(所以XP系统无法正常访问了,还有部分电脑默认是没选择TLS1.2的)&lt;/li&gt;&#xA;&lt;li&gt;还无法访问,需要核实一下云服务商是不是对企业的外网IP做了封禁&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;无法上传附件核实一下internet选项里的TLS1.2是不是勾选了&lt;/li&gt;&#xA;&lt;li&gt;打印合格证的时候提示未指定的错误去QQ群文件下载最新的企业平台安装包重新安装&lt;/li&gt;&#xA;&lt;li&gt;企业找不到自己的备案编号让企业自己去这个地址&lt;a href=&#34;https://weixiu.bjysgl.cn/bjvmpsf/f/&#34;&gt;https://weixiu.bjysgl.cn/bjvmpsf/f/&lt;/a&gt;  查询备案编号&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在这个网址查询不到企业的原因？&#xA;&lt;ol&gt;&#xA;&lt;li&gt;确认企业是不是备案成功了&lt;/li&gt;&#xA;&lt;li&gt;在这个页面查询时只输入企业名称，要么一定要跟备案的企业名称一称，要么只输入确认的几个字&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;登录企业平台提示账号已锁定让企业联系所属修管科, 一般是修管科将企业列入经营地异常会导致这种情况.&lt;/li&gt;&#xA;&lt;li&gt;自动采集接口提示账号已锁定让企业去技术支持群下载最新的企业平台重新安装&lt;/li&gt;&#xA;&lt;li&gt;登录企业平台提示未绑定MAC地址让企业从技术支持群的群文件里获取获取MAC地址的工具和操作视频,获取到MAC地址后上报给企业所属的修管科&lt;/li&gt;&#xA;&lt;li&gt;企业说联系过修管科了,修管科也给绑定了MAC地址,可是还是登录不上去.&#xA;让企业发一下获取MAC地址工具结果截图, 登录企业平台露出登录账号和报错信息的截图和企业的备案编号三样东西给咱们,去系统里核对是否是绑定成功了.&lt;/li&gt;&#xA;&lt;li&gt;企业要修管科的联系方式群文件有一个叫&amp;quot;本市道路运输管理部门联系电话&amp;quot;的文档, 咱们只有修管科这一个联系方式.&lt;/li&gt;&#xA;&lt;li&gt;企业平台提示&amp;quot;下载错误,请联系管理员&amp;quot;&#xA;直接从群文件下载最新的企业平台安装包,重新安装.&lt;/li&gt;&#xA;&lt;li&gt;企业平台被杀毒软件误杀技术支持群里有&amp;quot;企业被杀毒软件误杀的解决办法&amp;quot;文档.&lt;/li&gt;&#xA;&lt;li&gt;企业录入维修纪录时无法选择维修接待员/质保员/维修人员人员是是按在职或兼职岗位在企业平台已经录入的人员列表里查询的&#xA;&lt;ol&gt;&#xA;&lt;li&gt;维修接待对应售后服务部下的维修接待员&lt;/li&gt;&#xA;&lt;li&gt;质检员对应售后服务部的质量检验员&lt;/li&gt;&#xA;&lt;li&gt;维修人员对应售后服务部下的机修技师,电气维修技师等&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;企业录入维修纪录时点击保存后一直转圈,未提示&amp;quot;保存成功&amp;quot;&#xA;这种情况有可能是网络问题,有可能是企业录入的日期不符合规范(还未修复),还有可能是维修配件里带有英文的逗号(最新版本已修复,不会再有这个问题).&lt;/li&gt;&#xA;&lt;li&gt;维修纪录提示车牌号错误这种情况有可能是特殊的车牌号或者企业录入错误,让企业提供一下行驶证,我去核对一下.&lt;/li&gt;&#xA;&lt;li&gt;维修纪录里车牌号码不能选择别的省的车牌车牌字头的下拉框是可以直接输入的.直接录入就可以.&lt;/li&gt;&#xA;&lt;li&gt;合格证无法打印让企业确认一下Internet Explorer浏览器能不能正常打印内容. 如果正常再找我们. 如果不正常就是打印机的默认设置有问题了.&lt;/li&gt;&#xA;&lt;li&gt;企业登记信息上报未通过需要重新上报您可在“综合查询-行管通知查询”，查看在最上方的&amp;quot;机动车维修经营登记信息审核结果通知书&amp;quot;，点击附件名称，下载通知书，查看审核未通过原因&lt;/li&gt;&#xA;&lt;li&gt;企业登记审核结果通知书里提示企业缺少对应的配件及人员, 企业说企业本身就没这些人员或者设备&#xA;&lt;ol&gt;&#xA;&lt;li&gt;告诉企业登记信息的核对结果是按企业的开业条件去审核的.&lt;/li&gt;&#xA;&lt;li&gt;提示质量检验员未上报驾驶证的,按企业的经营范围,给质量检验员上报驾驶证就可以了.&lt;/li&gt;&#xA;&lt;li&gt;提示人员学历或职称不达标的,给对应的人员上传对应的学历&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;企业维修设备有些设备数量无法修改无法修改的设备可以多次点&amp;quot;添加&amp;quot;按钮,添加多条&lt;/li&gt;&#xA;&lt;li&gt;企业登记信息上报时提示&amp;quot;环保措施或管理制度数据是否上报不完整&amp;quot;&#xA;确认一下管理制度里带星的是不是都上传了文件.&lt;/li&gt;&#xA;&lt;li&gt;人员录入提示人员在其他企业在职&#xA;&lt;ol&gt;&#xA;&lt;li&gt;让员工联系上家企业办理离职&lt;/li&gt;&#xA;&lt;li&gt;如果联系不到上家企业或者上家企业已经不经营了,那么联系企业所属修管科, 让修管科联系咱们办理离职&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;维修管理制度，环保制度上传格式问题&#xA;PDF, DOC,JPG,PNG&#xA;无法上传时需要修改选择文件类型&lt;/li&gt;&#xA;&lt;li&gt;企业已经录入维修接待员,可还是无法选择维修接待人员&#xA;&lt;ol&gt;&#xA;&lt;li&gt;人员是否已录入&lt;/li&gt;&#xA;&lt;li&gt;确认一下网络是否正常，首页是不是能正常获取数据，如果不能的话，确认一下网络是否正常，在internet选项里添加一下TLS1.2的支持。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;环评是否上传环评现在不要求必传,如果做过了可以上传环评结果,没做过就可以不传了.&lt;/li&gt;&#xA;&lt;li&gt;新车不需要录入环保维修项目跟环保确认过，有微信的聊天纪录。新车不会查询环保维修项目。&lt;/li&gt;&#xA;&lt;li&gt;新车有临牌的录入临牌，没有的录入京Z00000&lt;/li&gt;&#xA;&lt;li&gt;车辆的VIN码为16位怎么处理目前环检不合格的车辆是不验证车牌号和VIN的有效性的,只要关联上就行.&#xA;非环检不合格的车辆补0就可以了.&lt;/li&gt;&#xA;&lt;li&gt;企业维修职位中无洗车工怎么处理目前没有洗车式的职位，可以在售后服务部随意选一个岗位录入。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;行业管理平台-修管科-修管处&#34;&gt;行业管理平台-&amp;gt;修管科/修管处&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;企业录入了维修纪录了,可环检不合格数据还是关联成了备案企业治理未报信息&#xA;&lt;ol&gt;&#xA;&lt;li&gt;确认一下车牌号和VIN码是否一致&lt;/li&gt;&#xA;&lt;li&gt;确认一个维修纪录是否是在接收到环检不合格数据后打印的合格证,并且是在复检数据接收前.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;综合管理平台&#34;&gt;综合管理平台&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;用户名密码错误&#xA;&lt;ol&gt;&#xA;&lt;li&gt;默认用户名为企业备案编号去掉&amp;quot;修备&amp;quot;剩下的12位数字, 默认密码为WeiXiu@备案编号后门位.&lt;/li&gt;&#xA;&lt;li&gt;忘记密码联系企业所属修管科重置密码&lt;/li&gt;&#xA;&lt;li&gt;企业在本月27日到下月10日之间备案的企业是不同步的, 需要10日以后再尝试登录.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;登录提示账号锁定无操作半小时后自动解锁&lt;/li&gt;&#xA;&lt;li&gt;无法上报修管科汇总了当月/季/半年/年报后企业无法再次上报&lt;/li&gt;&#xA;&lt;li&gt;上报错误,需要打回修改修管科的联系修管处打回, 企业的联系所属修管科打回&lt;/li&gt;&#xA;&lt;li&gt;各类企业都上报哪些报表一类:月报,年报二类:季报,年报三类:半年报&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>Rust笔记</title>
      <link>https://stoneepigraph.github.io/posts/rust%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 07 Apr 2024 23:32:39 +0800</pubDate>
      <guid>https://stoneepigraph.github.io/posts/rust%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h2 id=&#34;rust基础&#34;&gt;Rust基础&lt;/h2&gt;&#xA;&lt;h3 id=&#34;数据类型&#34;&gt;数据类型&lt;/h3&gt;&#xA;&lt;h4 id=&#34;说明&#34;&gt;说明&lt;/h4&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Rust不会自动进行隐式类型转换。&lt;/p&gt;&#xA;&lt;p&gt;Rust的整数类型都实现了From&amp;lt;T&amp;gt;和Into&amp;lt;T&amp;gt;trait, 使得我们可以在它们之间进行转换。From&amp;lt;T&amp;gt;trait包含from()方法，Into&amp;lt;T&amp;gt;trait包含into()方法。类型通过实现这些trait来表达它将被如何转换为另一个类型。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;string-和-and-str&#34;&gt;String 和 &amp;amp;str&lt;/h4&gt;&#xA;&lt;p&gt;&amp;amp;str 是一个指向字符串片段的不可变引用&#xA;String是一个可变字符串缓冲区&#xA;&lt;strong&gt;对于String类型来说，应该倾向于使用&amp;amp;str,而不是&amp;amp;String.&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;String&#xA;String可以看作由三个变量所组成的结构体，第一个变量为指向一块堆上连续内存的指针，第二个变量为这块内存里已经使用的总大小。第三个变量为这块内存的总长度capacity。&#xA;String在new的时候从堆里申请内存，在drop的时候释放内存。&#xA;String内部的指向的连续内存可以看作为u8的数组，String的使用接口确保了内部存储的确实为合法的UTF-8编码的字节。&lt;/li&gt;&#xA;&lt;li&gt;&amp;amp;str&#xA;&amp;amp;str是对String的一种借用形式，被称为字符串切片。&#xA;由于&amp;amp;str的特殊性让其与普通的引用区分开，这种携带了元数据的特殊引用也被称为胖指针。&#xA;＆str非常有用，它能够引用String类型的多个不同子字符串而无需复制，避免复制。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;元组&#34;&gt;元组&lt;/h4&gt;&#xA;&lt;h4 id=&#34;数组&#34;&gt;数组&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let 变量名称:[数据类型;数组长度] = [默认值;数组长度]&#xA;let 变量名称:[数据类型;数组长度] = [数据值1,数据值2...]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;做为参数&lt;/p&gt;&#xA;&lt;p&gt;可以进行值传递也可以进行引用传递.值传递方法内的修改不会影响方法外的数据.引用传递会同步修改.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;集合&#34;&gt;集合&lt;/h4&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;分类&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;迭代器&lt;/p&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;分类&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;iter()&#xA;返回一个只读可重入迭代器,迭代器元素的类型为&amp;amp;T&lt;/li&gt;&#xA;&lt;li&gt;into_iter()&#xA;返回一个只读不可重入迭代器,迭代器元素的类型为T&lt;/li&gt;&#xA;&lt;li&gt;inter_mut()&#xA;返回一个可修改可重入迭代器,迭代器元素的类型为&amp;amp;mut T&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;类型别名&#34;&gt;类型别名&lt;/h4&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;说明&lt;/p&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;类型别名仅仅是别名,只是为了让可读性更好,并不是全新的类型&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;类型别名无法实现为外部类型实现外部特征等功能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;newtype&#34;&gt;newtype&lt;/h4&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;为什么要使用newtype&lt;/p&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;自定义类型可以让我们给出更有意义和可主读性的类型名&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对于某些场景,只有newtype可以很好的解决&lt;/p&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;为外部类型实现外部特征&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;危险期内部类型的细节&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;sized和不定长类型dst&#34;&gt;Sized和不定长类型DST&lt;/h4&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;动态大小类型DST&lt;/p&gt;</description>
    </item>
    <item>
      <title>Emacs Lisp</title>
      <link>https://stoneepigraph.github.io/posts/emacslisp/</link>
      <pubDate>Sun, 17 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/emacslisp/</guid>
      <description>&lt;h2 id=&#34;elisp&#34;&gt;ELisp&lt;/h2&gt;&#xA;&lt;h3 id=&#34;快捷键&#34;&gt;快捷键&lt;/h3&gt;&#xA;&lt;h4 id=&#34;格式化区域代码-c-m&#34;&gt;格式化区域代码： C - M - \&lt;/h4&gt;&#xA;&lt;h4 id=&#34;执行代码-c-x-c-e&#34;&gt;执行代码： C - x C - e&lt;/h4&gt;&#xA;&lt;p&gt;相当于 eval-last-sexp&lt;/p&gt;&#xA;&lt;h4 id=&#34;执行代码并将执行结果放到光标处-c-u-c-x-c-e&#34;&gt;执行代码并将执行结果放到光标处： C - u C - x C - e&lt;/h4&gt;&#xA;&lt;h4 id=&#34;查找更多信息&#34;&gt;查找更多信息&lt;/h4&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;查询函数信息： C - h f&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;查询变量信息： C - h v&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;查询快捷键信息： C - h k&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用正则表达式查询函数名： M - x apropos&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;数据类型&#34;&gt;数据类型&lt;/h3&gt;&#xA;&lt;h4 id=&#34;内建&#34;&gt;内建&lt;/h4&gt;&#xA;&lt;p&gt;内建的Emacs数据类型称为primitive types, 包括整数、浮点数、cons、符号（symbol)、字符串、向量(vector)、散列表(hash-table)、subr(内建函数， 比如cons, if, and)、byte-code function, 和其它特殊类型， 例如缓冲区(buffer)&lt;/p&gt;&#xA;&lt;h4 id=&#34;数字&#34;&gt;数字&lt;/h4&gt;&#xA;&lt;p&gt;Emacs的数字分为整数和浮点数。1.属于整数&lt;/p&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;整数&lt;/p&gt;&#xA;&lt;p&gt;一般来说最小范围是在-2**28 ~ 2**28-1.&lt;/p&gt;</description>
    </item>
    <item>
      <title>JVM简述</title>
      <link>https://stoneepigraph.github.io/posts/jvm/</link>
      <pubDate>Sun, 17 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/jvm/</guid>
      <description>&lt;h2 id=&#34;类的加载-连接与初始化&#34;&gt;类的加载,连接与初始化&lt;/h2&gt;&#xA;&lt;h3 id=&#34;加载&#34;&gt;加载&lt;/h3&gt;&#xA;&lt;p&gt;指的是将类的.class文件中的二进制数据读入到内存当中,将其放在运行时数据区的方法区内,然后在内存中创建一个java.lang.Class对象.&lt;/p&gt;&#xA;&lt;h4 id=&#34;类的加载方式&#34;&gt;类的加载方式&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;从本地系统中直接加载&lt;/li&gt;&#xA;&lt;li&gt;从网络下载.class&lt;/li&gt;&#xA;&lt;li&gt;从zip, jar等归档中加载.class文件&lt;/li&gt;&#xA;&lt;li&gt;从专有数据库中提取.class文件&lt;/li&gt;&#xA;&lt;li&gt;将Java源文件动态的编译为.class文件&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;连接&#34;&gt;连接&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;验证确保被加载的类的正确性&lt;/li&gt;&#xA;&lt;li&gt;准备为类的静态变量分配内存,并将其初始化为默认值&lt;/li&gt;&#xA;&lt;li&gt;解析把类中的符号引用转换为直接引用&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;类的使用&#34;&gt;类的使用&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;主动使用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;创建类的实例&lt;/li&gt;&#xA;&lt;li&gt;访问某个类或接口的静态变量或对静态变量赋值&lt;/li&gt;&#xA;&lt;li&gt;访问类的静态方法&lt;/li&gt;&#xA;&lt;li&gt;反射&lt;/li&gt;&#xA;&lt;li&gt;初始化一个类的子类&lt;/li&gt;&#xA;&lt;li&gt;Java虚拟机启动时被标明为启动类的类&lt;/li&gt;&#xA;&lt;li&gt;JDK1.7开始提供的动态语言支持：java.lang.invoke.MethodHandler实例的解析结果REF_getStatic, REF_PUTsTATIC, REF_invokeStatic句柄对应的类没有初始化，则初始化。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;被动使用&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;初始化&#34;&gt;初始化&lt;/h3&gt;&#xA;&lt;p&gt;所有的Java虚拟机实现必须在每个类或接口被Java程序&amp;quot;首次主动使用&amp;quot;时才进行初始化.&lt;/p&gt;&#xA;&lt;h4 id=&#34;注意&#34;&gt;注意&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;当一个常量的值并非编译期间可以确定的,那么其值就不会被放到调用类的常量池中,这时在程序运行时,会导致主动使用这个常量所在的类,显然会导致这个类被初始化.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;主动使用的方式&#34;&gt;主动使用的方式&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;创建类的实例&lt;/li&gt;&#xA;&lt;li&gt;访问某个类或接口的静态变量,或者对该静态变量赋值&lt;/li&gt;&#xA;&lt;li&gt;调用类的静态方法&lt;/li&gt;&#xA;&lt;li&gt;反射如Class.forName(&amp;ldquo;com.path.ClassName&amp;rdquo;)&lt;/li&gt;&#xA;&lt;li&gt;初始化一个类的子类&lt;/li&gt;&#xA;&lt;li&gt;Java虚拟机启动时被标明为启动类的类&lt;/li&gt;&#xA;&lt;li&gt;JDK1.7开始提供的动态语言支持.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;虚拟机参数&#34;&gt;虚拟机参数&lt;/h2&gt;&#xA;&lt;h3 id=&#34;tips&#34;&gt;Tips&lt;/h3&gt;&#xA;&lt;h3 id=&#34;说明&#34;&gt;说明&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;-XX:+&amp;lt;option&amp;gt;, 表示开启option选项&lt;/li&gt;&#xA;&lt;li&gt;-XX:-&amp;lt;option&amp;gt;, 表示关闭option选项&lt;/li&gt;&#xA;&lt;li&gt;-XX:&amp;lt;option&amp;gt;=&amp;lt;value&amp;gt;, 表示将option选项的值设置为value&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;参数&#34;&gt;参数&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&amp;ndash;XX:+TraceClassLoading: 用于追踪类的加载信息并打印出来.&lt;/li&gt;&#xA;&lt;li&gt;-Xss1M: 设置最大调用深度，防止栈举出。StackOverflowError。&lt;/li&gt;&#xA;&lt;li&gt;-XX:MaxTenuringThreshold: 指定新征伐对象经过多少次回收后进入老年代，默认为15次。&lt;/li&gt;&#xA;&lt;li&gt;-XX:PretenureSizeThreshold: 指定对象的大小超过在指定的大小之后，直接晋升老年代。&lt;/li&gt;&#xA;&lt;li&gt;TLAB&#xA;&lt;ol&gt;&#xA;&lt;li&gt;-XX:+UseTLBA: 使用TLAB, 默认开启。&lt;/li&gt;&#xA;&lt;li&gt;-XX:+TLABSize: 设置TLAB大小&lt;/li&gt;&#xA;&lt;li&gt;-XX:TLABRefillWasteFraction：设置维护进入TLAB空间的单个对象大小，他是一个比例值，默认为64,即如果对象大于整个空间的1/64,则在堆创建对象。&lt;/li&gt;&#xA;&lt;li&gt;-XX:+printTLAB：查看TLAB。&lt;/li&gt;&#xA;&lt;li&gt;-XX:ResizeTLAB: 自调整TLABRefillWasteFraction阀值。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;垃圾收集器&#xA;&lt;ol&gt;&#xA;&lt;li&gt;-XX：UseSerialGC： 使用串行垃圾回收器。&lt;/li&gt;&#xA;&lt;li&gt;-XX:+useParNewGC: 新生代使用ParNew回收器。老年代使用串行回收器。&#xA;&lt;ol&gt;&#xA;&lt;li&gt;-XX:parallelGCThreads： 指定Parnew收集器的线程数。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ParallelGC&#xA;&lt;ol&gt;&#xA;&lt;li&gt;-XX:MaxGCPauseMills: 设置最大垃圾收集停顿时间。&lt;/li&gt;&#xA;&lt;li&gt;-XX：GCTimeRatio： 设置吞量大小，它是一个0到100之间的整数，默认为100。&lt;/li&gt;&#xA;&lt;li&gt;-XX:UseAdaptiveSizePolicy: 打开自适应模式。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;CMS&#xA;&lt;ol&gt;&#xA;&lt;li&gt;-XX:+UseConcMarkSweepGC&lt;/li&gt;&#xA;&lt;li&gt;-XX:ConcGCThreads:设置并发线程数量。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;虚拟机调优策略&#34;&gt;虚拟机调优策略&lt;/h3&gt;&#xA;&lt;p&gt;JVM参数调优主要设置堆内存，主要让GC不要去频繁回收垃圾，减少对老年代的回收。配置时让-Xms与-Xmx一致。&lt;/p&gt;</description>
    </item>
    <item>
      <title>FreeMarker入门</title>
      <link>https://stoneepigraph.github.io/posts/freemarker/</link>
      <pubDate>Fri, 25 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/freemarker/</guid>
      <description>&lt;h2 id=&#34;入门&#34;&gt;入门&lt;/h2&gt;&#xA;&lt;h3 id=&#34;模板-plus-数据模型-输出&#34;&gt;模板 + 数据模型 = 输出&lt;/h3&gt;&#xA;&lt;h3 id=&#34;数据模型&#34;&gt;数据模型&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;数据模型的基本结构是树状的.&lt;/li&gt;&#xA;&lt;li&gt;标量用于存储单一的值.这种类型的值可以是字符串,数字,日期/时间或者布尔值&lt;/li&gt;&#xA;&lt;li&gt;哈希表是一种存储变量及其相关且有唯一标识名称的容器&lt;/li&gt;&#xA;&lt;li&gt;序列是存储有序变量的容器.存储的变量可以通过数字索引来检索,索引通常从0开始.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;值域&#34;&gt;值域&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;start..end: 包含结尾的值域&lt;/li&gt;&#xA;&lt;li&gt;start..&amp;lt;end或者start..!end: 不包含结尾的值域&lt;/li&gt;&#xA;&lt;li&gt;start..*length: 限定长度的值域.&lt;/li&gt;&#xA;&lt;li&gt;start..: 无右边界值域.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;注意&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;值域表达式本身没有方括号&lt;/li&gt;&#xA;&lt;li&gt;可以在..的两侧编写自述表达式而不需要圆括号&lt;/li&gt;&#xA;&lt;li&gt;.., ..&amp;lt;, ..!, ..*是去处符,所以它们中间不能有空格.&lt;/li&gt;&#xA;&lt;li&gt;无右边界值域的定义大小是2147483647&lt;/li&gt;&#xA;&lt;li&gt;值域并不存储它们包含的数字.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;哈希表&#34;&gt;哈希表&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;像连接字符串那样,也可以使用加号的方式来连接哈希表.如果两个哈希表含有键相同的项,那么在加号右侧的哈希表中的项优先.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;模板&#34;&gt;模板&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;插值: ${paramsName}&lt;/li&gt;&#xA;&lt;li&gt;FTL标签&#xA;FTL标签与HTML标签有一些相似之处,这些标签的名称以#开头, 用户自定义的FTL标签则需要使用@来代替#.&lt;/li&gt;&#xA;&lt;li&gt;注释注释使用&amp;lt;#&amp;ndash; and &amp;ndash;&amp;gt; 来标识&lt;/li&gt;&#xA;&lt;li&gt;其它任何不是FTL标签,插值或注释的内容被视为静态文本,这些东西不会被FreeMarker所解析, 会被按照原样输出来.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;基本指令&#34;&gt;基本指令&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IF指令&#xA;&lt;pre&gt;&lt;code class=&#34;language-FreeMarker&#34;&gt;&amp;lt;#if condition&amp;gt; &amp;lt;/#if&amp;gt;&#xA;&amp;lt;#if condition&amp;gt;&#xA;  if statement&#xA;&amp;lt;#elseif condition&amp;gt;&#xA;  elseif statement&#xA;&amp;lt;#else&amp;gt;&#xA;  else statement&#xA;&amp;lt;/#if&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;list指令展示列表内容&#xA;&lt;ol&gt;&#xA;&lt;li&gt;基本&#xA;&lt;pre&gt;&lt;code class=&#34;language-FreeMarker&#34;&gt;&amp;lt;ul&amp;gt;&#xA;&amp;lt;#list listObj as obj&amp;gt;&#xA;&amp;lt;li&amp;gt;${ojb}&#xA;&amp;lt;/#list&amp;gt;&#xA;&amp;lt;/ul&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;如果列表为空的话,整个列表都不展示&#xA;&lt;pre&gt;&lt;code class=&#34;language-freeMarker&#34;&gt;&amp;lt;#list listObj&amp;gt;&#xA;  &amp;lt;ul&amp;gt;&#xA;    &amp;lt;#items as obj&amp;gt;&#xA;      &amp;lt;li&amp;gt;${obj}&#xA;  &amp;lt;/ul&amp;gt;&#xA;&amp;lt;/#list&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;如果列表为空的话展示一些其它信息&#xA;&lt;pre&gt;&lt;code class=&#34;language-freeMarker&#34;&gt;&amp;lt;#list listObj&amp;gt;&#xA;  &amp;lt;p&amp;gt; ListDesc:&#xA;  &amp;lt;ul&amp;gt;&#xA;    &amp;lt;#items as obj&amp;gt;&#xA;      &amp;lt;li&amp;gt;${obj}&amp;lt;#sep&amp;gt;septarator&amp;lt;/#sep&amp;gt;&#xA;    &amp;lt;/#items&amp;gt;&#xA;  &amp;lt;/ul&amp;gt;&#xA;&amp;lt;#else&amp;gt;&#xA;  &amp;lt;p&amp;gt; list is empty.&#xA;&amp;lt;/#list&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;include指令使用include指令, 我们可以在模板中插入其他文件的内容. 比如: 版权信息.&#xA;&lt;pre&gt;&lt;code class=&#34;language-freemarker&#34;&gt;&amp;lt;#include &amp;quot;filePath&amp;quot;&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;联合使用指令&#34;&gt;联合使用指令&lt;/h4&gt;&#xA;&lt;p&gt;在页面中,指令间可以很容易地相互嵌套.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Gitignore</title>
      <link>https://stoneepigraph.github.io/posts/git/gitignore/</link>
      <pubDate>Fri, 25 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/git/gitignore/</guid>
      <description>&lt;h2 id=&#34;规则&#34;&gt;规则&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;em&gt;mtk&lt;/em&gt; 过滤整个文件夹&lt;/li&gt;&#xA;&lt;li&gt;*.zip 过滤所有.zip文件&lt;/li&gt;&#xA;&lt;li&gt;/mtk/do.c 过滤某个具体文件&lt;/li&gt;&#xA;&lt;li&gt;!*.zip 反忽略&lt;/li&gt;&#xA;&lt;li&gt;!/mtk/one.txt反忽略&lt;/li&gt;&#xA;&lt;li&gt;*.a       # 忽略所有 .a 结尾的文件&lt;/li&gt;&#xA;&lt;li&gt;!lib.a    # 但 lib.a 除外&lt;/li&gt;&#xA;&lt;li&gt;/TODO     # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO&lt;/li&gt;&#xA;&lt;li&gt;build/    # 忽略 build/ 目录下的所有文件&lt;/li&gt;&#xA;&lt;li&gt;doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Git常用命令</title>
      <link>https://stoneepigraph.github.io/posts/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Fri, 25 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>&lt;h2 id=&#34;git常用命令&#34;&gt;Git常用命令&lt;/h2&gt;&#xA;&lt;h3 id=&#34;新建代码库&#34;&gt;新建代码库&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在当前目录新建一个Git代码库&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&amp;gt; git init&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;新建一个目录，将其初始化为Git代码库&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&amp;gt; git init [Project_name]&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;下载一个项目和它的整个代码历史&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&amp;gt; git clone [url]&lt;/p&gt;&#xA;&lt;h3 id=&#34;配置&#34;&gt;配置&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;添加指定文件到暂存区&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&amp;gt; git add [fileName] &amp;hellip;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;添加当前目录的所有的文档到暂存区&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&amp;gt; git add .&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;删除工作区文件，并且将这次删除放入暂存区&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&amp;gt; git rm [fileName] &amp;hellip;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;停止追踪指定文件，但该文件会保留在工作区&#xA;&amp;gt; git rm &amp;ndash;cached [filename]&lt;/li&gt;&#xA;&lt;li&gt;改名文件，并且将这个改名放入暂存区&#xA;&amp;gt; git mv [file-original] [file-renamed]&lt;/li&gt;&#xA;&lt;li&gt;全局配置忽略Linux与Windows回车的类型&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global core.autocrlf true&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;代码提交&#34;&gt;代码提交&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;提交暂存区到仓库区&#xA;&amp;gt; git commit -m [Message]&lt;/li&gt;&#xA;&lt;li&gt;提交暂存区的指定文件到仓库区&#xA;&amp;gt; git commit [file1] [file2] &amp;hellip; -m [message]&lt;/li&gt;&#xA;&lt;li&gt;提交工作区自上次commit之后的变化，直接到仓库区&#xA;&amp;gt; git commit -a&lt;/li&gt;&#xA;&lt;li&gt;提交时显示所有diff信息&#xA;&amp;gt; git commit -v&lt;/li&gt;&#xA;&lt;li&gt;使用一次新的commit, 替代上一次提交，如果代码没有变化，则用来改写上一次commit的提交信息&#xA;&amp;gt; git commit &amp;ndash;amend -m [message]&lt;/li&gt;&#xA;&lt;li&gt;重做上一次commit, 并包括指定文件的新变化&#xA;&amp;gt; git commit &amp;ndash;amend &amp;hellip;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;分支&#34;&gt;分支&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;列出所有本地分支&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&amp;gt; git branch&lt;/p&gt;</description>
    </item>
    <item>
      <title>maven基础</title>
      <link>https://stoneepigraph.github.io/posts/maven/</link>
      <pubDate>Fri, 25 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/maven/</guid>
      <description>&lt;h2 id=&#34;maven库&#34;&gt;Maven库：&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://repo2.maven.org/maven2/&#34;&gt;http://repo2.maven.org/maven2/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;maven依赖查询&#34;&gt;Maven依赖查询：&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://mvnrepository.com/&#34;&gt;http://mvnrepository.com/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;maven常用命令&#34;&gt;Maven常用命令：&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;创建Maven的普通java项目：&#xA;mvn archetype:create&#xA;-DgroupId=packageName&#xA;-DartifactId=projectName&lt;/li&gt;&#xA;&lt;li&gt;创建Maven的Web项目：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;​    mvn archetype:create&#xA;​    -DgroupId=packageName&#xA;​    -DartifactId=webappName&#xA;​    -DarchetypeArtifactId=maven-archetype-webapp&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;编译源代码： mvn compile&lt;/li&gt;&#xA;&lt;li&gt;编译测试代码：mvn test-compile&lt;/li&gt;&#xA;&lt;li&gt;运行测试：mvn test&lt;/li&gt;&#xA;&lt;li&gt;产生site：mvn site&lt;/li&gt;&#xA;&lt;li&gt;打包：mvn package&lt;/li&gt;&#xA;&lt;li&gt;在本地Repository中安装jar：mvn install&lt;/li&gt;&#xA;&lt;li&gt;清除产生的项目：mvn clean&lt;/li&gt;&#xA;&lt;li&gt;生成eclipse项目：mvn eclipse:eclipse&lt;/li&gt;&#xA;&lt;li&gt;生成idea项目：mvn idea:idea&lt;/li&gt;&#xA;&lt;li&gt;组合使用goal命令，如只打包不测试：mvn -Dtest package&lt;/li&gt;&#xA;&lt;li&gt;编译测试的内容：mvn test-compile&lt;/li&gt;&#xA;&lt;li&gt;只打jar包: mvn jar:jar&lt;/li&gt;&#xA;&lt;li&gt;只测试而不编译，也不测试编译：mvn test -skipping compile -skipping test-compile&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;​      ( -skipping 的灵活运用，当然也可以用于其他组合命令)&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;清除eclipse的一些系统设置:mvn eclipse:clean&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;ps：一 般使用情况是这样，首先通过cvs或svn下载代码到本机，然后执行mvn eclipse:eclipse生成ecllipse项目文件，然后导入到eclipse就行了；修改代码后执行mvn compile或mvn test检验，也可以下载eclipse的maven插件。&#xA;mvn -version/-v  显示版本信息&#xA;mvn archetype:generate        创建mvn项目&#xA;mvn archetype:create -DgroupId=com.oreilly -DartifactId=my-app   创建mvn项目&#xA;mvn package            生成target目录，编译、测试代码，生成测试报告，生成jar/war文件&#xA;mvn jetty:run            运行项目于jetty上,&#xA;mvn compile                    编译&#xA;mvn test                    编译并测试&#xA;mvn clean                    清空生成的文件&#xA;mvn site                    生成项目相关信息的网站&#xA;mvn -Dwtpversion=1.0 eclipse:eclipse        生成Wtp插件的Web项目&#xA;mvn -Dwtpversion=1.0 eclipse:clean        清除Eclipse项目的配置信息(Web项目)&#xA;mvn eclipse:eclipse                将项目转化为Eclipse项目在应用程序用使用多个存储库&lt;/p&gt;</description>
    </item>
    <item>
      <title>SVN常用命令</title>
      <link>https://stoneepigraph.github.io/posts/svn/</link>
      <pubDate>Fri, 25 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/svn/</guid>
      <description>&lt;h2 id=&#34;常用svn命令&#34;&gt;常用SVN命令&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;svn checkout 签出,创建新的工作拷贝.&lt;/li&gt;&#xA;&lt;li&gt;svn info 搞清楚工作拷贝从哪里来的.&lt;/li&gt;&#xA;&lt;li&gt;svn update 从项目仓库中更新目录中的所有文件&lt;/li&gt;&#xA;&lt;li&gt;svn add 添加文件的目录到项目仓库中&lt;/li&gt;&#xA;&lt;li&gt;svn propset 设置文件的属性&lt;/li&gt;&#xA;&lt;li&gt;svn add 添加文件&lt;/li&gt;&#xA;&lt;li&gt;svn delete 删除文件&lt;/li&gt;&#xA;&lt;li&gt;svn move src.file dist.file 移动文件&lt;/li&gt;&#xA;&lt;li&gt;svn commit -m &amp;lsquo;提交信息&amp;rsquo;&lt;/li&gt;&#xA;&lt;li&gt;svn log filename 查看指定文件的历史&lt;/li&gt;&#xA;&lt;li&gt;svn diff 展示文件版本之间的差异.&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在版本之间找差异&#xA;svn diff -r19:21 filename&#xA;使用-r选项来指定一个版本范围&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;svn revert 删掉本地改动并使用项目仓库中的文件版本&lt;/li&gt;&#xA;&lt;li&gt;svn resolved 修正冲突后执行&lt;/li&gt;&#xA;&lt;li&gt;svn blame 显示每个文件的每一行最后的版本, 以及做出这个改动的人&lt;/li&gt;&#xA;&lt;li&gt;svn update 获取最新的代码&lt;/li&gt;&#xA;&lt;li&gt;svn merge -r 27:26 filename 移除file中版本27的改动&lt;/li&gt;&#xA;&lt;li&gt;svn lock filename 给文件加锁&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>UML</title>
      <link>https://stoneepigraph.github.io/posts/uml/</link>
      <pubDate>Fri, 25 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/uml/</guid>
      <description>&lt;h2 id=&#34;基础知识&#34;&gt;基础知识&lt;/h2&gt;&#xA;&lt;h3 id=&#34;uml图&#34;&gt;UML图&lt;/h3&gt;&#xA;&lt;h4 id=&#34;类图&#34;&gt;类图&lt;/h4&gt;&#xA;&lt;p&gt;表述系统中各个对象的类型以及其间存在的各种静态关系.类图也示明类中的特性和操作以及用于对象连接方式的约束.&lt;/p&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;聚合与组合&lt;/p&gt;&#xA;&lt;p&gt;聚合是整体-部分关系.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;可见性&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;+: 公用&lt;/li&gt;&#xA;&lt;li&gt;-: 私用&lt;/li&gt;&#xA;&lt;li&gt;~: 包&lt;/li&gt;&#xA;&lt;li&gt;#: 受护&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;顺序图&#34;&gt;顺序图&lt;/h4&gt;&#xA;&lt;p&gt;顺序图能明晰地指出参加者交互方面的区别.不擅长于示明诸如循环与条件行为等算法细节,但却能使参加者之间的调用一目了然.&#xA;当你考查单个用例内部若干对象的行为时,&lt;/p&gt;&#xA;&lt;h4 id=&#34;用例图&#34;&gt;用例图&lt;/h4&gt;&#xA;&lt;p&gt;用例通过表述系统的用户和系统本向之间特有的交互而工作,提供了如何使用系统的一种陈述.&lt;/p&gt;&#xA;&lt;h4 id=&#34;对象图&#34;&gt;对象图&lt;/h4&gt;&#xA;&lt;p&gt;是在一个时间点上系统中各个对象的一个快照.&#xA;由于对象图示明的是实例而不是类,&lt;/p&gt;&#xA;&lt;h4 id=&#34;包图&#34;&gt;包图&lt;/h4&gt;&#xA;&lt;p&gt;在UML中用双冒号表示包名.&#xA;对大型系统要了解系统主要成分之间的依赖时,使用包图.&#xA;包图表示一种编译时刻的聚组机制.关于示明在运行时刻如何来组合各个对象.&lt;/p&gt;&#xA;&lt;h4 id=&#34;部署图&#34;&gt;部署图&lt;/h4&gt;&#xA;&lt;p&gt;通过揭示&amp;quot;哪些软件片段运行于哪些硬件片段上&amp;quot;来示明系统的一个物理布局.&#xA;任何复杂的部署都可以很好地使用部署图.&lt;/p&gt;&#xA;&lt;h4 id=&#34;活动图&#34;&gt;活动图&lt;/h4&gt;&#xA;&lt;p&gt;活动图可以示明组织机构的工作流,示明软件与人的活动如何交互.活动图还可以示明用例的环境发及复杂用例如何工作的细节.&#xA;考查跨用例或跨线程的行为,就考虑活动图.&#xA;活动图是一种表述过程基理,业务过程以及工作流的技术.&lt;/p&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;分划&lt;/p&gt;&#xA;&lt;p&gt;分划示明一个类或一个机构单位施行哪些动作.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;信号&lt;/p&gt;&#xA;&lt;p&gt;活动图有明确定义的起点,它对应于程序或例和的启用.动作亦可对应于信号.&#xA;信号指明活动接收来自外部过程的一个事件.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;权标&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;流与边&lt;/p&gt;&#xA;&lt;p&gt;是UML2中用来表述两个动作之间连接的同义词.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;饰针与转换&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;展开区域&lt;/p&gt;&#xA;&lt;p&gt;展开区域是活动图上标出的一个区域,其中的动作对一个组中每一项均要发生一次.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;流终&lt;/p&gt;&#xA;&lt;p&gt;流终(flow final)指明在整个活动并未终止时,一个特定流的终结.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;汇合指明&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;何时使用活动图&lt;/p&gt;&#xA;&lt;p&gt;活动图最大的优点是,它们支持并鼓励并行行为.这使它们成为工作流建模和过程建模的一项重要工具.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;通信图&#34;&gt;通信图&lt;/h4&gt;&#xA;&lt;p&gt;通信图是一种着重阐明交互中各个参加者之间的数据连接的交互图.&#xA;在UML1.x中,这些图称为协作图.&lt;/p&gt;&#xA;&lt;h4 id=&#34;构件图&#34;&gt;构件图&lt;/h4&gt;&#xA;&lt;h4 id=&#34;状态图&#34;&gt;状态图&lt;/h4&gt;&#xA;&lt;p&gt;如果一个概念具有有趣的生命周期,具有各种状态发及改变状态的事件,状态图则可能有用.&#xA;考虑用例的单个对象的行为,就用状态图.&lt;/p&gt;&#xA;&lt;h4 id=&#34;交互概观图&#34;&gt;交互概观图&lt;/h4&gt;&#xA;&lt;p&gt;是将活动图与顺序图嫁接在一起的图.&lt;/p&gt;</description>
    </item>
    <item>
      <title>代码之外的生存指南</title>
      <link>https://stoneepigraph.github.io/posts/%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%E7%9A%84%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97/</link>
      <pubDate>Fri, 25 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%E7%9A%84%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97/</guid>
      <description>&lt;h3 id=&#34;为何这本书与你先前读过的任何书籍都迥然不同&#34;&gt;为何这本书与你先前读过的任何书籍都迥然不同&lt;/h3&gt;&#xA;&lt;p&gt;讲述如何成为一名优秀的软件开发人员的书，优秀开发人员指的是那些能够把控自己的职业生涯，达成目标，享受生活的人。本书并不再讨论你能做什么，而是讨论你自己。关乎你的职业生涯，你的生活，你的身体，你的思想及你的灵魂。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;职业生涯：学习如何主动管理自己的职业生涯，从而达到自己追寻的结果。&lt;/li&gt;&#xA;&lt;li&gt;自我营销：学习如何推销自己。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如何打造个人品牌，如何打造一个成功的博客，如何通过演讲，教学，著书立说的方式让你扬名立万。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;学习：学习如何学习，学习如何自觉&lt;/li&gt;&#xA;&lt;li&gt;生产力：关于如何让工作更加富有成效的&lt;/li&gt;&#xA;&lt;li&gt;理财：学习如何有效地管理你赚到的财。&lt;/li&gt;&#xA;&lt;li&gt;健身：&lt;/li&gt;&#xA;&lt;li&gt;精神：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;职业&#34;&gt;职业&lt;/h2&gt;&#xA;&lt;p&gt;你所能犯的最大错误就是相信自己是在为别人工作。这样一来你对工作的安全感已然尽失。职业发展的驱动力一定是来自个体本身。记住：工作是属于公司的，而职业生涯却是属于你自己的。体验决策过程：你要决定自己想要从软件开发这个职业中获得什么，以及如何去获得。&lt;/p&gt;&#xA;&lt;h3 id=&#34;从非同凡响开始-绝不要做其他人都在做的事&#34;&gt;从非同凡响开始：绝不要做其他人都在做的事&lt;/h3&gt;&#xA;&lt;h4 id=&#34;拥有商业心态&#34;&gt;拥有商业心态&lt;/h4&gt;&#xA;&lt;p&gt;因为只有你开始把自己当作一个企业去思考时，你才能开始做出良好的商业决策。尽管在你的职业生涯的某个特定时间段里，你可能确实是在为某家公司打工，但是千万不要让那个特定的角色固化了你和你的整个职业生涯。我们需要把雇主当作是自己的软件开发企业的一个客户。&lt;/p&gt;&#xA;&lt;h4 id=&#34;如何像企业一样思考&#34;&gt;如何像企业一样思考&lt;/h4&gt;&#xA;&lt;p&gt;理解企业的构成：首先，要有一个产品或服务，我的产品是什么？通常软件开发人员售卖的就是他们把一个想法变成一个数字化的现实产品的能力。作为一名软件开发人员，你提供的服务具备有形价值，你要传达的不仅是这款软件的价值是什么，还有它与别的成千上万款软件开发人员提供的服务有什么不同。同时，你需要认识到仅有服务或产品是不够的。想要赚钱，你就必须能让潜在的客户了解该产品或服务。所以我需要做到：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;专注于你正在提供怎样的服务，以及如何营销这项服务。&lt;/li&gt;&#xA;&lt;li&gt;想方设法提升你的服务&lt;/li&gt;&#xA;&lt;li&gt;思考你可以专注为哪一特定类型的客户或行业提供特定的服务&lt;/li&gt;&#xA;&lt;li&gt;集中精力成为一位专家，专门为某一特定类型的客户提供专业的整体服务（记住，作为一个软件开发人员，你只有真正专注于一类客户，才能找到非常好的工作）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;另外，还要想想如何更好地宣传你的服务，如何更好地找到你的客户。&lt;/p&gt;&#xA;&lt;h3 id=&#34;思考未来-你的目标是什么&#34;&gt;思考未来：你的目标是什么&lt;/h3&gt;&#xA;&lt;p&gt;定义你的业务目标要实现任何目标，都必须先知道目标是什么。&lt;/p&gt;&#xA;&lt;h4 id=&#34;如何设定目标&#34;&gt;如何设定目标&lt;/h4&gt;&#xA;&lt;p&gt;起步阶段最简单的就是在心中树立一个大目标，然后再建立能帮你达成这个大目标的小目标。因为很难清晰地界定远期可能发生的事情，所以大目标通常不是非常明确。不过大目标不一定要非常具体。只要目标能具体到给你提供清晰的方向即可。花点儿时间思考一下你的大目标，你希望从职业生涯中收获什么？你希望自己5年或10年之后在哪里？——这非常重要。一旦你想通了自己长远的大目标是什么，下一步注是设定路线，制订通往大目标的小目标。有时还可以运用一下逆向思维，反推一下如何从大目标到当前的情况。如果你可以驱动小目标逐渐前行并靠近你的大目标，那么你最终一定会达到目的地。&lt;/p&gt;&#xA;&lt;h4 id=&#34;追踪你的目标&#34;&gt;追踪你的目标&lt;/h4&gt;&#xA;&lt;p&gt;你应该定期追踪并更新自己设定的目标，必要时还要调整。建议你定期核对自己的目标，这有助于在必要时进行调整，让你对自己负责。反思自己在短期和长期取得的成果是大有裨益的，你能够弄清自己是否取得了合理的进展，或者是否需要进行某些调整。&lt;/p&gt;&#xA;&lt;h3 id=&#34;人际交往能力-远比你想象的重要&#34;&gt;人际交往能力：远比你想象的重要&lt;/h3&gt;&#xA;&lt;h4 id=&#34;别管我-我只想一个人安静地写代码&#34;&gt;别管我，我只想一个人安静地写代码&lt;/h4&gt;&#xA;&lt;p&gt;我曾经对软件开发人员的工作的印象就是写代码。事实上，在软件开发领域，我们大多数时候是与人而非与计算机打交道。甚至我们所写的代码首先是供人使用的，其次才是让计算机可以理解。&lt;/p&gt;&#xA;&lt;h4 id=&#34;学会如何与人打交道&#34;&gt;学会如何与人打交道&lt;/h4&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;每个人都希望感觉自己很重要&lt;/p&gt;&#xA;&lt;p&gt;当你和别人打交道的时候，你应该知道 的最重要的一个概念就是：以自己为核心，每个人都希望自己很重要。这是人类最深邃，最致命的欲望之一，也是社会和生活中取得伟大成就的主要动机。我们常常容易犯的一个错误就是，轻率地否决同事的想法，以便于可以提出自己的想法。然而承着你作出这样的错误判断，你往往会发现他们对你的想法充耳不闻，仅仅因为你让他们感觉自己是无足轻重的。如果你希望人们接受你的想法，并认可其中的价值，首先你最好先主动给他人相同的礼遇。如果你不能保全他人的自尊，那你永远也不可能赢得他的心。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;永远不要批评&lt;/p&gt;&#xA;&lt;p&gt;研究表明，奖励积极行为要比惩罚消极行为有效得多。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;换位思考&lt;/p&gt;&#xA;&lt;p&gt;在人际交往方面获得成功的关键在于：停止用“我”和“我想要什么“来思考。你应当开始思考对他人而言什么才最重要，什么才是他们需要的。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;避免争吵&lt;/p&gt;&#xA;&lt;p&gt;作为软件开发人员，我们有时候倾向于认为所有人是从逻辑角度来思考问题的，这很容易让你落入陷阱，错误地认为严谨的推理足以使他人接受你的思维方式。事情的真相是：尽管我们为自己的智慧感到骄傲，但人们依然是情感动物。我们就像那些穿着西装，打着领带，四处游荡的小孩，假装自己已经长大，其实任何轻微的伤害都能让我们号啕大哭，或者大发雷霆，我们只是已经学会了如何控制和隐藏这些情绪。如果你因为”该怎么做某事“与他人产生分歧，那么在很多情况下，你最好先确定分歧点是否值得你去拼命维护，特别是在你知道它已让他人卷入时。如果你从来没花时间来提高自己的人际交往能力，那现在正当其时。你会发现，当你学会了如何以令人愉悦的方式与他人互动和交往的时候，自己的生活也越来越愉快。通过买得这些技能，你积累了让自己获益终生的财富，它的价值无法用金钱衡量。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;破解面试之道&#34;&gt;破解面试之道&lt;/h3&gt;&#xA;&lt;h4 id=&#34;通过面试的最快捷的方式&#34;&gt;通过面试的最快捷的方式&lt;/h4&gt;&#xA;&lt;p&gt;通过面试最快捷的方式是让面试官对你怀有好感。达成该目标有很多方法，其中大多数可以在面试之前完成。&lt;/p&gt;&#xA;&lt;h4 id=&#34;我是如何得到最后一份工作的&#34;&gt;我是如何得到最后一份工作的&lt;/h4&gt;&#xA;&lt;p&gt;我事先确定了我要入职的公司，我花了一些时间研究这家公司，找出这个公司有哪些开发人员在写博客。我开始关注为这家公司工作的开发人员的所有博客。并开始在他们的博客文章下留下经过沉思熟虑的评论。慢慢地，许多在这家公司供职的开发人员开始认识了我，并通过我给他们博客做出的评论知道了我是谁，他们中的一些人甚至开始读我的博客。接下来，当这家公司开始招聘开发人员的时候，我递交了申请。&lt;/p&gt;&#xA;&lt;h4 id=&#34;突破陈规-建立融洽关系&#34;&gt;突破陈规，建立融洽关系&lt;/h4&gt;&#xA;&lt;p&gt;“破解”面试的要诀就是在面试开始之前就思考应对面试的策略。大量工作岗位来自“个人推荐”。你要试图确保你申请的职位也适用于个人推荐。所以你必须要突破常规，想尽办法与公司内部人员建立联系。随着社交媒体和互联网的广泛应用，你能非常容易地找到任何公司的各种信息，也容易与他们的员工建立联系。&lt;/p&gt;&#xA;&lt;h4 id=&#34;真正的面试会是什么样子的&#34;&gt;真正的面试会是什么样子的&lt;/h4&gt;&#xA;&lt;p&gt;如果顺利的话，在你走进面试间的时候，面试官已经知道你是谁了，但无论如何 ，你都需要了解在面试时自己该做什么。现在，很明显，你需要从技术能力上证明你可以通过技术面试。接下来要关注的事情就是自信地展示自己的能力。——知道要获得这份工作需要做什么，做就是了。对于公司来说招聘员工就是一项投资。与其雇用技术高超但需要生拉硬拽才能干活的人相比，宁愿雇用这样的开发人员：知道的东西可以少一点，但是明确知道要做什么，以及怎样去做。从某种程度上，在你可控的内，面试的时候你要集中精力证明自己就是无需督促也能自动自发做好事情的员工。你还必须要证明：在技术上你确实胜任工作。同时，如果你能说服面试官相信你非常能干，不会被困难阻挡，那么他们不仅会喜欢你，而且更有可能会录用你。&lt;/p&gt;&#xA;&lt;h4 id=&#34;当下你能做什么&#34;&gt;当下你能做什么&lt;/h4&gt;&#xA;&lt;p&gt;不管你现在是正在积极寻找工作，还是给自己保留选择的余地，再没有比现在更好的时机去开始准备你的下一场求职面试了。你应该做的第一件事情是确保自己仍旧保持技术能力。所以确保自己一直阅读技术书籍和博客文章，并会花些时间提升自己的技能。你也可以未雨筹谋，拓展自己的社交网络。开始与本领域不同公司的员工接触，建立联系，他们日后会帮到你。通过阅读并评论他们的博客，认识本领域的其他开发人员甚至是招聘人员。想方设法扩大你的社交圈子。别忘了实践，即使你现在对换新工作毫无兴趣，为了获得面试经验，你也要去面试。集中精力推销自己会对你大有裨益。行动：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;即使你现在不需要努力找工作，也要整理一份清单，列出你想去工作的公司，以及你认识 的公司的人&lt;/li&gt;&#xA;&lt;li&gt;在这份清单上的，如果有的公司你一个人都不认识，那么制订计划至少去认识这些公司中的一位员工，并与之建立联系。&lt;/li&gt;&#xA;&lt;li&gt;在自己所在的领域找出至少一个本地用户组，参数聚会，并把自己介绍给尽可能多的人。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;就业选择-列出你的选择&#34;&gt;就业选择：列出你的选择&lt;/h3&gt;&#xA;&lt;p&gt;落入俗套很容易，循规蹈矩也很容易，只要跟其他人做一样的事情就是了。你自己甚至可能都不知道除了雇用型劳动关系之外还有其他选项。&lt;/p&gt;&#xA;&lt;h4 id=&#34;选择一-雇员&#34;&gt;选择一：雇员&lt;/h4&gt;&#xA;&lt;p&gt;对广大软件开发人员而言，这是一项常见的，默认的就业选择。一部分原因是因为不知道还有其他选项，一部分在于这是最容易的选择。身为雇员的最大的好处就是稳定。作为一名雇员也是一条比其他选择更轻松的道路，因为你的职责是有限的，路线明晰。寻找和申请工作都有一个明确定义的流程。你也无需要操心“做什么才能赚钱”这种问题。作为一名雇员，你通常还有带薪年假。作为一名雇员的消极方面，很大部分与自由相关。此外，作为一名雇员也意味着你的收入是事先确定好的，这就意味着收入有一个“封顶”的界限。&lt;/p&gt;&#xA;&lt;h4 id=&#34;选择二-独立咨询师&#34;&gt;选择二：独立咨询师&lt;/h4&gt;&#xA;&lt;p&gt;作为独立咨询师，软件开发人员不再为特定的单个雇主工作，而是服务于一个或多个客户。如果你曾兼职为某个客户写程序，他们以时薪或固定价格付你报酬，那你就明白什么是咨询了。做独立咨询师最大的好处可能就是赚钱的潜力。作为独立咨询师，你其实就是名副其实的经营者（不仅仅指心态），你要负责税务，法律咨询，销售，健康保险以及各种与企业经营有关的事情。&lt;/p&gt;&#xA;&lt;h4 id=&#34;创业者&#34;&gt;创业者&lt;/h4&gt;&#xA;&lt;p&gt;创业之路可能是你职业生涯中最验证，最不确定但却最具回报潜力的选择。“创业者”意味着软件开发者使用自己的软件技能开发自己的产品，拓展自己的业务。“创业者”的优势： 完全的自由和完全不封顶的赚钱潜力。但需要学习诸多方面的技能：销售，市场营销，以及商业和理财待。&lt;/p&gt;</description>
    </item>
    <item>
      <title>学习</title>
      <link>https://stoneepigraph.github.io/posts/study/</link>
      <pubDate>Fri, 25 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/study/</guid>
      <description>&lt;h2 id=&#34;提问&#34;&gt;提问&lt;/h2&gt;&#xA;&lt;h3 id=&#34;提问的智慧&#34;&gt;提问的智慧&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;提问的智慧&lt;a href=&#34;http://www.catb.org/~esr/faqs/smart-questions.html&#34;&gt;http://www.catb.org/~esr/faqs/smart-questions.html&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;提问的智慧&lt;a href=&#34;https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md&#34;&gt;https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;学习新技术的逻辑&#34;&gt;学习新技术的逻辑&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;这个技术出现的背景、初衷和要达到什么样的目标或是要解决什么样的问题。这个问题非常关键，也就是说，你在学习一个技术的时候，需要知道这个技术的成因和目标，也就是这个技术的灵魂。如果不知道这些的话，那么你会看不懂这个技术的一些设计理念。&lt;/li&gt;&#xA;&lt;li&gt;这个技术的优势和劣势分别是什么，或者说，这个技术的 trade-off 是什么。任何技术都有其好坏，在解决一个问题的时候，也会带来新的问题。另外，一般来说，任何设计都有 trade-off（要什么和不要什么），所以，你要清楚这个技术的优势和劣势，以及带来的挑战。&lt;/li&gt;&#xA;&lt;li&gt;这个技术适用的场景。任何技术都有其适用的场景，离开了这个场景，这个技术可能会有很多槽点，所以学习技术不但要知道这个技术是什么，还要知道其适用的场景。没有任何一个技术是普适的。注意，所谓场景一般分别两个，一个是业务场景，一个是技术场景。&lt;/li&gt;&#xA;&lt;li&gt;技术的组成部分和关键点。这是技术的核心思想和核心组件了，也是这个技术的灵魂所在了。学习技术的核心部分是快速掌握的关键。&lt;/li&gt;&#xA;&lt;li&gt;技术的底层原理和关键实现。任何一个技术都有其底层的关键基础技术，这些关键技术很有可能也是其它技术的关键基础技术。所以，学习这些关键的基础底层技术，可以让你未来很快地掌握其它技术。可以参看我在 CoolShell 上写的 Docker 底层技术那一系列文章。&lt;/li&gt;&#xA;&lt;li&gt;已有的实现和它之间的对比。一般来说，任何一个技术都会有不同的实现，不同的实现都会有不同的侧重。学习不同的实现，可以让你得到不同的想法和思路，对于开阔思维，深入细节是非常重要的。&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>精通Git(2)</title>
      <link>https://stoneepigraph.github.io/posts/git/readnote/%E7%B2%BE%E9%80%9Agit_22/</link>
      <pubDate>Fri, 25 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/git/readnote/%E7%B2%BE%E9%80%9Agit_22/</guid>
      <description>&lt;h2 id=&#34;精通git&#34;&gt;精通Git&lt;/h2&gt;&#xA;&lt;h3 id=&#34;git基础&#34;&gt;Git基础&lt;/h3&gt;&#xA;&lt;h4 id=&#34;获取git仓库&#34;&gt;获取Git仓库&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git init&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;记录每次更新到仓库&#34;&gt;记录每次更新到仓库&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git add .&#xA;git commit -m &#39;commit mesg&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;查询提交历史&#34;&gt;查询提交历史&lt;/h4&gt;&#xA;&lt;p&gt;#+END_SRC&#xA;git log&#xA;#+END_SRC&lt;/p&gt;&#xA;&lt;h4 id=&#34;撤消操作&#34;&gt;撤消操作&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git commit --amend&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;这个命令会将暂存区中的文件提交，如果自上次提交以来你还未做任何修改，那么快照会保持不变，而你所修改的只是提交信息。&#xA;e.g.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git commit -m &#39;initial commit&#39;&#xA;git add ofrgotten_file&#xA;git commit --amend&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;最终你只会有一个提交 - 第二冷饮提交将代替第一次提交的结果。&lt;/p&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;取消暂存的文件&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git reset HEAD&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;撤消对文件的修改&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git checkout xxx.file&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;远程仓库的使用&#34;&gt;远程仓库的使用&lt;/h4&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;查看远程仓库&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;get remote -v&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;添加远程仓库&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git remote add &amp;lt;shortname&amp;gt; &amp;lt;url&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;从远程仓库中抓取与拉取&lt;/p&gt;</description>
    </item>
    <item>
      <title>重构2</title>
      <link>https://stoneepigraph.github.io/posts/%E9%87%8D%E6%9E%842/</link>
      <pubDate>Fri, 25 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/%E9%87%8D%E6%9E%842/</guid>
      <description>&lt;h2 id=&#34;开始&#34;&gt;开始&lt;/h2&gt;&#xA;&lt;p&gt;本章重构：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将原函数分解成一组嵌套的函数&lt;/li&gt;&#xA;&lt;li&gt;分离计算逻辑与输出格式化逻辑&lt;/li&gt;&#xA;&lt;li&gt;为计算器引入多态性来处理计算逻辑&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;好的代码的检验标准就是人们是否能构轻易地修改它注： 小步累积&lt;/p&gt;&#xA;&lt;h2 id=&#34;重构的原则&#34;&gt;重构的原则&lt;/h2&gt;&#xA;&lt;h3 id=&#34;何谓重构&#34;&gt;何谓重构&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;名: 对软件内部结构的一种调整,目的是在不改变软件可观察行为的前提下,提高其可理解性,降低其修改成本.&lt;/li&gt;&#xA;&lt;li&gt;动: 使用一系列重构手法,在不改变软件可观察行为的前提下,高速其结构.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;重构时不添加新功能-添加新功能时不重构-dot&#34;&gt;重构时不添加新功能,添加新功能时不重构.&lt;/h3&gt;&#xA;&lt;h3 id=&#34;为何重构&#34;&gt;为何重构&lt;/h3&gt;&#xA;&lt;h4 id=&#34;改进软件的设计&#34;&gt;改进软件的设计&lt;/h4&gt;&#xA;&lt;h4 id=&#34;使软件更容易理解&#34;&gt;使软件更容易理解&lt;/h4&gt;&#xA;&lt;h4 id=&#34;帮助找到bug&#34;&gt;帮助找到BUG&lt;/h4&gt;&#xA;&lt;h4 id=&#34;提高编程速度&#34;&gt;提高编程速度&lt;/h4&gt;&#xA;&lt;h3 id=&#34;何时重构&#34;&gt;何时重构&lt;/h3&gt;&#xA;&lt;p&gt;事不过三, 三则重构&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;预备性重构: 在添加新功能之前进行重构&lt;/li&gt;&#xA;&lt;li&gt;帮助理解的重构:&lt;/li&gt;&#xA;&lt;li&gt;捡垃圾式重构:&#xA;不想从眼下正要完成的代码上跑题太多,但也不想把垃圾留在原地.所以在重构可以很快完成时就立即重构,如果需要花一些精力,可以做一个TODO.至少要让营地比你到达时干净.&lt;/li&gt;&#xA;&lt;li&gt;有计划的重构和见机行事的重构每次修改时,首先令修改很容易,然后再进行这次容易的修改.&lt;/li&gt;&#xA;&lt;li&gt;长期重构如果想替换掉一个正在使用的库,需要很长时间,可以先引入一层新的抽象,使其兼容新旧的两个库的接口.一旦调用方已经完全为使用这层抽象,替换掉下面的库就会容易很多.&lt;/li&gt;&#xA;&lt;li&gt;重审代码时重构&lt;/li&gt;&#xA;&lt;li&gt;何是不应该重构&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果我看见一块凌乱的代码,但并不需要修改它,那么我就不需要重构它.&lt;/li&gt;&#xA;&lt;li&gt;如果丑陋的代码能被隐藏在一个API之下,我就可以容忍它继续保持丑陋.&lt;/li&gt;&#xA;&lt;li&gt;如果重写比重构还容易,就别重构了.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;重构的挑战&#34;&gt;重构的挑战&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;延缓新功能开发&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;代码的坏味道&#34;&gt;代码的坏味道&lt;/h2&gt;&#xA;&lt;h3 id=&#34;神秘命名&#34;&gt;神秘命名&lt;/h3&gt;&#xA;&lt;h3 id=&#34;重复代码&#34;&gt;重复代码&lt;/h3&gt;&#xA;&lt;h3 id=&#34;过长函数&#34;&gt;过长函数&lt;/h3&gt;&#xA;&lt;p&gt;现代编程语言几乎已经完全免除了进程内的函数调用开销.&lt;/p&gt;&#xA;&lt;h3 id=&#34;过长的参数列表&#34;&gt;过长的参数列表&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果可以向某个参数发起查询而获得另一个参数的值,那么就可以使用以查询取代参数去掉这第二个参数.&lt;/li&gt;&#xA;&lt;li&gt;如果正在从现有的数据结构中抽出很多数据荐,就可以考虑使用保持对象完整手法&lt;/li&gt;&#xA;&lt;li&gt;如果有几项参数总是同时出现,可以引入参数对象&lt;/li&gt;&#xA;&lt;li&gt;如果某个参数被用作区分函数行为的标记,可以使用移除标记参数.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;全局数据&#34;&gt;全局数据&lt;/h3&gt;&#xA;&lt;p&gt;可以把全局数据用一个函数包装起来,至少能看见修改它的地方.&lt;/p&gt;&#xA;&lt;h3 id=&#34;可变数据&#34;&gt;可变数据&lt;/h3&gt;&#xA;&lt;h3 id=&#34;发散式变化&#34;&gt;发散式变化&lt;/h3&gt;&#xA;&lt;p&gt;每次只关心一个上下文&lt;/p&gt;&#xA;&lt;h3 id=&#34;霰弹式修改&#34;&gt;霰弹式修改&lt;/h3&gt;&#xA;&lt;h3 id=&#34;依恋情结&#34;&gt;依恋情结&lt;/h3&gt;&#xA;&lt;p&gt;总是将一起变化的东西放在一块儿.&lt;/p&gt;&#xA;&lt;h3 id=&#34;数据泥团&#34;&gt;数据泥团&lt;/h3&gt;&#xA;&lt;h3 id=&#34;基本类型偏执&#34;&gt;基本类型偏执&lt;/h3&gt;&#xA;&lt;p&gt;可以运用使用对象取代基本类型&lt;/p&gt;&#xA;&lt;h3 id=&#34;重复的switch&#34;&gt;重复的switch&lt;/h3&gt;&#xA;&lt;p&gt;任何switch语句都应该用以多态取代条件表达式.&lt;/p&gt;&#xA;&lt;h3 id=&#34;循环语句&#34;&gt;循环语句&lt;/h3&gt;&#xA;&lt;p&gt;可以使用管道取代循环&lt;/p&gt;&#xA;&lt;h3 id=&#34;冗赘的元素&#34;&gt;冗赘的元素&lt;/h3&gt;&#xA;&lt;p&gt;有些类或者额外的结构在设计过程中不再有用,就把它抛弃&lt;/p&gt;&#xA;&lt;h3 id=&#34;夸夸其谈通用性&#34;&gt;夸夸其谈通用性&lt;/h3&gt;&#xA;&lt;p&gt;那些我们想的总有一天需要做这些事,并且企图以各式各样的钩子和特殊情况来处理一些非必要的事情.&lt;/p&gt;&#xA;&lt;h3 id=&#34;临时字段&#34;&gt;临时字段&lt;/h3&gt;&#xA;&lt;h3 id=&#34;过长的消息链&#34;&gt;过长的消息链&lt;/h3&gt;&#xA;&lt;p&gt;可以使用隐藏委托关系&lt;/p&gt;&#xA;&lt;h3 id=&#34;中间人&#34;&gt;中间人&lt;/h3&gt;&#xA;&lt;p&gt;如果你看到某个类中有一半的函数都委托给其它类,这样就是过度运用.应该移除中间人.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Jenkins入门</title>
      <link>https://stoneepigraph.github.io/posts/jenkins%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/jenkins%E5%85%A5%E9%97%A8/</guid>
      <description>&lt;h2 id=&#34;gitlab配置&#34;&gt;gitlab配置&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;wget &amp;ndash;content-disposition &lt;a href=&#34;https://packages.gitlab.com/gitlab/gitlab-ce/packages/el/7/gitlab-ce-13.2.4-ce.0.el7.x86_64.rpm/download.rpm&#34;&gt;https://packages.gitlab.com/gitlab/gitlab-ce/packages/el/7/gitlab-ce-13.2.4-ce.0.el7.x86_64.rpm/download.rpm&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;安装信赖&#xA;&lt;ol&gt;&#xA;&lt;li&gt;yum install curl openssh-server postfix cronie&lt;/li&gt;&#xA;&lt;li&gt;yum -y install policycoreutils-python&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;rpm -ivh gitlab-ce&lt;/li&gt;&#xA;&lt;li&gt;config gitlab&#xA;&lt;ol&gt;&#xA;&lt;li&gt;vi /etc/gitlab/gitlab.rb&#xA;external_url:&#xA;nginx[&amp;rsquo;listen_port&#39;]&lt;/li&gt;&#xA;&lt;li&gt;gitlab-ctl reconfigure&lt;/li&gt;&#xA;&lt;li&gt;gitlab-ctl restart&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;配置防火墙&lt;/li&gt;&#xA;&lt;li&gt;配置gitlab组及用户&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;jenkins安装&#34;&gt;jenkins安装&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;安装Jenkins跳过插件安装&lt;/li&gt;&#xA;&lt;li&gt;jenkins插件安装&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;tips&#34;&gt;tips&lt;/h2&gt;&#xA;&lt;h3 id=&#34;三台服务器-一台gitlab-一台jenkins-一台测试服务器&#34;&gt;三台服务器,一台gitlab, 一台Jenkins, 一台测试服务器&lt;/h3&gt;</description>
    </item>
    <item>
      <title>MyBatis基础</title>
      <link>https://stoneepigraph.github.io/posts/mybatis%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/mybatis%E5%9F%BA%E7%A1%80/</guid>
      <description>&lt;h2 id=&#34;入门&#34;&gt;入门&lt;/h2&gt;&#xA;&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Jar包安装&lt;/li&gt;&#xA;&lt;li&gt;Maven导入&lt;/li&gt;&#xA;&lt;li&gt;Gradle导入&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;从xml中构建sqlsessionfactory&#34;&gt;从XML中构建SqlSessionFactory&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String resource = &amp;quot;org/mybatis/example/mybatis-config.xml&amp;quot;;&#xA;InputStream inputStream = Resources.getResourceAsStream(resource);&#xA;SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;XML配置&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;&#xA;&amp;lt;!DOCTYPE configuration&#xA;  PUBLIC &amp;quot;-//mybatis.org//DTD Config 3.0//EN&amp;quot;&#xA;  &amp;quot;http://mybatis.org/dtd/mybatis-3-config.dtd&amp;quot;&amp;gt;&#xA;&amp;lt;configuration&amp;gt;&#xA;  &amp;lt;environments default=&amp;quot;development&amp;quot;&amp;gt;&#xA;    &amp;lt;environment id=&amp;quot;development&amp;quot;&amp;gt;&#xA;      &amp;lt;transactionManager type=&amp;quot;JDBC&amp;quot;/&amp;gt;&#xA;      &amp;lt;dataSource type=&amp;quot;POOLED&amp;quot;&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;driver&amp;quot; value=&amp;quot;${driver}&amp;quot;/&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;${url}&amp;quot;/&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;${username}&amp;quot;/&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${password}&amp;quot;/&amp;gt;&#xA;      &amp;lt;/dataSource&amp;gt;&#xA;    &amp;lt;/environment&amp;gt;&#xA;  &amp;lt;/environments&amp;gt;&#xA;  &amp;lt;mappers&amp;gt;&#xA;    &amp;lt;mapper resource=&amp;quot;org/mybatis/example/BlogMapper.xml&amp;quot;/&amp;gt;&#xA;  &amp;lt;/mappers&amp;gt;&#xA;&amp;lt;/configuration&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;不使用xml构建sqlsessionfactory&#34;&gt;不使用XML构建SqlSessionFactory&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;DataSource dataSource = BlogDataSourceFactory.getBlogDataSource();&#xA;TransactionFactory transactionFactory = new JdbcTransactionFactory();&#xA;Environment environment = new Environment(&amp;quot;development&amp;quot;, transactionFactory, dataSource);&#xA;Configuration configuration = new Configuration(environment);&#xA;configuration.addMapper(BlogMapper.class);&#xA;SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;从sqlsessionfactory中获取sqlsession&#34;&gt;从SqlSessionFactory中获取SqlSession&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SqlSession session = SqlSessionFactory.openSession();&#xA;try {&#xA;    //Blog blog = (Blog) session.selectOne(&amp;quot;*.*.BlogMapper.seelctBlog&amp;quot;, 1);&#xA;    BlogMapper mapper = session.getMapper(BlogMapper.class);&#xA;    Blog blog = mapper.selectBlog(1);&#xA;} finally {&#xA;    session.close();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;mapper的配置&#34;&gt;Mapper的配置&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;XML的配置&lt;/p&gt;</description>
    </item>
    <item>
      <title>Oracle一些简单查询</title>
      <link>https://stoneepigraph.github.io/posts/oracle%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/oracle%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2/</guid>
      <description>&lt;h2 id=&#34;oracle一些基本查询&#34;&gt;Oracle一些基本查询&lt;/h2&gt;&#xA;&lt;h4 id=&#34;字符集相关&#34;&gt;字符集相关&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;查询数据库字符集&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select userenv(&#39;language&#39;) from dual;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;实例相关&#34;&gt;实例相关&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;查询实例名&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select instance_name from v$instance;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;锁相关&#34;&gt;锁相关&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;查看被锁的表&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select b.username,b.sid,b.serial#,logon_time from v$locked_object a,v$session b where a.session_id = b.sid order by b.logon_time;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;杀死锁进程&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;alter system kill session &#39;id,serial*&#39;;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;查询表之前的状态&#34;&gt;查询表之前的状态&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from tablename AS OF TIMESTAMP (SYSTIMESTAMP - INTERVAL &#39;50&#39; MINUTE)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;用户&#34;&gt;用户&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;查询当前用户的缺省表空间&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select username,default_tablespace from user_users;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;查询当前用户的角色&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from user_role_privs;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;查看当前用户的系统权限和表级权限&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from user_sys_privs;&#xA;select * from user_tab_privs;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;查询用户下的所有的表&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from user_tables;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;表&#34;&gt;表&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;查看用户下所有的表&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from user_tables;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;查看名称包含log字符的表&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select object_name,object_id from user_objects where instr(object_name,&#39;LOG&#39;)&amp;gt;0;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;查询表的创建时间&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select object_name,created from user_objects where object_name=upper(&#39;&amp;amp;table_name&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;查询表的大小&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select sum(bytes)/(1024*1024) as &amp;quot;size(M)&amp;quot; from user_segments where segment_name=upper(&#39;&amp;amp;table_name&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;查看放在Oracle的内存区里的表&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select table_name,cache from user_tables where instr(cache,&#39;Y&#39;)&amp;gt;0;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;查询表的DDL语句&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select dbms_metadata.get_ddl(&#39;TABLE&#39;,upper(&#39;tr_rpt_repair_record&#39;),upper(&#39;bjvmmis&#39;)) from dual;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;索引&#34;&gt;索引&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;查看索引个数和类别&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select index_name,index_type,table_name from user_indexes order by table_name;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;查看索引被索引的字段&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from user_ind_columns where index_name=upper(&#39;&amp;amp;index_name&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;查看索引的大小&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select sum(bytes)/(1024*1024) as &amp;quot;size(M)&amp;quot; from user_segments&#xA;where segment_name=upper(&#39;&amp;amp;index_name&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;序列号&#34;&gt;序列号&lt;/h4&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;查看序列号，last_number是当前值&lt;/p&gt;</description>
    </item>
    <item>
      <title>postgresql-note</title>
      <link>https://stoneepigraph.github.io/posts/postgresql%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/postgresql%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h2 id=&#34;安装及配置&#34;&gt;安装及配置&lt;/h2&gt;&#xA;&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;下载postgresql   &lt;a href=&#34;https://www.postgresql.org/download/&#34;&gt;https://www.postgresql.org/download/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;安装 按照官网的说明安装&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;su - postgres -c &amp;quot;pg_ctl -D /var/lib/postgres/data -l /var/log/postgresql/postgresql.log start&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;切换到postgres用户修改postgres密码&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;!--listend--&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;su - postres&#xA;alter user postgres with password &#39;passwod&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;备份及恢复&#34;&gt;备份及恢复&lt;/h2&gt;&#xA;&lt;h3 id=&#34;备份&#34;&gt;备份&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pg_dump dbname &amp;gt; dbname.bak   # 备份单个数据库&#xA;pg_dumpall &amp;gt; pd_backup.bak    # 备份所有的数据库&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;备份格式有三种， 可以使用-F指定&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;*.bak 压缩二进制文件&lt;/li&gt;&#xA;&lt;li&gt;*.sql 明文转储&lt;/li&gt;&#xA;&lt;li&gt;*.tar tarball  t&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;恢复&#34;&gt;恢复&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;psql dbname &amp;lt; dbanme.bak&#xA;pg_restore -U postgres -d dbname /tmp/back_filename.tar&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;注意&#34;&gt;注意&lt;/h4&gt;&#xA;&lt;p&gt;使用psql恢复数据库需要先创建一个空的对应名称的数据库&lt;/p&gt;&#xA;&lt;h2 id=&#34;序列&#34;&gt;序列&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;查询序列的值&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select nextval(&#39;sys_menu_menu_id_seq&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;修改序列的值从某个新值开始&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT setval(&#39;bi_his_corp_policy_part_id_seq&#39;, (SELECT MAX(id) FROM bi_his_corp_policy));&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;修改序列&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;         alter sequence sys_menu_menu_id_seq&#xA;increment by 1&#xA;    restart with 2354;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;基础&#34;&gt;基础&lt;/h2&gt;&#xA;&lt;h3 id=&#34;函数&#34;&gt;函数&lt;/h3&gt;&#xA;&lt;h4 id=&#34;创建函数&#34;&gt;创建函数&lt;/h4&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;exp insert&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;create or replace function fun_date2utc(p_date timestamp) returns bigint&#xA;    language pluxsql&#xA;as&#xA;$$&#xA;declare&#xA;    utc integer;&#xA;begin&#xA;    utc = 86400 * (p_date - to_date(&#39;1970/01/01 00:00:00&#39;, &#39;YYYY/MM/DD HH24:MI:SS&#39;)) - 8*3600;&#xA;    return utc;&#xA;end;&#xA;$$;&#xA;create trigger trg_insert_local_vehicle2_dynamic&#xA;    before insert&#xA;    on bi_inf_vehicle_local&#xA;    for each row&#xA;execute procedure check_insert_dynamic_vehicle();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;exp delete&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;          create function check_delete_dynamic_vehicle() returns trigger&#xA;    language pluxsql&#xA;as&#xA;$$&#xA;begin&#xA;    delete from vd_sta_vehicle_local where vehicle_id = old.id;&#xA;    return old;&#xA;end;&#xA;$$;&#xA;alter function check_delete_dynamic_vehicle() owner to uxdb;&#xA;create trigger trg_delete_local_vehicle2_dynamic&#xA;      before delete&#xA;      on bi_inf_vehicle_local&#xA;      for each row&#xA;  execute procedure check_delete_dynamic_vehicle();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;一些函数&#34;&gt;一些函数&lt;/h4&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;生成序列&#xA;&lt;ul&gt;&#xA;&lt;li&gt;generate_series()&#xA;&lt;ul&gt;&#xA;&lt;li&gt;生成数字序列&#xA;&lt;pre&gt;&lt;code class=&#34;language-nil&#34;&gt;select generate_series(1, 10)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;生成时间序列&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--listend--&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select generate_series(now()::timestamp, now()::timestamp + interval &#39;100 day&#39;, interval &#39;1 day&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;索引&#34;&gt;索引&lt;/h2&gt;&#xA;&lt;h3 id=&#34;postgresql使用什么数据结构保存索引的-b-tree&#34;&gt;postgresql使用什么数据结构保存索引的: B-tree&lt;/h3&gt;&#xA;&lt;h2 id=&#34;分区表&#34;&gt;分区表&lt;/h2&gt;&#xA;&lt;h3 id=&#34;创建分区表&#34;&gt;创建分区表&lt;/h3&gt;&#xA;&lt;p&gt;创建分区表需要在表结构结束添加 partition by partition_type(partition_key);&lt;/p&gt;</description>
    </item>
    <item>
      <title>用Python写网络爬虫</title>
      <link>https://stoneepigraph.github.io/posts/%E7%94%A8python%E5%86%99%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/%E7%94%A8python%E5%86%99%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/</guid>
      <description>&lt;h2 id=&#34;网络爬虫简介&#34;&gt;网络爬虫简介&lt;/h2&gt;&#xA;&lt;h3 id=&#34;识别网站所用技术builtwith模块&#34;&gt;识别网站所用技术&amp;mdash;&amp;mdash;builtwith模块&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;pip install builtwith&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import builtwith&#xA;builtwith.parse(&amp;quot;sample.website.com&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;寻找网站的所有者&#34;&gt;寻找网站的所有者&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;pip install python-whois&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import whois&#xA;print(whois.whois(&#39;sample.website.com&#39;))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;编写第一个网络爬虫&#34;&gt;编写第一个网络爬虫&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;3种爬取网站的常见方法：&lt;/em&gt;&lt;/strong&gt; - 爬取网站地图 - 遍历每个网页的数据库ID -&#xA;跟踪网页链接&lt;/p&gt;&#xA;&lt;h4 id=&#34;下载网页&#34;&gt;下载网页&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import urllib2&#xA;def download(url):&#xA;    print(&#39;Downloading。。。&#39;, url)&#xA;    try:&#xA;        html = urllib2.urlopen(url).read()&#xA;    except urllib2.URLError e:&#xA;        print(&amp;quot;Download error:&amp;quot;, e.reason)&#xA;        html = None&#xA;    return html&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;下载内容时可能会遇到一些无法控制的错误，如果请求的页面可能不存在。因此需要捕获异常。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;而有些时间的错误可能是临时性的，比如503，对于此类错误，我们可以尝试重新下载。重试N次后还失败，再返回错误。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;因为Python默认的请求头通常会被网站封禁，所以我们需要添加请求代理。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def download(url, user_agent=&amp;quot;wswp&amp;quot;, num_retries=5):&#xA;  print(&amp;quot;download...: &#39;, url)&#xA;  headers = {&#39;User-agent&#39;: user_agent}&#xA;  request = urllibs.Request(url, headers=hearders)&#xA;  try:&#xA;      html - urllib2.urlopen(request).read()&#xA;  except urllib2.URLError as e:&#xA;      print(&#39;Download error: &#39;, e.reason)&#xA;      html = None&#xA;  return html&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;strong&gt;*&lt;/strong&gt; 网站地图爬虫&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
