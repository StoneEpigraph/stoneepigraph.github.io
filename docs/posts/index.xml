<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 石记</title>
    <link>https://stoneepigraph.github.io/posts/</link>
    <description>Recent content in Posts on 石记</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Wed, 04 Sep 2024 16:35:00 +0800</lastBuildDate>
    <atom:link href="https://stoneepigraph.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>如何设计程序</title>
      <link>https://stoneepigraph.github.io/posts/book/common/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Wed, 04 Sep 2024 16:35:00 +0800</pubDate>
      <guid>https://stoneepigraph.github.io/posts/book/common/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A8%8B%E5%BA%8F/</guid>
      <description>&lt;h2 id=&#34;如何设计程序&#34;&gt;如何设计程序&lt;/h2&gt;&#xA;&lt;h3 id=&#34;base&#34;&gt;Base&lt;/h3&gt;&#xA;&lt;h4 id=&#34;基本程序设计步骤&#34;&gt;基本程序设计步骤&lt;/h4&gt;&#xA;&lt;!--list-separator--&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;六个基本的程序设计步骤&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;问题分析和数据定义&lt;/li&gt;&#xA;&lt;li&gt;合约,用途说明与结果的描述,函数头部&lt;/li&gt;&#xA;&lt;li&gt;例子&lt;/li&gt;&#xA;&lt;li&gt;函数模板&lt;/li&gt;&#xA;&lt;li&gt;函数定义&lt;/li&gt;&#xA;&lt;li&gt;测试&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;六个步骤产生定义明确的中间结果&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;问题数据类型描述&lt;/li&gt;&#xA;&lt;li&gt;程序行为的非形式描述&lt;/li&gt;&#xA;&lt;li&gt;说明程序行为的例子&lt;/li&gt;&#xA;&lt;li&gt;开发程序的模板或视图&lt;/li&gt;&#xA;&lt;li&gt;把模板转换成完整的定义&lt;/li&gt;&#xA;&lt;li&gt;通过测试发现错误&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;要正确的设计程序需要做到&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;分析通常使用文字表述的问题&lt;/li&gt;&#xA;&lt;li&gt;在抽象表达问题实质的同时使用例子进行说明&lt;/li&gt;&#xA;&lt;li&gt;用精确的语言阐明所表述的语句和注释&lt;/li&gt;&#xA;&lt;li&gt;通过检查,测试对上述活动进行评价和修改&lt;/li&gt;&#xA;&lt;li&gt;关注细节&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;简单数据的处理&#34;&gt;简单数据的处理&lt;/h3&gt;&#xA;&lt;h4 id=&#34;学生-教师和计算机&#34;&gt;学生,教师和计算机&lt;/h4&gt;&#xA;&lt;p&gt;程序只是计算速度非常快的学生,不过程序并不能理解自然语言,所以我们需要学会一门计算机语言将自然语言翻译给计算机.但程序设计需要耐心和专心,保能关注每个微小的细节,并严格规划和对规划忠诚,才能避免错误.&lt;/p&gt;&#xA;&lt;h4 id=&#34;数-表达式和简单程序&#34;&gt;数,表达式和简单程序&lt;/h4&gt;&#xA;&lt;!--list-separator--&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;数和算术运算&lt;/p&gt;&#xA;&lt;p&gt;讲述了数和Scheme的一些基本知识&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;变量和程序&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;字处理问题&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;错误&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;设计程序&lt;/p&gt;</description>
    </item>
    <item>
      <title>Awk入门</title>
      <link>https://stoneepigraph.github.io/posts/awk/</link>
      <pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/awk/</guid>
      <description>&lt;h2 id=&#34;awk语言&#34;&gt;AWK语言&lt;/h2&gt;&#xA;&lt;h2 id=&#34;变量&#34;&gt;变量&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;NF： awk计算当前行的字段数量&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;NR： awk计算到目前为止，读取到的行的数量&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;$0: 整行内容&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;$1: 第一个字段&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;$N: 第N个字段&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;#: 注释&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;逻辑&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&amp;amp;&amp;amp;&lt;/li&gt;&#xA;&lt;li&gt;||&lt;/li&gt;&#xA;&lt;li&gt;!&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;模式&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;BEGIN&#xA;在第一个输入文件的第一行之前被匹配&lt;/li&gt;&#xA;&lt;li&gt;END&#xA;在最后一个输入文件的最后一行被处理之后匹配例：&#xA;awk -F &amp;lsquo;:&amp;rsquo; &amp;lsquo;BEGIN {print &amp;ldquo;id    name    shell&amp;rdquo;; print &amp;ldquo;&amp;rdquo;}&#xA;{emp = emp + 1; print NF, $1, $NF}&#xA;END {print &amp;ldquo;total rows: &amp;ldquo;, emp}&amp;rsquo; /etc/passwd&lt;/li&gt;&#xA;&lt;li&gt;expression { statements}&#xA;每碰到一个使expression为真的输入行，statements就执行， expression为真指的是其值非零或非空&lt;/li&gt;&#xA;&lt;li&gt;&lt;em&gt;regular expression&lt;/em&gt; {statements}&#xA;当碰到这样一个输入行时， statements就执行： 输入行含有一段字符串，而该字符串可以被regular expression匹配&lt;/li&gt;&#xA;&lt;li&gt;compound parttern {statements}&#xA;一个复合模式将表达式用 &amp;amp;&amp;amp;(AND), ||(OR), !(NOT), 以及括号组合起来；当compound parttern为真时， statements执行。&lt;/li&gt;&#xA;&lt;li&gt;pattern1, pattern2 { statemtnts }&#xA;一个范围模式匹配多个输入行，这些输入行从匹配pattern1的行开始，到匹配pattern2的行结束（包括这两行）， 对这其中的每一行执行statements.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;流程控制&lt;/p&gt;</description>
    </item>
    <item>
      <title>Docker笔记</title>
      <link>https://stoneepigraph.github.io/posts/docker/</link>
      <pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/docker/</guid>
      <description>&lt;h2 id=&#34;入门&#34;&gt;入门&lt;/h2&gt;&#xA;&lt;h3 id=&#34;什么是docker&#34;&gt;什么是Docker&lt;/h3&gt;&#xA;&lt;p&gt;docker是一个容器技术。&lt;/p&gt;&#xA;&lt;h3 id=&#34;docker的优势&#34;&gt;Docker的优势&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;一致的运行环境， 更轻松的迁移。&lt;/li&gt;&#xA;&lt;li&gt;对进程进行封装隔离，容器与容器之间互不影响，更高效的利用系统资源。&lt;/li&gt;&#xA;&lt;li&gt;通过镜像复制多个环境一致的容器。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;docker与虚拟机的对比&#34;&gt;Docker与虚拟机的对比&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Docker占用磁盘少&lt;/li&gt;&#xA;&lt;li&gt;Docker的引擎比虚拟机系统占用CPU资源低&lt;/li&gt;&#xA;&lt;li&gt;Docker启动速度快&lt;/li&gt;&#xA;&lt;li&gt;Docker安装管理方便&lt;/li&gt;&#xA;&lt;li&gt;Docker从第二次部署开始轻松简捷&lt;/li&gt;&#xA;&lt;li&gt;Docker可以每个应用使用一个服务，服务隔离&lt;/li&gt;&#xA;&lt;li&gt;Docker推荐使用Linux，不推荐使用Windows&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;安装及配置&#34;&gt;安装及配置&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;下载安装&lt;/li&gt;&#xA;&lt;li&gt;配置&#xA;&lt;ol&gt;&#xA;&lt;li&gt;启动Docker&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo systemctl enable docker&#xA;sudo systemctl start docker&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;创建Docker用户组&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo groupadd docker&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;将当前用户添加到docker组&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo usermod -aG docker $USER&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;测试Docker是否安装正确&lt;/li&gt;&#xA;&lt;li&gt;重启Docker&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo systemctl restart docker&#xA;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>Flask Web开发实战</title>
      <link>https://stoneepigraph.github.io/posts/flask-web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</link>
      <pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/flask-web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</guid>
      <description>&lt;h2 id=&#34;flask-web开发实战&#34;&gt;Flask Web开发实战&lt;/h2&gt;&#xA;&lt;h3 id=&#34;基础&#34;&gt;基础&lt;/h3&gt;&#xA;&lt;h4 id=&#34;初识&#34;&gt;初识&lt;/h4&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;开发环境&lt;/p&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;pipenv工作流&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;pip install pipenv&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA; &lt;!--quoteend--&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;pipenv install # 创建虚拟环境&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA; &lt;!--quoteend--&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;pipenv shell # 进入虚拟环境&#xA;pipenv run command #使用虚拟环境执行命令&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA; &lt;!--quoteend--&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;pipenv graph # 查看当前环境的依赖&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Hello，Flask&lt;/p&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;创建程序实例&lt;/p&gt;&#xA;&lt;p&gt;新建app.py(可以是除flask.py之外任意名字)&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java8函数式编程</title>
      <link>https://stoneepigraph.github.io/posts/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</guid>
      <description>&lt;h2 id=&#34;函数式编程&#34;&gt;函数式编程&lt;/h2&gt;&#xA;&lt;p&gt;函数式编程中没有赋值语句,因此变量一旦有了值,就不会再改变了.更通俗地说,函数式编程完全没有副作用.&lt;/p&gt;&#xA;&lt;h2 id=&#34;lambda表达式&#34;&gt;Lambda表达式&lt;/h2&gt;&#xA;&lt;h3 id=&#34;格式&#34;&gt;格式&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;() -&amp;gt; {}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;参数：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;(): 表式没有参数&lt;/li&gt;&#xA;&lt;li&gt;单个参数可不加括号&lt;/li&gt;&#xA;&lt;li&gt;参数可以不加类型，由编译器去推断类型，也可以加上类型。加类型的话需要使用小括号包起来。&lt;/li&gt;&#xA;&lt;li&gt;参数引用的值而不是变量。但不必须写final变量。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;主体：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可以是一个表达式，也可以是一段代码块，如果是一段代码块需要使用大括号包起来。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;函数式接口&#34;&gt;函数式接口&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Java里函数式接口的主要类型&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;接口&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;参数&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;返回类型&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;示例&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&amp;mdash;-&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&amp;mdash;&amp;mdash;&amp;ndash;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&amp;mdash;-&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Predicate&amp;lt;T&amp;gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;T&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;boolean&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Consumer&amp;lt;T&amp;gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;T&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;void&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Function&amp;lt;T, R&amp;gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;T&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;R&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Supplier&amp;lt;T&amp;gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;None&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;T&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;UnaryOperator&amp;lt;T&amp;gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;T&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;T&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;BinaryOperator&amp;lt;T&amp;gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;T, T&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;T&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;流-stream&#34;&gt;流（Stream）&lt;/h2&gt;&#xA;&lt;p&gt;Stream是用函数式编程方式 在集合类上进行复杂操作的工具。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linux命令行与Shell脚本大全</title>
      <link>https://stoneepigraph.github.io/posts/os/linux/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E5%A4%A7%E5%85%A8/</link>
      <pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/os/linux/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E5%A4%A7%E5%85%A8/</guid>
      <description>&lt;h2 id=&#34;linux命令行&#34;&gt;Linux命令行&lt;/h2&gt;&#xA;&lt;h3 id=&#34;初识linux-shell&#34;&gt;初识Linux Shell&lt;/h3&gt;&#xA;&lt;h4 id=&#34;什么是linux&#34;&gt;什么是Linux&lt;/h4&gt;&#xA;&lt;p&gt;Linux可划分为以下四部分：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Linux内核&lt;/li&gt;&#xA;&lt;li&gt;GNU工具&lt;/li&gt;&#xA;&lt;li&gt;图形化桌面环境&lt;/li&gt;&#xA;&lt;li&gt;应用软件&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;深入探究Linux内核&lt;/p&gt;&#xA;&lt;p&gt;内核主要负责以下四种功能：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;系统内存管理&lt;/li&gt;&#xA;&lt;li&gt;软件程序管理&lt;/li&gt;&#xA;&lt;li&gt;硬件设备管理&lt;/li&gt;&#xA;&lt;li&gt;文件系统管理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;系统内存管理&lt;/p&gt;&#xA;&lt;p&gt;不公管理服务器上的可用物理内存，还可以创建和不容易理虚拟内存。内核通过硬盘上的存储空间来实现虚拟内存，这块区域称为交换空间（swap space）。内丰存储单元按组划分成很多块，这些块称作页面（page）。内核将每个存在 页面放在物理内存或交换空间。然后， 内核 会维护一个内存页面表。指明哪些页面位于物理内存内，哪些页面被换到硬盘上。内核会记录哪些内存页面正在使用中，并自动把一段时间未访问的内存页面复制 到交换空间区域（称为换出，swapping out_）即使不宜可用内存。当程序要访问一个已被换出的内存页面时，内核必需从物理内存换出另外一个内存页面给它让出空间，然后从交换空间换入请求的内存页面。显然，这个过程 要花时间，拖慢运行的进程。只要Linux系统在运行，为运行中的程序换出内存面对面的的过程 就不会停歇。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;软件程序管理&lt;/p&gt;&#xA;&lt;p&gt;Linux操作系统将运行中的程序称为进程。可分为前台运行和后台运行。内核控制着Linux系统管理运行在系统上的所有进程。内核创建了第一个进程（称为init进程）来启动系统上所有的其他进程。当内核启动时，它会将init进程加载到虚拟 内存中。内核 在启动任何其他进程时，都 会在虚拟 内存中给新进程分配 一块发你的区域 来存储该 进程用到的数据和代码。一些Linux发行版使用一个表来管理在系统开机时要自动 启动的进程。在Linux系统上，这个表通常位于专门文件/etc/inittab中。有的系统（如Ubuntu）则采用/etc/init.d目录将开机时启动或停止某个应用的脚本 放在之个目录 下。这些脚本通过/etc/rcX.d目录下的入口 启动。X代表运行级别。运行级别：​&#x9;1.单用户​&#x9;3.标准启动​&#x9;5.X Windows&#xA;​&#x9;6.重启&lt;/p&gt;</description>
    </item>
    <item>
      <title>maven基础</title>
      <link>https://stoneepigraph.github.io/posts/language/java/maven/</link>
      <pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/language/java/maven/</guid>
      <description>&lt;h2 id=&#34;maven库&#34;&gt;Maven库：&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://repo2.maven.org/maven2/&#34;&gt;http://repo2.maven.org/maven2/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;maven依赖查询&#34;&gt;Maven依赖查询：&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://mvnrepository.com/&#34;&gt;http://mvnrepository.com/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;maven常用命令&#34;&gt;Maven常用命令：&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;创建Maven的普通java项目：&#xA;mvn archetype:create&#xA;-DgroupId=packageName&#xA;-DartifactId=projectName&lt;/li&gt;&#xA;&lt;li&gt;创建Maven的Web项目：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;​    mvn archetype:create&#xA;​    -DgroupId=packageName&#xA;​    -DartifactId=webappName&#xA;​    -DarchetypeArtifactId=maven-archetype-webapp&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;编译源代码： mvn compile&lt;/li&gt;&#xA;&lt;li&gt;编译测试代码：mvn test-compile&lt;/li&gt;&#xA;&lt;li&gt;运行测试：mvn test&lt;/li&gt;&#xA;&lt;li&gt;产生site：mvn site&lt;/li&gt;&#xA;&lt;li&gt;打包：mvn package&lt;/li&gt;&#xA;&lt;li&gt;在本地Repository中安装jar：mvn install&lt;/li&gt;&#xA;&lt;li&gt;清除产生的项目：mvn clean&lt;/li&gt;&#xA;&lt;li&gt;生成eclipse项目：mvn eclipse:eclipse&lt;/li&gt;&#xA;&lt;li&gt;生成idea项目：mvn idea:idea&lt;/li&gt;&#xA;&lt;li&gt;组合使用goal命令，如只打包不测试：mvn -Dtest package&lt;/li&gt;&#xA;&lt;li&gt;编译测试的内容：mvn test-compile&lt;/li&gt;&#xA;&lt;li&gt;只打jar包: mvn jar:jar&lt;/li&gt;&#xA;&lt;li&gt;只测试而不编译，也不测试编译：mvn test -skipping compile -skipping test-compile&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;​      ( -skipping 的灵活运用，当然也可以用于其他组合命令)&lt;/p&gt;</description>
    </item>
    <item>
      <title>Nginx-note</title>
      <link>https://stoneepigraph.github.io/posts/middle/nginx-note/</link>
      <pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/middle/nginx-note/</guid>
      <description>&lt;h2 id=&#34;Nginx基础&#34;&gt;Nginx基础1&lt;/h2&gt;&#xA;&lt;h3 id=&#34;nginx架构&#34;&gt;Nginx架构&lt;/h3&gt;&#xA;&lt;h4 id=&#34;nginx事件模型&#34;&gt;nginx事件模型&lt;/h4&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;nginx是采用的异步非阻塞。&lt;/p&gt;&#xA;&lt;p&gt;拿epoll为例，当事件没准备好时，放到epoll里，事件准备好了，我们就去读写，当读写返回EAGAIN时，我们将它再次加入到epoll里。这样，只要有事件准备好了，我们就去处理它，只有当所有事件都没准备好时，才在epoll里等着。这样我们就可以并发处理大量的并发了，当然，这里的并发请求，是指未处理完的请求，线程只有一个，所以同时能处理的请求当然只有一个，只是在请求间进行不断切换而已，切换也是因为异步事件未准备好，而主动让出的。这里的切换是没有任何代价的，你可以理解为循环处理多个准备好的事件，事实上就是这样的。与多线程相比，这事事件处理方式是有很大的优势的，不需要创建线程，每个请求占用的内存也很少，没有上下文切换，事件处理非常轻量级。并发数再多也不会导致无谓的资源浪费（上下文切换）。更多的并发数，只是会占用更多的内存而已。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Nginx的worker数最好设置为CPU的核数。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;nginx基本概念&#34;&gt;Nginx基本概念&lt;/h4&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;connection&lt;/p&gt;&#xA;&lt;p&gt;在Nginx中connection就是对tcp连接的封闭，其中包括连接的socket, 读事件，写事件。利用Nginx封闭的Connection，我们可以很方便的使用Nginx来处理与连接相关的事情，比如，建立连接，发送与接受数据等。而Nginx中的http请求的处理就是建立在Connection之上的，所以Nginx不公可以作为一个web服务器， 也可以作为邮件服务器。当然，利用Nginx提供的Connection,我们可以与任何后端服务打交道。&lt;/p&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Nginx处理连接的流程&lt;/p&gt;&#xA;&lt;p&gt;首先Nginx在启动时，会解析配置文件，得到需要监听的端口与IP地址，然后在Nginx的master进程里面，先初始化好这个监控的socket（创建Socket， 设置Addrreuse等选项，绑定到指定的IP地址端口，再Listen），然后再fork出多个子进程出来，然后子进程会竞争accept新的连接。此时，客户端就可以向Nginx发起连接了。当客户端与服务端通过三次握手建立好一个连接后，Nginx的某一个子进程会Accept成功，得到这个建立好的连接的Socket，然后创建Nginx对连接的封闭，即ngx_connection_t结构体。接着，设置读写事件处理函数并添加读写事件来与客户端进行数据的交换。最后，Nginx或客户端主动关掉连接，到此，一个连接就结束了。&#xA;Nginx在实现时，是通过一个连接池来管理的，这里的连接池里保存的其实不是真实的连接，它只是一个worker_connections(不大于系统对fd的限制)大小的ngx_connection_t结构体的数组。并且，Nginx会通过一个链表free_connections来保存所有的空闲ngx_connection_t，每次获取一个连接时，就从空闲连接链表里获取一个，用完后，再放回空间连接链表里。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;request&lt;/p&gt;&#xA;&lt;p&gt;在Ningx中request我们指的是http请求，具体到Nginx中的数据结构是ngx_http_request_t。它是对一个Http请求的封装。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;指令&#34;&gt;指令&lt;/h3&gt;&#xA;&lt;h4 id=&#34;server&#34;&gt;server&lt;/h4&gt;&#xA;&lt;p&gt;用于定义服务，http中可以有多个server块&lt;/p&gt;&#xA;&lt;h4 id=&#34;listen&#34;&gt;listen&lt;/h4&gt;&#xA;&lt;p&gt;指定服务器侦听请求的IP地址和端口，如果省略地址，服务器将侦听所有地址，如果省略端口，则使用标准端口&lt;/p&gt;&#xA;&lt;h4 id=&#34;server-name&#34;&gt;server_name&lt;/h4&gt;&#xA;&lt;p&gt;服务名称，用于配置域名使用_表示不做域名匹配.&lt;/p&gt;&#xA;&lt;h4 id=&#34;location&#34;&gt;location&lt;/h4&gt;&#xA;&lt;p&gt;用于配置映射路径uri对应的配置，一个server中可以有多个location, location后面跟一个uri,可以是一个正则表达式，/表示匹配任意路径，当客户端访问的路径满足这个uri时就会执行location块里的代码&lt;/p&gt;</description>
    </item>
    <item>
      <title>Python CookBook</title>
      <link>https://stoneepigraph.github.io/posts/python-cookbook/</link>
      <pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/python-cookbook/</guid>
      <description>&lt;h2 id=&#34;数据结构与算法&#34;&gt;数据结构与算法&lt;/h2&gt;&#xA;&lt;h3 id=&#34;解压序列赋值给多个变量&#34;&gt;解压序列赋值给多个变量&lt;/h3&gt;&#xA;&lt;p&gt;注意_, /, /_, 级别的使用&lt;/p&gt;&#xA;&lt;h3 id=&#34;保留最后n个元素&#34;&gt;保留最后N个元素&lt;/h3&gt;&#xA;&lt;p&gt;collections deque&lt;/p&gt;&#xA;&lt;h3 id=&#34;查找最大或最小的n个元素&#34;&gt;查找最大或最小的N个元素&lt;/h3&gt;&#xA;&lt;p&gt;heapq.nlargest(count, list)&#xA;heapq.nsmallest(count, list)&lt;/p&gt;&#xA;&lt;h3 id=&#34;实现一个优先级队列&#34;&gt;实现一个优先级队列&lt;/h3&gt;&#xA;&lt;p&gt;heapq.heappush()&#xA;heapq.heappop()&lt;/p&gt;&#xA;&lt;h3 id=&#34;字典中的键映射多个值&#34;&gt;字典中的键映射多个值&lt;/h3&gt;&#xA;&lt;p&gt;可以将多个值放到另外的容器中。也可以全用collections模块中的defaultdict来构造这样的字典&lt;/p&gt;&#xA;&lt;h3 id=&#34;字典排序&#34;&gt;字典排序&lt;/h3&gt;&#xA;&lt;p&gt;可以使用collections模块中的OrderedDict类，它会保持元素被插入时的顺序。&lt;/p&gt;&#xA;&lt;h3 id=&#34;字典的运算&#34;&gt;字典的运算&lt;/h3&gt;&#xA;&lt;p&gt;对字典运算，通常需要使用zip()函数先将键值反转过来。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;zip(dict.values(), dict.keys())&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;可以使用sorted()对反转后的字典进行排序。因为你在一个字典上执行普通的数字运算，它们仅仅作用于键，而不是值 。&lt;/p&gt;&#xA;&lt;h3 id=&#34;查找两个字典的相同点&#34;&gt;查找两个字典的相同点&lt;/h3&gt;&#xA;&lt;p&gt;可以简单的在两字典的keys()或者items()方法返回结果上执行集合操作。&lt;/p&gt;&#xA;&lt;h3 id=&#34;删除序列相同元素并保持顺序&#34;&gt;删除序列相同元素并保持顺序&lt;/h3&gt;&#xA;&lt;p&gt;如果序列上的值都是hashable类型，那么可以简单的利用集合或者生成器来解决问题。&lt;/p&gt;&#xA;&lt;h3 id=&#34;命令切片&#34;&gt;命令切片&lt;/h3&gt;&#xA;&lt;p&gt;使用s = slice(start, stop, step)避免大量无法理解 的硬编码下标。你还可以使用s.start, s.stop, s.step获取它的属性。&lt;/p&gt;&#xA;&lt;h3 id=&#34;序列中出现次数最多的元素&#34;&gt;序列中出现次数最多的元素&lt;/h3&gt;&#xA;&lt;p&gt;collections.Counter类&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;words = [&amp;hellip;]&#xA;from collections import Counter&#xA;word_counts = Counter(words)&#xA;#出现频率最高的3个单词&#xA;top_three = word_counts.most_common(3)&lt;/p&gt;</description>
    </item>
    <item>
      <title>Python核心编程（3）</title>
      <link>https://stoneepigraph.github.io/posts/python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B3/</link>
      <pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B3/</guid>
      <description>&lt;h2 id=&#34;正则表达式&#34;&gt;正则表达式&lt;/h2&gt;&#xA;&lt;h2 id=&#34;网络编程&#34;&gt;网络编程&lt;/h2&gt;&#xA;&lt;h2 id=&#34;因特网客户端编程&#34;&gt;因特网客户端编程&lt;/h2&gt;&#xA;&lt;h3 id=&#34;因特网客户端简介&#34;&gt;因特网客户端简介&lt;/h3&gt;&#xA;&lt;h3 id=&#34;文件传输&#34;&gt;文件传输&lt;/h3&gt;&#xA;&lt;h4 id=&#34;文件传输因特协议&#34;&gt;文件传输因特协议&lt;/h4&gt;&#xA;&lt;p&gt;在当下，HTTP,FTP,scp/rsync的应用仍然广泛。&lt;/p&gt;&#xA;&lt;h4 id=&#34;python和ftp&#34;&gt;Python和FTP&lt;/h4&gt;&#xA;&lt;h4 id=&#34;ftplib.ftp类&#34;&gt;ftplib.FTP类&lt;/h4&gt;&#xA;&lt;h4 id=&#34;客户端ftp程序实例&#34;&gt;客户端FTP程序实例&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#! /usr/bin/env python&#xA;# coding: utf-8&#xA;import ftplib&#xA;import os&#xA;import socket&#xA;HOST = &#39;ftp.mozilla.org&#39;&#xA;DIRN = &#39;pub/mozilla.org/webtools&#39;&#xA;FILE = &#39;bugzilla-LATEST.tar.gz&#39;&#xA;def main():&#xA;    try:&#xA;        f = ftplib.FTP(HOST)&#xA;    except (socket.error, socket.gaierror) as e:&#xA;        print(&amp;quot;ERROR: can&#39;t reach &#39;%s&#39; &amp;quot; % HOST)&#xA;        return&#xA;    print(&amp;quot;*** Connected to host &#39;%s&#39;&amp;quot; % HOST)&#xA;    try:&#xA;        f.login()&#xA;    except ftplib.error_perm:&#xA;        print(&amp;quot;ERROR: can&#39;t login anonymously&amp;quot;)&#xA;        f.quit()&#xA;        return&#xA;    print(&amp;quot;*** Logged in as &#39;anonymous&amp;quot;)&#xA;    try:&#xA;        f.cwd(DIRN)&#xA;    except ftplib.error_perm:&#xA;        print(&amp;quot;ERROR: can&#39;t CD to &#39;%s&amp;quot; % DIRN)&#xA;        f.quit()&#xA;        return&#xA;    print(&amp;quot;*** Change to &#39;%s&#39; folder&amp;quot; % DIRN )&#xA;    try:&#xA;        f.retrbinary(&amp;quot;RETR %s&amp;quot; % FILE, open(FILE, &#39;wb&#39;).write())&#xA;    except ftplib.error_perm:&#xA;        print(&amp;quot;ERROR: can&#39;t read file &#39;%s&#39;&amp;quot; % FILE)&#xA;        os.unlink(FILE)&#xA;    else:&#xA;        print(&amp;quot;*** Download &#39;%s&#39; to CWD&amp;quot; % FILE)&#xA;        f.quit()&#xA;if __name__ == &#39;__main__&#39;:&#xA;    main()&#xA;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>SICP</title>
      <link>https://stoneepigraph.github.io/posts/sicp/</link>
      <pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/sicp/</guid>
      <description>&lt;h2 id=&#34;构造过程抽象&#34;&gt;构造过程抽象&lt;/h2&gt;&#xA;&lt;h3 id=&#34;程序设计的基本元素&#34;&gt;程序设计的基本元素&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基本表达式用于表示语言所关心的最简单的个体&lt;/li&gt;&#xA;&lt;li&gt;组合的方法通过它们可以从较简单的东西出发构造出复合的元素&lt;/li&gt;&#xA;&lt;li&gt;抽象的方法通过它们可以为复合对象命名，并将它们当作单元去操作。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;命名环境&#34;&gt;命名环境&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define variable value)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;组合式的求值&#34;&gt;组合式的求值&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;求值该组合式的各个子表达式。&lt;/li&gt;&#xA;&lt;li&gt;将作为最左子表达式的值 的那个过程应用于相应的实际参数。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;复合过程&#34;&gt;复合过程&lt;/h4&gt;&#xA;&lt;p&gt;包括：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;数和算术运算是基本的数据和过程&#xA;&lt;ol&gt;&#xA;&lt;li&gt;组合式的嵌套提供了一种组织起多个操作的方法&lt;/li&gt;&#xA;&lt;li&gt;定义是一种受限的抽象手段，它为名字关联相应的值。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;抽象过程的定义&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (funcName params) body)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;过程应用的代换模型&#34;&gt;过程应用的代换模型&lt;/h4&gt;&#xA;&lt;p&gt;为了求值一个组合式，解释器将对组合式的各个元素求值，而后将得到的那个过程应用于那些实际参数。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;应用序求值先求值参数而后应用&lt;/li&gt;&#xA;&lt;li&gt;正则序求值指“完全展开而后紧约”的求值模型&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;条件表达式和谓词&#34;&gt;条件表达式和谓词&lt;/h4&gt;&#xA;&lt;p&gt;条件表达式的一般形式&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(cond (p1 e1)&#xA;      (p2 e2)&#xA;      .&#xA;      .&#xA;      (pn en))&#xA;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>VIM</title>
      <link>https://stoneepigraph.github.io/posts/vim/</link>
      <pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/vim/</guid>
      <description>&lt;h2 id=&#34;移动光标&#34;&gt;移动光标&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;h j k l&lt;/li&gt;&#xA;&lt;li&gt;{ 移动到上一段&lt;/li&gt;&#xA;&lt;li&gt;}: 移动到下一段&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;搜索&#34;&gt;搜索&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;f加上你想在本行光标往后搜索的字母&lt;/li&gt;&#xA;&lt;li&gt;在想要搜索的word上按*&lt;/li&gt;&#xA;&lt;li&gt;/&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;移动页面&#34;&gt;移动页面&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;zz将光标所在行移动到屏幕中间&lt;/li&gt;&#xA;&lt;li&gt;zt： 将光标所在行移动到行首&lt;/li&gt;&#xA;&lt;li&gt;ab: 将光标所在行移动到行尾&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;选择&#34;&gt;选择&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;v: 进入visual 模式&lt;/li&gt;&#xA;&lt;li&gt;V: 进入visual line模式&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;操作&#34;&gt;操作&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;y: 复制选中的内容&lt;/li&gt;&#xA;&lt;li&gt;yy: 复制一整行&lt;/li&gt;&#xA;&lt;li&gt;p： 在光标后边粘贴&lt;/li&gt;&#xA;&lt;li&gt;P: 在光标前边粘贴&lt;/li&gt;&#xA;&lt;li&gt;u: 撤消上一步操作&lt;/li&gt;&#xA;&lt;li&gt;U：撤消光标落在此行后的所有修改&lt;/li&gt;&#xA;&lt;li&gt;.：重做上一步，&lt;/li&gt;&#xA;&lt;li&gt;c - r : 重作上一步, 重做上一步撤消的内容&lt;/li&gt;&#xA;&lt;li&gt;n. 重做N次上一步&lt;/li&gt;&#xA;&lt;li&gt;&amp;ldquo;ay: 将内容放到a暂存区&lt;/li&gt;&#xA;&lt;li&gt;&amp;ldquo;ap: 将a暂存区的内容粘贴到当前&lt;/li&gt;&#xA;&lt;li&gt;d： 删除选中的内容&lt;/li&gt;&#xA;&lt;li&gt;D：删除光标到行尾的内容&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;11.dd: 删除当前行内容&lt;/p&gt;</description>
    </item>
    <item>
      <title>DDIA</title>
      <link>https://stoneepigraph.github.io/posts/ddia/</link>
      <pubDate>Tue, 03 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/ddia/</guid>
      <description>&lt;h2 id=&#34;数据密集型应用设计&#34;&gt;数据密集型应用设计&lt;/h2&gt;&#xA;&lt;h3 id=&#34;数据系统基础&#34;&gt;数据系统基础&lt;/h3&gt;&#xA;&lt;h4 id=&#34;可靠-可扩展与可维护的应用系统&#34;&gt;可靠、可扩展与可维护的应用系统&lt;/h4&gt;&#xA;&lt;p&gt;对于数据密集型应用，CPU的处理能力往往不是第一限制性因素，在于数据量、数据的复杂度及数据的快速多变性。数据密集型应用通常也是基于标准模块构建而成，每个模块负责单一的常用功能。例如，许多应用系统都包含以下模块：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;数据库： 用以存储数据，这样之后应用可以再次访问&lt;/li&gt;&#xA;&lt;li&gt;调整缓存：缓存那些复杂或操作代价昂贵的结果，以加快下一次访问。&lt;/li&gt;&#xA;&lt;li&gt;索引：用户可以按安搜索数据并支持各种过滤。&lt;/li&gt;&#xA;&lt;li&gt;流式处理：持续发送消息臻另一个进程，处理采用异步方式&lt;/li&gt;&#xA;&lt;li&gt;批处理：定期处理大量的累积数据。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;可靠性&lt;/p&gt;&#xA;&lt;p&gt;当出现意外情况，如硬件、软件故障、人为失误等，系统应可以继续正常运转：虽然性能可能有所降低，但确保功能正确。对于软件,典型的可靠性期望包括:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;应用程序执行用户据期望的功能.&lt;/li&gt;&#xA;&lt;li&gt;可以容忍用户出现错误或者不正确的软件使用方法&lt;/li&gt;&#xA;&lt;li&gt;性能可以应对典型场景, 合理负载原动力和数据量&lt;/li&gt;&#xA;&lt;li&gt;系统可防止任何示经授权的访问和滥用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;硬件故障&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;软件故障&lt;/p&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;原因&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;由于软件错误&lt;/li&gt;&#xA;&lt;li&gt;一个应用进程使用了某些共享资源,但却不幸失控&lt;/li&gt;&#xA;&lt;li&gt;系统统带于某些服务,但该服务突然或无响应&lt;/li&gt;&#xA;&lt;li&gt;级联故障&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;人为失误&lt;/p&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;如果假定人是不可靠的,那么该如何保证系统的可靠性?&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;以最小出错的方式来设计系统.&lt;/li&gt;&#xA;&lt;li&gt;想办法分离最容易出错的地方,容易引发故障的接口.&lt;/li&gt;&#xA;&lt;li&gt;充分的测试&lt;/li&gt;&#xA;&lt;li&gt;当出现人为失误时,提供快速的恢复机制以尽量减少故障影响&lt;/li&gt;&#xA;&lt;li&gt;设置详细而清晰的监控子系统&lt;/li&gt;&#xA;&lt;li&gt;推行管理流程并加以培训.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可靠性的重要性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;可扩展性&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java Stream简单了解</title>
      <link>https://stoneepigraph.github.io/posts/language/java/stream/</link>
      <pubDate>Tue, 03 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/language/java/stream/</guid>
      <description>&lt;h2 id=&#34;stream&#34;&gt;Stream&lt;/h2&gt;&#xA;&lt;h3 id=&#34;stream的创建方式&#34;&gt;Stream的创建方式&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;通过Collection系列集合提供&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();&#xA;Stream&amp;lt;String&amp;gt; stream1 = list.stream();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;通过Arrays中的静态方法获取数组流&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String[] emps = new String[10];&#xA;Stream&amp;lt;String&amp;gt; stream2 = Arrays.stream(emps);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;通过Stream类中的静态方法of()&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Stream&amp;lt;String&amp;gt; stream3 = Stream.of(&amp;quot;aa&amp;quot;, &amp;quot;bb&amp;quot;, &amp;quot;cc&amp;quot;);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;创建无限流&#xA;&lt;ol&gt;&#xA;&lt;li&gt;迭代&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Stream&amp;lt;Integer&amp;gt; stream4 = Stream.iterate(0, x -&amp;gt; x + 2);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;生成&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Stream.generate(() -&amp;gt; Math.random())&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;中间操作&#34;&gt;中间操作&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;筛选与切片&#xA;&lt;ol&gt;&#xA;&lt;li&gt;filter&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;stream.filter(Predicate)&#xA;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>csapp</title>
      <link>https://stoneepigraph.github.io/posts/csapp/</link>
      <pubDate>Fri, 30 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/csapp/</guid>
      <description>&lt;h2 id=&#34;计算机系统漫游&#34;&gt;计算机系统漫游&lt;/h2&gt;&#xA;&lt;h3 id=&#34;信息就是位-plus-上下文&#34;&gt;信息就是位+上下文&lt;/h3&gt;&#xA;&lt;h3 id=&#34;程序被其他程序翻译成不同的格式&#34;&gt;程序被其他程序翻译成不同的格式&lt;/h3&gt;&#xA;&lt;p&gt;hello程序的生命周期是从一个高级C语言开始的，因为这种形式能够被人读懂。然而，为了在系统上运行hello.c程序，每条C诗句都必须被其他程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为可执行目标程序的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为可执行目标文件。&lt;/p&gt;&#xA;&lt;h3 id=&#34;了解编译系统如何工作是大有益处的&#34;&gt;了解编译系统如何工作是大有益处的&lt;/h3&gt;&#xA;&lt;h4 id=&#34;优化程序性能&#34;&gt;优化程序性能&lt;/h4&gt;&#xA;&lt;h4 id=&#34;理解链接时出现的错误&#34;&gt;理解链接时出现的错误&lt;/h4&gt;&#xA;&lt;h4 id=&#34;避免安全漏洞&#34;&gt;避免安全漏洞&lt;/h4&gt;&#xA;&lt;h3 id=&#34;处理器读并解释储存在中的指令&#34;&gt;处理器读并解释储存在中的指令&lt;/h3&gt;&#xA;&lt;h4 id=&#34;系统的硬件组成&#34;&gt;系统的硬件组成&lt;/h4&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;总线&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;I/O设备&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主存&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;处理器&lt;/p&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;加载&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;存储&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;操作&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;跳转&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;高速缓存至关重要&#34;&gt;高速缓存至关重要&lt;/h3&gt;&#xA;&lt;h3 id=&#34;存储设备形成层次结构&#34;&gt;存储设备形成层次结构&lt;/h3&gt;&#xA;&lt;p&gt;在处理器和一个较大较慢的设备（例如主存）之间插入一个更小更快的存储设备（例如高速红艳艳）的想法已经成为一个普通的观念。实际上，每个计算机系统中的存储设备都被组织成了一个存储器层次结构，在这个层次结构中， 从上至下，设备的访问速度起来越慢，容量越来越大，并且每字节的造价也越来越便宜。&lt;/p&gt;&#xA;&lt;h3 id=&#34;操作系统管理硬件&#34;&gt;操作系统管理硬件&lt;/h3&gt;&#xA;&lt;p&gt;所有应用程序对硬件的操作深度都必须通过操作系统。&lt;/p&gt;&#xA;&lt;h4 id=&#34;操作系统有两个基本功能&#34;&gt;操作系统有两个基本功能&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;防止硬件被失控的应用程序滥用&lt;/li&gt;&#xA;&lt;li&gt;向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;操作系统通过几个基本的抽象概念来实现这两个功能&#34;&gt;操作系统通过几个基本的抽象概念来实现这两个功能&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;进程&#xA;进程则是对处理器、主存和I/O设备的抽象表示。&lt;/li&gt;&#xA;&lt;li&gt;虚拟内存&#xA;虚拟内存是对主存和磁盘I/O设备的抽象表示&lt;/li&gt;&#xA;&lt;li&gt;文件&#xA;文件是对I/O设备的抽象表示&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;进程&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;线程&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;虚拟内存&lt;/p&gt;</description>
    </item>
    <item>
      <title>修管日常FQ</title>
      <link>https://stoneepigraph.github.io/posts/%E4%BF%AE%E7%AE%A1%E6%97%A5%E5%B8%B8fq/</link>
      <pubDate>Sat, 25 May 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/%E4%BF%AE%E7%AE%A1%E6%97%A5%E5%B8%B8fq/</guid>
      <description>&lt;h2 id=&#34;企业平台&#34;&gt;企业平台&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;用户名密码错误企业平台账号为备案编号去掉修备的12位数字, 忘记密码联系企业所属修管科重置密码.&lt;/li&gt;&#xA;&lt;li&gt;下载企业平台群文件有最新的企业平台安装包&lt;/li&gt;&#xA;&lt;li&gt;企业平台提示网络异常或者老版本的(参数不是字符串)&#xA;确认一下电脑的internet Explorer浏览器能不能正常访问: &lt;a href=&#34;https://weixiu.bjysgl.cn/bjvmpsf/f/&#34;&gt;https://weixiu.bjysgl.cn/bjvmpsf/f/&lt;/a&gt;&#xA;正常情况下确认一下internet Explorer浏览器能不能正常上网就可以,如果能正常上网企业平台还是提示网络有问题,那么试一下上边儿的地址.&lt;/li&gt;&#xA;&lt;li&gt;企业平台提示网络异常&#xA;&lt;ol&gt;&#xA;&lt;li&gt;确认一下是不是XP系统,企业平台已经不再支持XP系统了&lt;/li&gt;&#xA;&lt;li&gt;确认一下internet Explorer浏览器能不能正常访问: &lt;a href=&#34;https://weixiu.bjysgl.cn/bjvmpsf/f/&#34;&gt;https://weixiu.bjysgl.cn/bjvmpsf/f/&lt;/a&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;无法访问,核实一下internet选项里的TLS1.2是不是勾选了, 现在企业平台最低要求TLS1.2(所以XP系统无法正常访问了,还有部分电脑默认是没选择TLS1.2的)&lt;/li&gt;&#xA;&lt;li&gt;还无法访问,需要核实一下云服务商是不是对企业的外网IP做了封禁&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;无法上传附件核实一下internet选项里的TLS1.2是不是勾选了&lt;/li&gt;&#xA;&lt;li&gt;打印合格证的时候提示未指定的错误去QQ群文件下载最新的企业平台安装包重新安装&lt;/li&gt;&#xA;&lt;li&gt;企业找不到自己的备案编号让企业自己去这个地址&lt;a href=&#34;https://weixiu.bjysgl.cn/bjvmpsf/f/&#34;&gt;https://weixiu.bjysgl.cn/bjvmpsf/f/&lt;/a&gt;  查询备案编号&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在这个网址查询不到企业的原因？&#xA;&lt;ol&gt;&#xA;&lt;li&gt;确认企业是不是备案成功了&lt;/li&gt;&#xA;&lt;li&gt;在这个页面查询时只输入企业名称，要么一定要跟备案的企业名称一称，要么只输入确认的几个字&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;登录企业平台提示账号已锁定让企业联系所属修管科, 一般是修管科将企业列入经营地异常会导致这种情况.&lt;/li&gt;&#xA;&lt;li&gt;自动采集接口提示账号已锁定让企业去技术支持群下载最新的企业平台重新安装&lt;/li&gt;&#xA;&lt;li&gt;登录企业平台提示未绑定MAC地址让企业从技术支持群的群文件里获取获取MAC地址的工具和操作视频,获取到MAC地址后上报给企业所属的修管科&lt;/li&gt;&#xA;&lt;li&gt;企业说联系过修管科了,修管科也给绑定了MAC地址,可是还是登录不上去.&#xA;让企业发一下获取MAC地址工具结果截图, 登录企业平台露出登录账号和报错信息的截图和企业的备案编号三样东西给咱们,去系统里核对是否是绑定成功了.&lt;/li&gt;&#xA;&lt;li&gt;企业要修管科的联系方式群文件有一个叫&amp;quot;本市道路运输管理部门联系电话&amp;quot;的文档, 咱们只有修管科这一个联系方式.&lt;/li&gt;&#xA;&lt;li&gt;企业平台提示&amp;quot;下载错误,请联系管理员&amp;quot;&#xA;直接从群文件下载最新的企业平台安装包,重新安装.&lt;/li&gt;&#xA;&lt;li&gt;企业平台被杀毒软件误杀技术支持群里有&amp;quot;企业被杀毒软件误杀的解决办法&amp;quot;文档.&lt;/li&gt;&#xA;&lt;li&gt;企业录入维修纪录时无法选择维修接待员/质保员/维修人员人员是是按在职或兼职岗位在企业平台已经录入的人员列表里查询的&#xA;&lt;ol&gt;&#xA;&lt;li&gt;维修接待对应售后服务部下的维修接待员&lt;/li&gt;&#xA;&lt;li&gt;质检员对应售后服务部的质量检验员&lt;/li&gt;&#xA;&lt;li&gt;维修人员对应售后服务部下的机修技师,电气维修技师等&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;企业录入维修纪录时点击保存后一直转圈,未提示&amp;quot;保存成功&amp;quot;&#xA;这种情况有可能是网络问题,有可能是企业录入的日期不符合规范(还未修复),还有可能是维修配件里带有英文的逗号(最新版本已修复,不会再有这个问题).&lt;/li&gt;&#xA;&lt;li&gt;维修纪录提示车牌号错误这种情况有可能是特殊的车牌号或者企业录入错误,让企业提供一下行驶证,我去核对一下.&lt;/li&gt;&#xA;&lt;li&gt;维修纪录里车牌号码不能选择别的省的车牌车牌字头的下拉框是可以直接输入的.直接录入就可以.&lt;/li&gt;&#xA;&lt;li&gt;合格证无法打印让企业确认一下Internet Explorer浏览器能不能正常打印内容. 如果正常再找我们. 如果不正常就是打印机的默认设置有问题了.&lt;/li&gt;&#xA;&lt;li&gt;企业登记信息上报未通过需要重新上报您可在“综合查询-行管通知查询”，查看在最上方的&amp;quot;机动车维修经营登记信息审核结果通知书&amp;quot;，点击附件名称，下载通知书，查看审核未通过原因&lt;/li&gt;&#xA;&lt;li&gt;企业登记审核结果通知书里提示企业缺少对应的配件及人员, 企业说企业本身就没这些人员或者设备&#xA;&lt;ol&gt;&#xA;&lt;li&gt;告诉企业登记信息的核对结果是按企业的开业条件去审核的.&lt;/li&gt;&#xA;&lt;li&gt;提示质量检验员未上报驾驶证的,按企业的经营范围,给质量检验员上报驾驶证就可以了.&lt;/li&gt;&#xA;&lt;li&gt;提示人员学历或职称不达标的,给对应的人员上传对应的学历&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;企业维修设备有些设备数量无法修改无法修改的设备可以多次点&amp;quot;添加&amp;quot;按钮,添加多条&lt;/li&gt;&#xA;&lt;li&gt;企业登记信息上报时提示&amp;quot;环保措施或管理制度数据是否上报不完整&amp;quot;&#xA;确认一下管理制度里带星的是不是都上传了文件.&lt;/li&gt;&#xA;&lt;li&gt;人员录入提示人员在其他企业在职&#xA;&lt;ol&gt;&#xA;&lt;li&gt;让员工联系上家企业办理离职&lt;/li&gt;&#xA;&lt;li&gt;如果联系不到上家企业或者上家企业已经不经营了,那么联系企业所属修管科, 让修管科联系咱们办理离职&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;维修管理制度，环保制度上传格式问题&#xA;PDF, DOC,JPG,PNG&#xA;无法上传时需要修改选择文件类型&lt;/li&gt;&#xA;&lt;li&gt;企业已经录入维修接待员,可还是无法选择维修接待人员&#xA;&lt;ol&gt;&#xA;&lt;li&gt;人员是否已录入&lt;/li&gt;&#xA;&lt;li&gt;确认一下网络是否正常，首页是不是能正常获取数据，如果不能的话，确认一下网络是否正常，在internet选项里添加一下TLS1.2的支持。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;环评是否上传环评现在不要求必传,如果做过了可以上传环评结果,没做过就可以不传了.&lt;/li&gt;&#xA;&lt;li&gt;新车不需要录入环保维修项目跟环保确认过，有微信的聊天纪录。新车不会查询环保维修项目。&lt;/li&gt;&#xA;&lt;li&gt;新车有临牌的录入临牌，没有的录入京Z00000&lt;/li&gt;&#xA;&lt;li&gt;车辆的VIN码为16位怎么处理目前环检不合格的车辆是不验证车牌号和VIN的有效性的,只要关联上就行.&#xA;非环检不合格的车辆补0就可以了.&lt;/li&gt;&#xA;&lt;li&gt;企业维修职位中无洗车工怎么处理目前没有洗车式的职位，可以在售后服务部随意选一个岗位录入。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;行业管理平台-修管科-修管处&#34;&gt;行业管理平台-&amp;gt;修管科/修管处&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;企业录入了维修纪录了,可环检不合格数据还是关联成了备案企业治理未报信息&#xA;&lt;ol&gt;&#xA;&lt;li&gt;确认一下车牌号和VIN码是否一致&lt;/li&gt;&#xA;&lt;li&gt;确认一个维修纪录是否是在接收到环检不合格数据后打印的合格证,并且是在复检数据接收前.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;综合管理平台&#34;&gt;综合管理平台&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;用户名密码错误&#xA;&lt;ol&gt;&#xA;&lt;li&gt;默认用户名为企业备案编号去掉&amp;quot;修备&amp;quot;剩下的12位数字, 默认密码为WeiXiu@备案编号后门位.&lt;/li&gt;&#xA;&lt;li&gt;忘记密码联系企业所属修管科重置密码&lt;/li&gt;&#xA;&lt;li&gt;企业在本月27日到下月10日之间备案的企业是不同步的, 需要10日以后再尝试登录.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;登录提示账号锁定无操作半小时后自动解锁&lt;/li&gt;&#xA;&lt;li&gt;无法上报修管科汇总了当月/季/半年/年报后企业无法再次上报&lt;/li&gt;&#xA;&lt;li&gt;上报错误,需要打回修改修管科的联系修管处打回, 企业的联系所属修管科打回&lt;/li&gt;&#xA;&lt;li&gt;各类企业都上报哪些报表一类:月报,年报二类:季报,年报三类:半年报&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>Rust笔记</title>
      <link>https://stoneepigraph.github.io/posts/rust%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 07 Apr 2024 23:32:39 +0800</pubDate>
      <guid>https://stoneepigraph.github.io/posts/rust%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h2 id=&#34;rust基础&#34;&gt;Rust基础&lt;/h2&gt;&#xA;&lt;h3 id=&#34;数据类型&#34;&gt;数据类型&lt;/h3&gt;&#xA;&lt;h4 id=&#34;说明&#34;&gt;说明&lt;/h4&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Rust不会自动进行隐式类型转换。&lt;/p&gt;&#xA;&lt;p&gt;Rust的整数类型都实现了From&amp;lt;T&amp;gt;和Into&amp;lt;T&amp;gt;trait, 使得我们可以在它们之间进行转换。From&amp;lt;T&amp;gt;trait包含from()方法，Into&amp;lt;T&amp;gt;trait包含into()方法。类型通过实现这些trait来表达它将被如何转换为另一个类型。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;string-和-and-str&#34;&gt;String 和 &amp;amp;str&lt;/h4&gt;&#xA;&lt;p&gt;&amp;amp;str 是一个指向字符串片段的不可变引用&#xA;String是一个可变字符串缓冲区&#xA;&lt;strong&gt;对于String类型来说，应该倾向于使用&amp;amp;str,而不是&amp;amp;String.&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;String&#xA;String可以看作由三个变量所组成的结构体，第一个变量为指向一块堆上连续内存的指针，第二个变量为这块内存里已经使用的总大小。第三个变量为这块内存的总长度capacity。&#xA;String在new的时候从堆里申请内存，在drop的时候释放内存。&#xA;String内部的指向的连续内存可以看作为u8的数组，String的使用接口确保了内部存储的确实为合法的UTF-8编码的字节。&lt;/li&gt;&#xA;&lt;li&gt;&amp;amp;str&#xA;&amp;amp;str是对String的一种借用形式，被称为字符串切片。&#xA;由于&amp;amp;str的特殊性让其与普通的引用区分开，这种携带了元数据的特殊引用也被称为胖指针。&#xA;＆str非常有用，它能够引用String类型的多个不同子字符串而无需复制，避免复制。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;元组&#34;&gt;元组&lt;/h4&gt;&#xA;&lt;h4 id=&#34;数组&#34;&gt;数组&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let 变量名称:[数据类型;数组长度] = [默认值;数组长度]&#xA;let 变量名称:[数据类型;数组长度] = [数据值1,数据值2...]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;做为参数&lt;/p&gt;&#xA;&lt;p&gt;可以进行值传递也可以进行引用传递.值传递方法内的修改不会影响方法外的数据.引用传递会同步修改.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;集合&#34;&gt;集合&lt;/h4&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;分类&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;迭代器&lt;/p&gt;&#xA; &lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;分类&lt;/p&gt;</description>
    </item>
    <item>
      <title>Emacs Lisp</title>
      <link>https://stoneepigraph.github.io/posts/emacslisp/</link>
      <pubDate>Sun, 17 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/emacslisp/</guid>
      <description>&lt;h2 id=&#34;elisp&#34;&gt;ELisp&lt;/h2&gt;&#xA;&lt;h3 id=&#34;快捷键&#34;&gt;快捷键&lt;/h3&gt;&#xA;&lt;h4 id=&#34;格式化区域代码-c-m&#34;&gt;格式化区域代码： C - M - \&lt;/h4&gt;&#xA;&lt;h4 id=&#34;执行代码-c-x-c-e&#34;&gt;执行代码： C - x C - e&lt;/h4&gt;&#xA;&lt;p&gt;相当于 eval-last-sexp&lt;/p&gt;&#xA;&lt;h4 id=&#34;执行代码并将执行结果放到光标处-c-u-c-x-c-e&#34;&gt;执行代码并将执行结果放到光标处： C - u C - x C - e&lt;/h4&gt;&#xA;&lt;h4 id=&#34;查找更多信息&#34;&gt;查找更多信息&lt;/h4&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;查询函数信息： C - h f&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;查询变量信息： C - h v&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;查询快捷键信息： C - h k&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用正则表达式查询函数名： M - x apropos&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;数据类型&#34;&gt;数据类型&lt;/h3&gt;&#xA;&lt;h4 id=&#34;内建&#34;&gt;内建&lt;/h4&gt;&#xA;&lt;p&gt;内建的Emacs数据类型称为primitive types, 包括整数、浮点数、cons、符号（symbol)、字符串、向量(vector)、散列表(hash-table)、subr(内建函数， 比如cons, if, and)、byte-code function, 和其它特殊类型， 例如缓冲区(buffer)&lt;/p&gt;</description>
    </item>
    <item>
      <title>JVM简述</title>
      <link>https://stoneepigraph.github.io/posts/jvm/</link>
      <pubDate>Sun, 17 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/jvm/</guid>
      <description>&lt;h2 id=&#34;类的加载-连接与初始化&#34;&gt;类的加载,连接与初始化&lt;/h2&gt;&#xA;&lt;h3 id=&#34;加载&#34;&gt;加载&lt;/h3&gt;&#xA;&lt;p&gt;指的是将类的.class文件中的二进制数据读入到内存当中,将其放在运行时数据区的方法区内,然后在内存中创建一个java.lang.Class对象.&lt;/p&gt;&#xA;&lt;h4 id=&#34;类的加载方式&#34;&gt;类的加载方式&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;从本地系统中直接加载&lt;/li&gt;&#xA;&lt;li&gt;从网络下载.class&lt;/li&gt;&#xA;&lt;li&gt;从zip, jar等归档中加载.class文件&lt;/li&gt;&#xA;&lt;li&gt;从专有数据库中提取.class文件&lt;/li&gt;&#xA;&lt;li&gt;将Java源文件动态的编译为.class文件&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;连接&#34;&gt;连接&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;验证确保被加载的类的正确性&lt;/li&gt;&#xA;&lt;li&gt;准备为类的静态变量分配内存,并将其初始化为默认值&lt;/li&gt;&#xA;&lt;li&gt;解析把类中的符号引用转换为直接引用&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;类的使用&#34;&gt;类的使用&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;主动使用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;创建类的实例&lt;/li&gt;&#xA;&lt;li&gt;访问某个类或接口的静态变量或对静态变量赋值&lt;/li&gt;&#xA;&lt;li&gt;访问类的静态方法&lt;/li&gt;&#xA;&lt;li&gt;反射&lt;/li&gt;&#xA;&lt;li&gt;初始化一个类的子类&lt;/li&gt;&#xA;&lt;li&gt;Java虚拟机启动时被标明为启动类的类&lt;/li&gt;&#xA;&lt;li&gt;JDK1.7开始提供的动态语言支持：java.lang.invoke.MethodHandler实例的解析结果REF_getStatic, REF_PUTsTATIC, REF_invokeStatic句柄对应的类没有初始化，则初始化。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;被动使用&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;初始化&#34;&gt;初始化&lt;/h3&gt;&#xA;&lt;p&gt;所有的Java虚拟机实现必须在每个类或接口被Java程序&amp;quot;首次主动使用&amp;quot;时才进行初始化.&lt;/p&gt;&#xA;&lt;h4 id=&#34;注意&#34;&gt;注意&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;当一个常量的值并非编译期间可以确定的,那么其值就不会被放到调用类的常量池中,这时在程序运行时,会导致主动使用这个常量所在的类,显然会导致这个类被初始化.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;主动使用的方式&#34;&gt;主动使用的方式&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;创建类的实例&lt;/li&gt;&#xA;&lt;li&gt;访问某个类或接口的静态变量,或者对该静态变量赋值&lt;/li&gt;&#xA;&lt;li&gt;调用类的静态方法&lt;/li&gt;&#xA;&lt;li&gt;反射如Class.forName(&amp;ldquo;com.path.ClassName&amp;rdquo;)&lt;/li&gt;&#xA;&lt;li&gt;初始化一个类的子类&lt;/li&gt;&#xA;&lt;li&gt;Java虚拟机启动时被标明为启动类的类&lt;/li&gt;&#xA;&lt;li&gt;JDK1.7开始提供的动态语言支持.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;虚拟机参数&#34;&gt;虚拟机参数&lt;/h2&gt;&#xA;&lt;h3 id=&#34;tips&#34;&gt;Tips&lt;/h3&gt;&#xA;&lt;h3 id=&#34;说明&#34;&gt;说明&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;-XX:+&amp;lt;option&amp;gt;, 表示开启option选项&lt;/li&gt;&#xA;&lt;li&gt;-XX:-&amp;lt;option&amp;gt;, 表示关闭option选项&lt;/li&gt;&#xA;&lt;li&gt;-XX:&amp;lt;option&amp;gt;=&amp;lt;value&amp;gt;, 表示将option选项的值设置为value&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;参数&#34;&gt;参数&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&amp;ndash;XX:+TraceClassLoading: 用于追踪类的加载信息并打印出来.&lt;/li&gt;&#xA;&lt;li&gt;-Xss1M: 设置最大调用深度，防止栈举出。StackOverflowError。&lt;/li&gt;&#xA;&lt;li&gt;-XX:MaxTenuringThreshold: 指定新征伐对象经过多少次回收后进入老年代，默认为15次。&lt;/li&gt;&#xA;&lt;li&gt;-XX:PretenureSizeThreshold: 指定对象的大小超过在指定的大小之后，直接晋升老年代。&lt;/li&gt;&#xA;&lt;li&gt;TLAB&#xA;&lt;ol&gt;&#xA;&lt;li&gt;-XX:+UseTLBA: 使用TLAB, 默认开启。&lt;/li&gt;&#xA;&lt;li&gt;-XX:+TLABSize: 设置TLAB大小&lt;/li&gt;&#xA;&lt;li&gt;-XX:TLABRefillWasteFraction：设置维护进入TLAB空间的单个对象大小，他是一个比例值，默认为64,即如果对象大于整个空间的1/64,则在堆创建对象。&lt;/li&gt;&#xA;&lt;li&gt;-XX:+printTLAB：查看TLAB。&lt;/li&gt;&#xA;&lt;li&gt;-XX:ResizeTLAB: 自调整TLABRefillWasteFraction阀值。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;垃圾收集器&#xA;&lt;ol&gt;&#xA;&lt;li&gt;-XX：UseSerialGC： 使用串行垃圾回收器。&lt;/li&gt;&#xA;&lt;li&gt;-XX:+useParNewGC: 新生代使用ParNew回收器。老年代使用串行回收器。&#xA;&lt;ol&gt;&#xA;&lt;li&gt;-XX:parallelGCThreads： 指定Parnew收集器的线程数。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ParallelGC&#xA;&lt;ol&gt;&#xA;&lt;li&gt;-XX:MaxGCPauseMills: 设置最大垃圾收集停顿时间。&lt;/li&gt;&#xA;&lt;li&gt;-XX：GCTimeRatio： 设置吞量大小，它是一个0到100之间的整数，默认为100。&lt;/li&gt;&#xA;&lt;li&gt;-XX:UseAdaptiveSizePolicy: 打开自适应模式。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;CMS&#xA;&lt;ol&gt;&#xA;&lt;li&gt;-XX:+UseConcMarkSweepGC&lt;/li&gt;&#xA;&lt;li&gt;-XX:ConcGCThreads:设置并发线程数量。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;虚拟机调优策略&#34;&gt;虚拟机调优策略&lt;/h3&gt;&#xA;&lt;p&gt;JVM参数调优主要设置堆内存，主要让GC不要去频繁回收垃圾，减少对老年代的回收。配置时让-Xms与-Xmx一致。&lt;/p&gt;</description>
    </item>
    <item>
      <title>FreeMarker入门</title>
      <link>https://stoneepigraph.github.io/posts/freemarker/</link>
      <pubDate>Fri, 25 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/freemarker/</guid>
      <description>&lt;h2 id=&#34;入门&#34;&gt;入门&lt;/h2&gt;&#xA;&lt;h3 id=&#34;模板-plus-数据模型-输出&#34;&gt;模板 + 数据模型 = 输出&lt;/h3&gt;&#xA;&lt;h3 id=&#34;数据模型&#34;&gt;数据模型&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;数据模型的基本结构是树状的.&lt;/li&gt;&#xA;&lt;li&gt;标量用于存储单一的值.这种类型的值可以是字符串,数字,日期/时间或者布尔值&lt;/li&gt;&#xA;&lt;li&gt;哈希表是一种存储变量及其相关且有唯一标识名称的容器&lt;/li&gt;&#xA;&lt;li&gt;序列是存储有序变量的容器.存储的变量可以通过数字索引来检索,索引通常从0开始.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;值域&#34;&gt;值域&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;start..end: 包含结尾的值域&lt;/li&gt;&#xA;&lt;li&gt;start..&amp;lt;end或者start..!end: 不包含结尾的值域&lt;/li&gt;&#xA;&lt;li&gt;start..*length: 限定长度的值域.&lt;/li&gt;&#xA;&lt;li&gt;start..: 无右边界值域.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;注意&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;值域表达式本身没有方括号&lt;/li&gt;&#xA;&lt;li&gt;可以在..的两侧编写自述表达式而不需要圆括号&lt;/li&gt;&#xA;&lt;li&gt;.., ..&amp;lt;, ..!, ..*是去处符,所以它们中间不能有空格.&lt;/li&gt;&#xA;&lt;li&gt;无右边界值域的定义大小是2147483647&lt;/li&gt;&#xA;&lt;li&gt;值域并不存储它们包含的数字.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;哈希表&#34;&gt;哈希表&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;像连接字符串那样,也可以使用加号的方式来连接哈希表.如果两个哈希表含有键相同的项,那么在加号右侧的哈希表中的项优先.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;模板&#34;&gt;模板&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;插值: ${paramsName}&lt;/li&gt;&#xA;&lt;li&gt;FTL标签&#xA;FTL标签与HTML标签有一些相似之处,这些标签的名称以#开头, 用户自定义的FTL标签则需要使用@来代替#.&lt;/li&gt;&#xA;&lt;li&gt;注释注释使用&amp;lt;#&amp;ndash; and &amp;ndash;&amp;gt; 来标识&lt;/li&gt;&#xA;&lt;li&gt;其它任何不是FTL标签,插值或注释的内容被视为静态文本,这些东西不会被FreeMarker所解析, 会被按照原样输出来.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;基本指令&#34;&gt;基本指令&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IF指令&#xA;&lt;pre&gt;&lt;code class=&#34;language-FreeMarker&#34;&gt;&amp;lt;#if condition&amp;gt; &amp;lt;/#if&amp;gt;&#xA;&amp;lt;#if condition&amp;gt;&#xA;  if statement&#xA;&amp;lt;#elseif condition&amp;gt;&#xA;  elseif statement&#xA;&amp;lt;#else&amp;gt;&#xA;  else statement&#xA;&amp;lt;/#if&amp;gt;&#xA;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>Gitignore</title>
      <link>https://stoneepigraph.github.io/posts/git/gitignore/</link>
      <pubDate>Fri, 25 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/git/gitignore/</guid>
      <description>&lt;h2 id=&#34;规则&#34;&gt;规则&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;em&gt;mtk&lt;/em&gt; 过滤整个文件夹&lt;/li&gt;&#xA;&lt;li&gt;*.zip 过滤所有.zip文件&lt;/li&gt;&#xA;&lt;li&gt;/mtk/do.c 过滤某个具体文件&lt;/li&gt;&#xA;&lt;li&gt;!*.zip 反忽略&lt;/li&gt;&#xA;&lt;li&gt;!/mtk/one.txt反忽略&lt;/li&gt;&#xA;&lt;li&gt;*.a       # 忽略所有 .a 结尾的文件&lt;/li&gt;&#xA;&lt;li&gt;!lib.a    # 但 lib.a 除外&lt;/li&gt;&#xA;&lt;li&gt;/TODO     # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO&lt;/li&gt;&#xA;&lt;li&gt;build/    # 忽略 build/ 目录下的所有文件&lt;/li&gt;&#xA;&lt;li&gt;doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Git常用命令</title>
      <link>https://stoneepigraph.github.io/posts/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Fri, 25 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>&lt;h2 id=&#34;git常用命令&#34;&gt;Git常用命令&lt;/h2&gt;&#xA;&lt;h3 id=&#34;新建代码库&#34;&gt;新建代码库&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在当前目录新建一个Git代码库&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&amp;gt; git init&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;新建一个目录，将其初始化为Git代码库&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&amp;gt; git init [Project_name]&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;下载一个项目和它的整个代码历史&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&amp;gt; git clone [url]&lt;/p&gt;&#xA;&lt;h3 id=&#34;配置&#34;&gt;配置&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;添加指定文件到暂存区&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&amp;gt; git add [fileName] &amp;hellip;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;添加当前目录的所有的文档到暂存区&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&amp;gt; git add .&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;删除工作区文件，并且将这次删除放入暂存区&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&amp;gt; git rm [fileName] &amp;hellip;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;停止追踪指定文件，但该文件会保留在工作区&#xA;&amp;gt; git rm &amp;ndash;cached [filename]&lt;/li&gt;&#xA;&lt;li&gt;改名文件，并且将这个改名放入暂存区&#xA;&amp;gt; git mv [file-original] [file-renamed]&lt;/li&gt;&#xA;&lt;li&gt;全局配置忽略Linux与Windows回车的类型&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global core.autocrlf true&#xD;&#xA;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>maven基础</title>
      <link>https://stoneepigraph.github.io/posts/maven/</link>
      <pubDate>Fri, 25 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/maven/</guid>
      <description>&lt;h2 id=&#34;maven库&#34;&gt;Maven库：&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://repo2.maven.org/maven2/&#34;&gt;http://repo2.maven.org/maven2/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;maven依赖查询&#34;&gt;Maven依赖查询：&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://mvnrepository.com/&#34;&gt;http://mvnrepository.com/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;maven常用命令&#34;&gt;Maven常用命令：&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;创建Maven的普通java项目：&#xA;mvn archetype:create&#xA;-DgroupId=packageName&#xA;-DartifactId=projectName&lt;/li&gt;&#xA;&lt;li&gt;创建Maven的Web项目：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;​    mvn archetype:create&#xA;​    -DgroupId=packageName&#xA;​    -DartifactId=webappName&#xA;​    -DarchetypeArtifactId=maven-archetype-webapp&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;编译源代码： mvn compile&lt;/li&gt;&#xA;&lt;li&gt;编译测试代码：mvn test-compile&lt;/li&gt;&#xA;&lt;li&gt;运行测试：mvn test&lt;/li&gt;&#xA;&lt;li&gt;产生site：mvn site&lt;/li&gt;&#xA;&lt;li&gt;打包：mvn package&lt;/li&gt;&#xA;&lt;li&gt;在本地Repository中安装jar：mvn install&lt;/li&gt;&#xA;&lt;li&gt;清除产生的项目：mvn clean&lt;/li&gt;&#xA;&lt;li&gt;生成eclipse项目：mvn eclipse:eclipse&lt;/li&gt;&#xA;&lt;li&gt;生成idea项目：mvn idea:idea&lt;/li&gt;&#xA;&lt;li&gt;组合使用goal命令，如只打包不测试：mvn -Dtest package&lt;/li&gt;&#xA;&lt;li&gt;编译测试的内容：mvn test-compile&lt;/li&gt;&#xA;&lt;li&gt;只打jar包: mvn jar:jar&lt;/li&gt;&#xA;&lt;li&gt;只测试而不编译，也不测试编译：mvn test -skipping compile -skipping test-compile&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;​      ( -skipping 的灵活运用，当然也可以用于其他组合命令)&lt;/p&gt;</description>
    </item>
    <item>
      <title>SVN常用命令</title>
      <link>https://stoneepigraph.github.io/posts/svn/</link>
      <pubDate>Fri, 25 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/svn/</guid>
      <description>&lt;h2 id=&#34;常用svn命令&#34;&gt;常用SVN命令&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;svn checkout 签出,创建新的工作拷贝.&lt;/li&gt;&#xA;&lt;li&gt;svn info 搞清楚工作拷贝从哪里来的.&lt;/li&gt;&#xA;&lt;li&gt;svn update 从项目仓库中更新目录中的所有文件&lt;/li&gt;&#xA;&lt;li&gt;svn add 添加文件的目录到项目仓库中&lt;/li&gt;&#xA;&lt;li&gt;svn propset 设置文件的属性&lt;/li&gt;&#xA;&lt;li&gt;svn add 添加文件&lt;/li&gt;&#xA;&lt;li&gt;svn delete 删除文件&lt;/li&gt;&#xA;&lt;li&gt;svn move src.file dist.file 移动文件&lt;/li&gt;&#xA;&lt;li&gt;svn commit -m &amp;lsquo;提交信息&amp;rsquo;&lt;/li&gt;&#xA;&lt;li&gt;svn log filename 查看指定文件的历史&lt;/li&gt;&#xA;&lt;li&gt;svn diff 展示文件版本之间的差异.&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在版本之间找差异&#xA;svn diff -r19:21 filename&#xA;使用-r选项来指定一个版本范围&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;svn revert 删掉本地改动并使用项目仓库中的文件版本&lt;/li&gt;&#xA;&lt;li&gt;svn resolved 修正冲突后执行&lt;/li&gt;&#xA;&lt;li&gt;svn blame 显示每个文件的每一行最后的版本, 以及做出这个改动的人&lt;/li&gt;&#xA;&lt;li&gt;svn update 获取最新的代码&lt;/li&gt;&#xA;&lt;li&gt;svn merge -r 27:26 filename 移除file中版本27的改动&lt;/li&gt;&#xA;&lt;li&gt;svn lock filename 给文件加锁&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>UML</title>
      <link>https://stoneepigraph.github.io/posts/uml/</link>
      <pubDate>Fri, 25 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/uml/</guid>
      <description>&lt;h2 id=&#34;基础知识&#34;&gt;基础知识&lt;/h2&gt;&#xA;&lt;h3 id=&#34;uml图&#34;&gt;UML图&lt;/h3&gt;&#xA;&lt;h4 id=&#34;类图&#34;&gt;类图&lt;/h4&gt;&#xA;&lt;p&gt;表述系统中各个对象的类型以及其间存在的各种静态关系.类图也示明类中的特性和操作以及用于对象连接方式的约束.&lt;/p&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;聚合与组合&lt;/p&gt;&#xA;&lt;p&gt;聚合是整体-部分关系.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;可见性&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;+: 公用&lt;/li&gt;&#xA;&lt;li&gt;-: 私用&lt;/li&gt;&#xA;&lt;li&gt;~: 包&lt;/li&gt;&#xA;&lt;li&gt;#: 受护&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;顺序图&#34;&gt;顺序图&lt;/h4&gt;&#xA;&lt;p&gt;顺序图能明晰地指出参加者交互方面的区别.不擅长于示明诸如循环与条件行为等算法细节,但却能使参加者之间的调用一目了然.&#xA;当你考查单个用例内部若干对象的行为时,&lt;/p&gt;&#xA;&lt;h4 id=&#34;用例图&#34;&gt;用例图&lt;/h4&gt;&#xA;&lt;p&gt;用例通过表述系统的用户和系统本向之间特有的交互而工作,提供了如何使用系统的一种陈述.&lt;/p&gt;&#xA;&lt;h4 id=&#34;对象图&#34;&gt;对象图&lt;/h4&gt;&#xA;&lt;p&gt;是在一个时间点上系统中各个对象的一个快照.&#xA;由于对象图示明的是实例而不是类,&lt;/p&gt;&#xA;&lt;h4 id=&#34;包图&#34;&gt;包图&lt;/h4&gt;&#xA;&lt;p&gt;在UML中用双冒号表示包名.&#xA;对大型系统要了解系统主要成分之间的依赖时,使用包图.&#xA;包图表示一种编译时刻的聚组机制.关于示明在运行时刻如何来组合各个对象.&lt;/p&gt;&#xA;&lt;h4 id=&#34;部署图&#34;&gt;部署图&lt;/h4&gt;&#xA;&lt;p&gt;通过揭示&amp;quot;哪些软件片段运行于哪些硬件片段上&amp;quot;来示明系统的一个物理布局.&#xA;任何复杂的部署都可以很好地使用部署图.&lt;/p&gt;&#xA;&lt;h4 id=&#34;活动图&#34;&gt;活动图&lt;/h4&gt;&#xA;&lt;p&gt;活动图可以示明组织机构的工作流,示明软件与人的活动如何交互.活动图还可以示明用例的环境发及复杂用例如何工作的细节.&#xA;考查跨用例或跨线程的行为,就考虑活动图.&#xA;活动图是一种表述过程基理,业务过程以及工作流的技术.&lt;/p&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;分划&lt;/p&gt;&#xA;&lt;p&gt;分划示明一个类或一个机构单位施行哪些动作.&lt;/p&gt;</description>
    </item>
    <item>
      <title>代码之外的生存指南</title>
      <link>https://stoneepigraph.github.io/posts/%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%E7%9A%84%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97/</link>
      <pubDate>Fri, 25 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%E7%9A%84%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97/</guid>
      <description>&lt;h3 id=&#34;为何这本书与你先前读过的任何书籍都迥然不同&#34;&gt;为何这本书与你先前读过的任何书籍都迥然不同&lt;/h3&gt;&#xA;&lt;p&gt;讲述如何成为一名优秀的软件开发人员的书，优秀开发人员指的是那些能够把控自己的职业生涯，达成目标，享受生活的人。本书并不再讨论你能做什么，而是讨论你自己。关乎你的职业生涯，你的生活，你的身体，你的思想及你的灵魂。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;职业生涯：学习如何主动管理自己的职业生涯，从而达到自己追寻的结果。&lt;/li&gt;&#xA;&lt;li&gt;自我营销：学习如何推销自己。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如何打造个人品牌，如何打造一个成功的博客，如何通过演讲，教学，著书立说的方式让你扬名立万。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;学习：学习如何学习，学习如何自觉&lt;/li&gt;&#xA;&lt;li&gt;生产力：关于如何让工作更加富有成效的&lt;/li&gt;&#xA;&lt;li&gt;理财：学习如何有效地管理你赚到的财。&lt;/li&gt;&#xA;&lt;li&gt;健身：&lt;/li&gt;&#xA;&lt;li&gt;精神：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;职业&#34;&gt;职业&lt;/h2&gt;&#xA;&lt;p&gt;你所能犯的最大错误就是相信自己是在为别人工作。这样一来你对工作的安全感已然尽失。职业发展的驱动力一定是来自个体本身。记住：工作是属于公司的，而职业生涯却是属于你自己的。体验决策过程：你要决定自己想要从软件开发这个职业中获得什么，以及如何去获得。&lt;/p&gt;&#xA;&lt;h3 id=&#34;从非同凡响开始-绝不要做其他人都在做的事&#34;&gt;从非同凡响开始：绝不要做其他人都在做的事&lt;/h3&gt;&#xA;&lt;h4 id=&#34;拥有商业心态&#34;&gt;拥有商业心态&lt;/h4&gt;&#xA;&lt;p&gt;因为只有你开始把自己当作一个企业去思考时，你才能开始做出良好的商业决策。尽管在你的职业生涯的某个特定时间段里，你可能确实是在为某家公司打工，但是千万不要让那个特定的角色固化了你和你的整个职业生涯。我们需要把雇主当作是自己的软件开发企业的一个客户。&lt;/p&gt;&#xA;&lt;h4 id=&#34;如何像企业一样思考&#34;&gt;如何像企业一样思考&lt;/h4&gt;&#xA;&lt;p&gt;理解企业的构成：首先，要有一个产品或服务，我的产品是什么？通常软件开发人员售卖的就是他们把一个想法变成一个数字化的现实产品的能力。作为一名软件开发人员，你提供的服务具备有形价值，你要传达的不仅是这款软件的价值是什么，还有它与别的成千上万款软件开发人员提供的服务有什么不同。同时，你需要认识到仅有服务或产品是不够的。想要赚钱，你就必须能让潜在的客户了解该产品或服务。所以我需要做到：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;专注于你正在提供怎样的服务，以及如何营销这项服务。&lt;/li&gt;&#xA;&lt;li&gt;想方设法提升你的服务&lt;/li&gt;&#xA;&lt;li&gt;思考你可以专注为哪一特定类型的客户或行业提供特定的服务&lt;/li&gt;&#xA;&lt;li&gt;集中精力成为一位专家，专门为某一特定类型的客户提供专业的整体服务（记住，作为一个软件开发人员，你只有真正专注于一类客户，才能找到非常好的工作）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;另外，还要想想如何更好地宣传你的服务，如何更好地找到你的客户。&lt;/p&gt;&#xA;&lt;h3 id=&#34;思考未来-你的目标是什么&#34;&gt;思考未来：你的目标是什么&lt;/h3&gt;&#xA;&lt;p&gt;定义你的业务目标要实现任何目标，都必须先知道目标是什么。&lt;/p&gt;&#xA;&lt;h4 id=&#34;如何设定目标&#34;&gt;如何设定目标&lt;/h4&gt;&#xA;&lt;p&gt;起步阶段最简单的就是在心中树立一个大目标，然后再建立能帮你达成这个大目标的小目标。因为很难清晰地界定远期可能发生的事情，所以大目标通常不是非常明确。不过大目标不一定要非常具体。只要目标能具体到给你提供清晰的方向即可。花点儿时间思考一下你的大目标，你希望从职业生涯中收获什么？你希望自己5年或10年之后在哪里？——这非常重要。一旦你想通了自己长远的大目标是什么，下一步注是设定路线，制订通往大目标的小目标。有时还可以运用一下逆向思维，反推一下如何从大目标到当前的情况。如果你可以驱动小目标逐渐前行并靠近你的大目标，那么你最终一定会达到目的地。&lt;/p&gt;&#xA;&lt;h4 id=&#34;追踪你的目标&#34;&gt;追踪你的目标&lt;/h4&gt;&#xA;&lt;p&gt;你应该定期追踪并更新自己设定的目标，必要时还要调整。建议你定期核对自己的目标，这有助于在必要时进行调整，让你对自己负责。反思自己在短期和长期取得的成果是大有裨益的，你能够弄清自己是否取得了合理的进展，或者是否需要进行某些调整。&lt;/p&gt;&#xA;&lt;h3 id=&#34;人际交往能力-远比你想象的重要&#34;&gt;人际交往能力：远比你想象的重要&lt;/h3&gt;&#xA;&lt;h4 id=&#34;别管我-我只想一个人安静地写代码&#34;&gt;别管我，我只想一个人安静地写代码&lt;/h4&gt;&#xA;&lt;p&gt;我曾经对软件开发人员的工作的印象就是写代码。事实上，在软件开发领域，我们大多数时候是与人而非与计算机打交道。甚至我们所写的代码首先是供人使用的，其次才是让计算机可以理解。&lt;/p&gt;&#xA;&lt;h4 id=&#34;学会如何与人打交道&#34;&gt;学会如何与人打交道&lt;/h4&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;每个人都希望感觉自己很重要&lt;/p&gt;&#xA;&lt;p&gt;当你和别人打交道的时候，你应该知道 的最重要的一个概念就是：以自己为核心，每个人都希望自己很重要。这是人类最深邃，最致命的欲望之一，也是社会和生活中取得伟大成就的主要动机。我们常常容易犯的一个错误就是，轻率地否决同事的想法，以便于可以提出自己的想法。然而承着你作出这样的错误判断，你往往会发现他们对你的想法充耳不闻，仅仅因为你让他们感觉自己是无足轻重的。如果你希望人们接受你的想法，并认可其中的价值，首先你最好先主动给他人相同的礼遇。如果你不能保全他人的自尊，那你永远也不可能赢得他的心。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;永远不要批评&lt;/p&gt;</description>
    </item>
    <item>
      <title>学习</title>
      <link>https://stoneepigraph.github.io/posts/study/</link>
      <pubDate>Fri, 25 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/study/</guid>
      <description>&lt;h2 id=&#34;提问&#34;&gt;提问&lt;/h2&gt;&#xA;&lt;h3 id=&#34;提问的智慧&#34;&gt;提问的智慧&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;提问的智慧&lt;a href=&#34;http://www.catb.org/~esr/faqs/smart-questions.html&#34;&gt;http://www.catb.org/~esr/faqs/smart-questions.html&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;提问的智慧&lt;a href=&#34;https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md&#34;&gt;https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;学习新技术的逻辑&#34;&gt;学习新技术的逻辑&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;这个技术出现的背景、初衷和要达到什么样的目标或是要解决什么样的问题。这个问题非常关键，也就是说，你在学习一个技术的时候，需要知道这个技术的成因和目标，也就是这个技术的灵魂。如果不知道这些的话，那么你会看不懂这个技术的一些设计理念。&lt;/li&gt;&#xA;&lt;li&gt;这个技术的优势和劣势分别是什么，或者说，这个技术的 trade-off 是什么。任何技术都有其好坏，在解决一个问题的时候，也会带来新的问题。另外，一般来说，任何设计都有 trade-off（要什么和不要什么），所以，你要清楚这个技术的优势和劣势，以及带来的挑战。&lt;/li&gt;&#xA;&lt;li&gt;这个技术适用的场景。任何技术都有其适用的场景，离开了这个场景，这个技术可能会有很多槽点，所以学习技术不但要知道这个技术是什么，还要知道其适用的场景。没有任何一个技术是普适的。注意，所谓场景一般分别两个，一个是业务场景，一个是技术场景。&lt;/li&gt;&#xA;&lt;li&gt;技术的组成部分和关键点。这是技术的核心思想和核心组件了，也是这个技术的灵魂所在了。学习技术的核心部分是快速掌握的关键。&lt;/li&gt;&#xA;&lt;li&gt;技术的底层原理和关键实现。任何一个技术都有其底层的关键基础技术，这些关键技术很有可能也是其它技术的关键基础技术。所以，学习这些关键的基础底层技术，可以让你未来很快地掌握其它技术。可以参看我在 CoolShell 上写的 Docker 底层技术那一系列文章。&lt;/li&gt;&#xA;&lt;li&gt;已有的实现和它之间的对比。一般来说，任何一个技术都会有不同的实现，不同的实现都会有不同的侧重。学习不同的实现，可以让你得到不同的想法和思路，对于开阔思维，深入细节是非常重要的。&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>精通Git(2)</title>
      <link>https://stoneepigraph.github.io/posts/git/readnote/%E7%B2%BE%E9%80%9Agit_22/</link>
      <pubDate>Fri, 25 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/git/readnote/%E7%B2%BE%E9%80%9Agit_22/</guid>
      <description>&lt;h2 id=&#34;精通git&#34;&gt;精通Git&lt;/h2&gt;&#xA;&lt;h3 id=&#34;git基础&#34;&gt;Git基础&lt;/h3&gt;&#xA;&lt;h4 id=&#34;获取git仓库&#34;&gt;获取Git仓库&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git init&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;记录每次更新到仓库&#34;&gt;记录每次更新到仓库&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git add .&#xA;git commit -m &#39;commit mesg&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;查询提交历史&#34;&gt;查询提交历史&lt;/h4&gt;&#xA;&lt;p&gt;#+END_SRC&#xA;git log&#xA;#+END_SRC&lt;/p&gt;&#xA;&lt;h4 id=&#34;撤消操作&#34;&gt;撤消操作&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git commit --amend&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;这个命令会将暂存区中的文件提交，如果自上次提交以来你还未做任何修改，那么快照会保持不变，而你所修改的只是提交信息。&#xA;e.g.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git commit -m &#39;initial commit&#39;&#xA;git add ofrgotten_file&#xA;git commit --amend&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;最终你只会有一个提交 - 第二冷饮提交将代替第一次提交的结果。&lt;/p&gt;&#xA;&lt;!--list-separator--&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;取消暂存的文件&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git reset HEAD&#xA;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>重构2</title>
      <link>https://stoneepigraph.github.io/posts/%E9%87%8D%E6%9E%842/</link>
      <pubDate>Fri, 25 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/%E9%87%8D%E6%9E%842/</guid>
      <description>&lt;h2 id=&#34;开始&#34;&gt;开始&lt;/h2&gt;&#xA;&lt;p&gt;本章重构：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将原函数分解成一组嵌套的函数&lt;/li&gt;&#xA;&lt;li&gt;分离计算逻辑与输出格式化逻辑&lt;/li&gt;&#xA;&lt;li&gt;为计算器引入多态性来处理计算逻辑&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;好的代码的检验标准就是人们是否能构轻易地修改它注： 小步累积&lt;/p&gt;&#xA;&lt;h2 id=&#34;重构的原则&#34;&gt;重构的原则&lt;/h2&gt;&#xA;&lt;h3 id=&#34;何谓重构&#34;&gt;何谓重构&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;名: 对软件内部结构的一种调整,目的是在不改变软件可观察行为的前提下,提高其可理解性,降低其修改成本.&lt;/li&gt;&#xA;&lt;li&gt;动: 使用一系列重构手法,在不改变软件可观察行为的前提下,高速其结构.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;重构时不添加新功能-添加新功能时不重构-dot&#34;&gt;重构时不添加新功能,添加新功能时不重构.&lt;/h3&gt;&#xA;&lt;h3 id=&#34;为何重构&#34;&gt;为何重构&lt;/h3&gt;&#xA;&lt;h4 id=&#34;改进软件的设计&#34;&gt;改进软件的设计&lt;/h4&gt;&#xA;&lt;h4 id=&#34;使软件更容易理解&#34;&gt;使软件更容易理解&lt;/h4&gt;&#xA;&lt;h4 id=&#34;帮助找到bug&#34;&gt;帮助找到BUG&lt;/h4&gt;&#xA;&lt;h4 id=&#34;提高编程速度&#34;&gt;提高编程速度&lt;/h4&gt;&#xA;&lt;h3 id=&#34;何时重构&#34;&gt;何时重构&lt;/h3&gt;&#xA;&lt;p&gt;事不过三, 三则重构&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;预备性重构: 在添加新功能之前进行重构&lt;/li&gt;&#xA;&lt;li&gt;帮助理解的重构:&lt;/li&gt;&#xA;&lt;li&gt;捡垃圾式重构:&#xA;不想从眼下正要完成的代码上跑题太多,但也不想把垃圾留在原地.所以在重构可以很快完成时就立即重构,如果需要花一些精力,可以做一个TODO.至少要让营地比你到达时干净.&lt;/li&gt;&#xA;&lt;li&gt;有计划的重构和见机行事的重构每次修改时,首先令修改很容易,然后再进行这次容易的修改.&lt;/li&gt;&#xA;&lt;li&gt;长期重构如果想替换掉一个正在使用的库,需要很长时间,可以先引入一层新的抽象,使其兼容新旧的两个库的接口.一旦调用方已经完全为使用这层抽象,替换掉下面的库就会容易很多.&lt;/li&gt;&#xA;&lt;li&gt;重审代码时重构&lt;/li&gt;&#xA;&lt;li&gt;何是不应该重构&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果我看见一块凌乱的代码,但并不需要修改它,那么我就不需要重构它.&lt;/li&gt;&#xA;&lt;li&gt;如果丑陋的代码能被隐藏在一个API之下,我就可以容忍它继续保持丑陋.&lt;/li&gt;&#xA;&lt;li&gt;如果重写比重构还容易,就别重构了.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;重构的挑战&#34;&gt;重构的挑战&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;延缓新功能开发&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;代码的坏味道&#34;&gt;代码的坏味道&lt;/h2&gt;&#xA;&lt;h3 id=&#34;神秘命名&#34;&gt;神秘命名&lt;/h3&gt;&#xA;&lt;h3 id=&#34;重复代码&#34;&gt;重复代码&lt;/h3&gt;&#xA;&lt;h3 id=&#34;过长函数&#34;&gt;过长函数&lt;/h3&gt;&#xA;&lt;p&gt;现代编程语言几乎已经完全免除了进程内的函数调用开销.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Jenkins入门</title>
      <link>https://stoneepigraph.github.io/posts/jenkins%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/jenkins%E5%85%A5%E9%97%A8/</guid>
      <description>&lt;h2 id=&#34;gitlab配置&#34;&gt;gitlab配置&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;wget &amp;ndash;content-disposition &lt;a href=&#34;https://packages.gitlab.com/gitlab/gitlab-ce/packages/el/7/gitlab-ce-13.2.4-ce.0.el7.x86_64.rpm/download.rpm&#34;&gt;https://packages.gitlab.com/gitlab/gitlab-ce/packages/el/7/gitlab-ce-13.2.4-ce.0.el7.x86_64.rpm/download.rpm&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;安装信赖&#xA;&lt;ol&gt;&#xA;&lt;li&gt;yum install curl openssh-server postfix cronie&lt;/li&gt;&#xA;&lt;li&gt;yum -y install policycoreutils-python&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;rpm -ivh gitlab-ce&lt;/li&gt;&#xA;&lt;li&gt;config gitlab&#xA;&lt;ol&gt;&#xA;&lt;li&gt;vi /etc/gitlab/gitlab.rb&#xA;external_url:&#xA;nginx[&amp;rsquo;listen_port&#39;]&lt;/li&gt;&#xA;&lt;li&gt;gitlab-ctl reconfigure&lt;/li&gt;&#xA;&lt;li&gt;gitlab-ctl restart&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;配置防火墙&lt;/li&gt;&#xA;&lt;li&gt;配置gitlab组及用户&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;jenkins安装&#34;&gt;jenkins安装&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;安装Jenkins跳过插件安装&lt;/li&gt;&#xA;&lt;li&gt;jenkins插件安装&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;tips&#34;&gt;tips&lt;/h2&gt;&#xA;&lt;h3 id=&#34;三台服务器-一台gitlab-一台jenkins-一台测试服务器&#34;&gt;三台服务器,一台gitlab, 一台Jenkins, 一台测试服务器&lt;/h3&gt;</description>
    </item>
    <item>
      <title>MyBatis基础</title>
      <link>https://stoneepigraph.github.io/posts/mybatis%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/mybatis%E5%9F%BA%E7%A1%80/</guid>
      <description>&lt;h2 id=&#34;入门&#34;&gt;入门&lt;/h2&gt;&#xA;&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Jar包安装&lt;/li&gt;&#xA;&lt;li&gt;Maven导入&lt;/li&gt;&#xA;&lt;li&gt;Gradle导入&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;从xml中构建sqlsessionfactory&#34;&gt;从XML中构建SqlSessionFactory&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String resource = &amp;quot;org/mybatis/example/mybatis-config.xml&amp;quot;;&#xA;InputStream inputStream = Resources.getResourceAsStream(resource);&#xA;SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;XML配置&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;&#xA;&amp;lt;!DOCTYPE configuration&#xA;  PUBLIC &amp;quot;-//mybatis.org//DTD Config 3.0//EN&amp;quot;&#xA;  &amp;quot;http://mybatis.org/dtd/mybatis-3-config.dtd&amp;quot;&amp;gt;&#xA;&amp;lt;configuration&amp;gt;&#xA;  &amp;lt;environments default=&amp;quot;development&amp;quot;&amp;gt;&#xA;    &amp;lt;environment id=&amp;quot;development&amp;quot;&amp;gt;&#xA;      &amp;lt;transactionManager type=&amp;quot;JDBC&amp;quot;/&amp;gt;&#xA;      &amp;lt;dataSource type=&amp;quot;POOLED&amp;quot;&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;driver&amp;quot; value=&amp;quot;${driver}&amp;quot;/&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;${url}&amp;quot;/&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;${username}&amp;quot;/&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${password}&amp;quot;/&amp;gt;&#xA;      &amp;lt;/dataSource&amp;gt;&#xA;    &amp;lt;/environment&amp;gt;&#xA;  &amp;lt;/environments&amp;gt;&#xA;  &amp;lt;mappers&amp;gt;&#xA;    &amp;lt;mapper resource=&amp;quot;org/mybatis/example/BlogMapper.xml&amp;quot;/&amp;gt;&#xA;  &amp;lt;/mappers&amp;gt;&#xA;&amp;lt;/configuration&amp;gt;&#xA;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>Oracle一些简单查询</title>
      <link>https://stoneepigraph.github.io/posts/oracle%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/oracle%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2/</guid>
      <description>&lt;h2 id=&#34;oracle一些基本查询&#34;&gt;Oracle一些基本查询&lt;/h2&gt;&#xA;&lt;h4 id=&#34;字符集相关&#34;&gt;字符集相关&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;查询数据库字符集&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select userenv(&#39;language&#39;) from dual;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;实例相关&#34;&gt;实例相关&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;查询实例名&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select instance_name from v$instance;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;锁相关&#34;&gt;锁相关&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;查看被锁的表&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select b.username,b.sid,b.serial#,logon_time from v$locked_object a,v$session b where a.session_id = b.sid order by b.logon_time;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;杀死锁进程&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;alter system kill session &#39;id,serial*&#39;;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;查询表之前的状态&#34;&gt;查询表之前的状态&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from tablename AS OF TIMESTAMP (SYSTIMESTAMP - INTERVAL &#39;50&#39; MINUTE)&#xA;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>postgresql-note</title>
      <link>https://stoneepigraph.github.io/posts/postgresql%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/postgresql%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h2 id=&#34;安装及配置&#34;&gt;安装及配置&lt;/h2&gt;&#xA;&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;下载postgresql   &lt;a href=&#34;https://www.postgresql.org/download/&#34;&gt;https://www.postgresql.org/download/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;安装 按照官网的说明安装&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;su - postgres -c &amp;quot;pg_ctl -D /var/lib/postgres/data -l /var/log/postgresql/postgresql.log start&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;切换到postgres用户修改postgres密码&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;!--listend--&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;su - postres&#xA;alter user postgres with password &#39;passwod&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;备份及恢复&#34;&gt;备份及恢复&lt;/h2&gt;&#xA;&lt;h3 id=&#34;备份&#34;&gt;备份&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pg_dump dbname &amp;gt; dbname.bak   # 备份单个数据库&#xA;pg_dumpall &amp;gt; pd_backup.bak    # 备份所有的数据库&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;备份格式有三种， 可以使用-F指定&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;*.bak 压缩二进制文件&lt;/li&gt;&#xA;&lt;li&gt;*.sql 明文转储&lt;/li&gt;&#xA;&lt;li&gt;*.tar tarball  t&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;恢复&#34;&gt;恢复&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;psql dbname &amp;lt; dbanme.bak&#xA;pg_restore -U postgres -d dbname /tmp/back_filename.tar&#xA;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>用Python写网络爬虫</title>
      <link>https://stoneepigraph.github.io/posts/%E7%94%A8python%E5%86%99%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/%E7%94%A8python%E5%86%99%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/</guid>
      <description>&lt;h2 id=&#34;网络爬虫简介&#34;&gt;网络爬虫简介&lt;/h2&gt;&#xA;&lt;h3 id=&#34;识别网站所用技术builtwith模块&#34;&gt;识别网站所用技术&amp;mdash;&amp;mdash;builtwith模块&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;pip install builtwith&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import builtwith&#xA;builtwith.parse(&amp;quot;sample.website.com&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;寻找网站的所有者&#34;&gt;寻找网站的所有者&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;pip install python-whois&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import whois&#xA;print(whois.whois(&#39;sample.website.com&#39;))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;编写第一个网络爬虫&#34;&gt;编写第一个网络爬虫&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;3种爬取网站的常见方法：&lt;/em&gt;&lt;/strong&gt; - 爬取网站地图 - 遍历每个网页的数据库ID -&#xA;跟踪网页链接&lt;/p&gt;&#xA;&lt;h4 id=&#34;下载网页&#34;&gt;下载网页&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import urllib2&#xA;def download(url):&#xA;    print(&#39;Downloading。。。&#39;, url)&#xA;    try:&#xA;        html = urllib2.urlopen(url).read()&#xA;    except urllib2.URLError e:&#xA;        print(&amp;quot;Download error:&amp;quot;, e.reason)&#xA;        html = None&#xA;    return html&#xA;&lt;/code&gt;&lt;/pr</description>
    </item>
  </channel>
</rss>
