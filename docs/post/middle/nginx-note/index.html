<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="generator" content="Hugo 0.68.3" />

  <title>Nginx基础 &middot; Stone Minder</title>

    

  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/pure-min.css">

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-old-ie-min.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-min.css">
  <!--<![endif]-->

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="/css/side-menu-old-ie.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="/css/side-menu.css">
  <!--<![endif]-->

  <link rel="stylesheet" href="/css/blackburn.css">

  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css">

  
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Raleway&display=swap" rel="stylesheet" type="text/css">

  
  <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

 
  

  

  <link rel="shortcut icon" href="https://stoneepigraph.github.io/img/favicon.ico" type="image/x-icon" />

  
  

</head>


<body>
<div id="layout">

  
<a href="#menu" id="menuLink" class="menu-link">
  
  <span></span>
</a>
<div id="menu">

  

  <div class="pure-menu">
    <ul class="pure-menu-list">
      
    </ul>
  </div>

  <div class="pure-menu social">
  <ul class="pure-menu-list">

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

  </ul>
</div>


  <div>
  <div class="small-print">
    <small></small>
  </div>
  <div class="small-print">
    <small>Built with&nbsp;<a href="https://gohugo.io/" target="_blank">Hugo</a></small>
    <small>Theme&nbsp;<a href="https://github.com/yoshiharuyamashita/blackburn" target="_blank">Blackburn</a></small>
  </div>
</div>

</div>


  <div id="main">


<div class="header">
  <h1>Nginx基础</h1>
  <h2></h2>
</div>
<div class="content">

  <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>13 Sep 2021, 00:00</time>
  </div>

  

  

  

</div>

  
<h2 id="headline-1">
Nginx基础
</h2>
<h3 id="headline-2">
Nginx架构
</h3>
<h4 id="headline-3">
nginx事件模型
</h4>
<h5 id="headline-4">
nginx是采用的异步非阻塞。
</h5>
<p>
拿epoll为例，当事件没准备好时，放到epoll里，事件准备好了，我们就去读写，当读写返回EAGAIN时，我们将它再次加入到epoll里。这样，只要有事件准备好了，我们就去处理它，只有当所有事件都没准备好时，才在epoll里等着。这样我们就可以并发处理大量的并发了，当然，这里的并发请求，是指未处理完的请求，线程只有一个，所以同时能处理的请求当然只有一个，只是在请求间进行不断切换而已，切换也是因为异步事件未准备好，而主动让出的。这里的切换是没有任何代价的，你可以理解为循环处理多个准备好的事件，事实上就是这样的。与多线程相比，这事事件处理方式是有很大的优势的，不需要创建线程，每个请求占用的内存也很少，没有上下文切换，事件处理非常轻量级。并发数再多也不会导致无谓的资源浪费（上下文切换）。更多的并发数，只是会占用更多的内存而已。
</p>
<h5 id="headline-5">
Nginx的worker数最好设置为CPU的核数。
</h5>
<h4 id="headline-6">
Nginx基本概念
</h4>
<h5 id="headline-7">
connection
</h5>
<p>
在Nginx中connection就是对tcp连接的封闭，其中包括连接的socket, 读事件，写事件。利用Nginx封闭的Connection，我们可以很方便的使用Nginx来处理与连接相关的事情，比如，建立连接，发送与接受数据等。
     而Nginx中的http请求的处理就是建立在Connection之上的，所以Nginx不公可以作为一个web服务器， 也可以作为邮件服务器。当然，利用Nginx提供的Connection,我们可以与任何后端服务打交道。
</p>
<h6 id="headline-8">
Nginx处理连接的流程
</h6>
<p>
首先Nginx在启动时，会解析配置文件，得到需要监听的端口与IP地址，然后在Nginx的master进程里面，先初始化好这个监控的socket（创建Socket， 设置Addrreuse等选项，绑定到指定的IP地址端口，再Listen），然后再fork出多个子进程出来，然后子进程会竞争accept新的连接。此时，客户端就可以向Nginx发起连接了。当客户端与服务端通过三次握手建立好一个连接后，Nginx的某一个子进程会Accept成功，得到这个建立好的连接的Socket，然后创建Nginx对连接的封闭，即ngx_connection_t结构体。接着，设置读写事件处理函数并添加读写事件来与客户端进行数据的交换。最后，Nginx或客户端主动关掉连接，到此，一个连接就结束了。
      Nginx在实现时，是通过一个连接池来管理的，这里的连接池里保存的其实不是真实的连接，它只是一个worker_connections(不大于系统对fd的限制)大小的ngx_connection_t结构体的数组。并且，Nginx会通过一个链表free_connections来保存所有的空闲ngx_connection_t，每次获取一个连接时，就从空闲连接链表里获取一个，用完后，再放回空间连接链表里。
</p>
<h5 id="headline-9">
request
</h5>
<p>
在Ningx中request我们指的是http请求，具体到Nginx中的数据结构是ngx_http_request_t。它是对一个Http请求的封装。
</p>
<h3 id="headline-10">
指令
</h3>
<h4 id="headline-11">
server
</h4>
<p>
用于定义服务，http中可以有多个server块
</p>
<h4 id="headline-12">
listen
</h4>
<p>
指定服务器侦听请求的IP地址和端口，如果省略地址，服务器将侦听所有地址，如果省略端口，则使用标准端口
</p>
<h4 id="headline-13">
server_name
</h4>
<p>
服务名称，用于配置域名
</p>
<h4 id="headline-14">
location
</h4>
<p>
用于配置映射路径uri对应的配置，一个server中可以有多个location, location后面跟一个uri,可以是一个正则表达式，/表示匹配任意路径，当客户端访问的路径满足这个uri时就会执行location块里的代码
</p>
<h5 id="headline-15">
修饰符
</h5>
<ol>
<li>
<p>
= 进行普通字符精确匹配。也就是完全匹配
</p>
</li>
<li>
<p>
^~ 前缀匹配。如果匹配成功，则不再匹配其他location.
</p>
</li>
<li>
<p>
~ 表示执行一个正则匹配，区分大小写 
</p>
</li>
<li>
<p>
~* 表示执行一个正则匹配，不区分大小写
</p>
</li>
<li>
<p>
<em>xxx</em> 常规字符串路径匹配
</p>
</li>
<li>
<p>
/ 通用匹配， 任何请求都会匹配到
</p>
</li>
</ol>
<h5 id="headline-16">
检查顺序
</h5>
<p>
location = &gt; location 完整路径 &gt; location ^~ &gt; location ~, ~* &gt; location 部分起始路径 &gt; /
     注意： location的优先级与location配置的位置无关
</p>
<h5 id="headline-17">
正则表达式
</h5>
<ol>
<li>
<p>
.: 匹配除换行符以外的任意字符
</p>
</li>
<li>
<p>
?: 重复0次或1次
</p>
</li>
<li>
<p>
?+: 重复1次或更多次
</p>
</li>
<li>
<ul>
<li>
<pre class="example">
重复0次或更多次
</pre>
</li>
</ul>
</li>
<li>
<p>
\d: 匹配数字
</p>
</li>
<li>
<p>
^: 匹配字符串的开始
</p>
</li>
<li>
<p>
$: 匹配字符串的结束
</p>
</li>
<li>
<p>
{n}: 重复n次
</p>
</li>
<li>
<p>
{n,}: 重复n次或更多次
</p>
</li>
<li>
<p>
[c]: 匹配单个字符c
</p>
</li>
<li>
<p>
[a-z]: 匹配a-z小写字母的任意一个
</p>
</li>
<li>
<p>
(a|b|c): 竖线表示匹配任意一种情况，每种情况使用竖线分隔，一般使用小括号括住，匹配符合a字符或b字符或是c字符的字符串
</p>
</li>
</ol>
<p>
小括号()之间匹配的内容，可以在后面通过$1来引用，$2表示的是前面第二个()里的内容。
</p>
<ol>
<li>
<p>
\: 用于转义特殊字符
</p>
</li>
</ol>
<h4 id="headline-18">
root
</h4>
<p>
root指令用于设置请求的根目录，从而允许Nginx将传入的请求映射到文件系统上。
</p>
<div class="src src-nginx">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nginx" data-lang="nginx">  <span style="color:#66d9ef">server</span> {
  <span style="color:#f92672">listen</span> <span style="color:#ae81ff">80</span>;
  <span style="color:#f92672">server_name</span> <span style="color:#e6db74">stonemind.cn</span>;
  <span style="color:#f92672">root</span> <span style="color:#e6db74">/var/www/html</span>;
  }</code></pre></div>
</div>
<h4 id="headline-19">
index
</h4>
<p>
设置首页， 当只访问server_name时后面不跟任何路径是不走直接走index指令的。如果访问路径中没有指定具体的文件，则返回index设置的资源。
</p>
<h4 id="headline-20">
set
</h4>
<p>
自定义变量
</p>
<div class="src src-nginx">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nginx" data-lang="nginx"><span style="color:#66d9ef">set</span> $doc_root <span style="color:#e6db74">/usr/local/var/www</span>;</code></pre></div>
</div>
<h4 id="headline-21">
proxy_pass
</h4>
<h5 id="headline-22">
反向代理（Reverse Proxy)
</h5>
<p>
反向代理方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。反向代理使用proxy_pass指令来实现。
</p>
<div class="src src-nginx">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nginx" data-lang="nginx">  <span style="color:#66d9ef">server</span> {
  <span style="color:#f92672">listen</span> <span style="color:#ae81ff">80</span>;
  <span style="color:#f92672">server_name</span> <span style="color:#e6db74">localhost</span>;
  
  <span style="color:#f92672">location</span> <span style="color:#e6db74">/</span> {
<span style="color:#f92672">proxy_pass</span> <span style="color:#e6db74">http://localhost:8081</span>;
<span style="color:#f92672">proxy_set_header</span> <span style="color:#e6db74">Host</span> $host:$server_port;
<span style="color:#75715e"># 设置用户IP地址
</span><span style="color:#75715e"></span><span style="color:#f92672">proxy_set_header</span> <span style="color:#e6db74">X-Forwarded-For</span> $remote_addr;
  }
  }</code></pre></div>
</div>
<h4 id="headline-23">
upstream
</h4>
<h5 id="headline-24">
负载均衡策略
</h5>
<ol>
<li>
<p>
PR(round robin: 轮询默认)
</p>
</li>
</ol>
<div class="src src-nginx">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nginx" data-lang="nginx"><span style="color:#66d9ef">upstream</span> <span style="color:#e6db74">web_servers</span> {  
   <span style="color:#f92672">server</span> localhost:<span style="color:#ae81ff">8081</span>;  
   <span style="color:#f92672">server</span> localhost:<span style="color:#ae81ff">8082</span>;  
}

<span style="color:#66d9ef">server</span> {
    <span style="color:#f92672">listen</span>       <span style="color:#ae81ff">80</span>;
    <span style="color:#f92672">server_name</span>  <span style="color:#e6db74">localhost</span>;
    <span style="color:#75715e">#access_log  logs/host.access.log  main;
</span><span style="color:#75715e"></span>

    <span style="color:#f92672">location</span> <span style="color:#e6db74">/</span> {
	<span style="color:#f92672">proxy_pass</span> <span style="color:#e6db74">http://web_servers</span>;
	<span style="color:#75715e"># 必须指定Header Host
</span><span style="color:#75715e"></span>	<span style="color:#f92672">proxy_set_header</span> <span style="color:#e6db74">Host</span> $host:$server_port;
    }
 }</code></pre></div>
</div>
<ol>
<li>
<p>
权重
</p>
</li>
</ol>
<div class="src src-nginx">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nginx" data-lang="nginx"><span style="color:#75715e"># 4次请求只有一次被分配到8081上，其他3次分配到8082上。backup是指热备，只有当8081和8082都宕机的情况下才走8083
</span><span style="color:#75715e"></span><span style="color:#66d9ef">upstream</span> <span style="color:#e6db74">test</span> {
    <span style="color:#f92672">server</span> localhost:<span style="color:#ae81ff">8081</span> <span style="color:#e6db74">weight=1</span>;
    <span style="color:#f92672">server</span> localhost:<span style="color:#ae81ff">8082</span> <span style="color:#e6db74">weight=3</span>;
    <span style="color:#f92672">server</span> localhost:<span style="color:#ae81ff">8083</span> <span style="color:#e6db74">weight=4</span> <span style="color:#e6db74">backup</span>;
}</code></pre></div>
</div>
<ol>
<li>
<p>
ip_hash
</p>
</li>
</ol>
<p>
上面的2种方式都有一个问题，那就是下一个请求来的时候请求可能分发到另外一台服务器，当我们的程序不是无状态的时候，这时候就有一个很大的问题了，比如把登记信息保存到了session中，那么中转到另外一台服务器的时候就需要重新登录了，所以很多时候我们需要一个客户只访问一个服务器， 那么就需要用ip_hash了，ip_hash的每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。
</p>
<div class="src src-nginx">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nginx" data-lang="nginx"><span style="color:#66d9ef">upstream</span> <span style="color:#e6db74">test</span> {
    <span style="color:#f92672">ip_hash</span>;
    <span style="color:#f92672">server</span> localhost:<span style="color:#ae81ff">8080</span>;
    <span style="color:#f92672">server</span> localhost:<span style="color:#ae81ff">8081</span>;
}</code></pre></div>
</div>
<ol>
<li>
<p>
fair(第三方)
</p>
</li>
</ol>
<p>
按后端服务器的响应时间来分配请求，响应时间短的优先分配。
</p>
<div class="src src-nginx">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nginx" data-lang="nginx"><span style="color:#66d9ef">upstream</span> <span style="color:#e6db74">backend</span> {
    <span style="color:#f92672">fair</span>;
    <span style="color:#f92672">server</span> localhost:<span style="color:#ae81ff">8080</span>;
    <span style="color:#f92672">server</span> localhost:<span style="color:#ae81ff">8081</span>;
}</code></pre></div>
</div>
<ol>
<li>
<p>
url_hash(第三方)
</p>
</li>
</ol>
<p>
按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法
</p>
<div class="src src-nginx">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nginx" data-lang="nginx"><span style="color:#66d9ef">upstream</span> <span style="color:#e6db74">backend</span> {
    <span style="color:#f92672">hash</span> $request_uri;
    <span style="color:#f92672">hash_method</span> <span style="color:#e6db74">crc32</span>;
    <span style="color:#f92672">server</span> localhost:<span style="color:#ae81ff">8080</span>;
    <span style="color:#f92672">server</span> localhost:<span style="color:#ae81ff">8081</span>;
}</code></pre></div>
</div>
<h4 id="headline-25">
return
</h4>
<p>
返回http状态码和可选的每二个参数（可重定向的URL）
</p>
<div class="src src-nginx">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nginx" data-lang="nginx"><span style="color:#66d9ef">location</span> <span style="color:#e6db74">/permantly/moved/url</span> {
    <span style="color:#f92672">return</span> <span style="color:#ae81ff">301</span> <span style="color:#e6db74">http://wwww.example.com/moved/here</span>;
}</code></pre></div>
</div>
<h4 id="headline-26">
rewrite
</h4>
<p>
重写URI请求 rewrite，通过使用rewrite指令在请求处理期间多次修改请求URI，该指令具有一个可选参数和两个必需参数。
    第一个(必需)参数是请求URI必须匹配的正则表达式。
    第二个参数是用于替换匹配URI的URI。
    可选的第三个参数是可以停止进一步重写指令的处理或发送重定向(代码301或302)的标志
</p>
<div class="src src-nginx">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nginx" data-lang="nginx"><span style="color:#66d9ef">location</span> <span style="color:#e6db74">/users/</span> {
    <span style="color:#f92672">rewrite</span> <span style="color:#e6db74">^/users/(.*)</span>$ <span style="color:#e6db74">/show?user=</span>$1 <span style="color:#e6db74">break</span>;
}</code></pre></div>
</div>
<h4 id="headline-27">
error_page
</h4>
<p>
使用error_page指令，您可以配置NGINX返回自定义页面以及错误代码，替换响应中的其他错误代码，或将浏览器重定向到其他URI。在以下示例中，error_page指令指定要返回404页面错误代码的页面(/404.html)。
</p>
<div class="src src-nginx">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nginx" data-lang="nginx"><span style="color:#66d9ef">error_page</span> <span style="color:#ae81ff">404</span> <span style="color:#e6db74">/404.html</span>;</code></pre></div>
</div>
<h4 id="headline-28">
日志
</h4>
<p>
访问日志：需要开启压缩 gzip on; 否则不生成日志文件，打开log_format、access_log注释
</p>
<div class="src src-nginx">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nginx" data-lang="nginx"><span style="color:#66d9ef">log_format</span>  <span style="color:#e6db74">main</span>  <span style="color:#e6db74">&#39;</span>$remote_addr <span style="color:#e6db74">-</span> $remote_user <span style="color:#e6db74">[</span>$time_local] <span style="color:#e6db74">&#34;</span>$request&#34; <span style="color:#e6db74">&#39;</span>
                  <span style="color:#e6db74">&#39;</span>$status $body_bytes_sent <span style="color:#e6db74">&#34;</span>$http_referer&#34; <span style="color:#e6db74">&#39;</span>
                  <span style="color:#e6db74">&#39;&#34;</span>$http_user_agent&#34; <span style="color:#e6db74">&#34;</span>$http_x_forwarded_for&#34;&#39;;
<span style="color:#66d9ef">access_log</span>  <span style="color:#e6db74">/usr/local/etc/nginx/logs/host.access.log</span>  <span style="color:#e6db74">main</span>;
<span style="color:#66d9ef">gzip</span>  <span style="color:#66d9ef">on</span>;</code></pre></div>
</div>
<h4 id="headline-29">
deny
</h4>
<div class="src src-nginx">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-nginx" data-lang="nginx"><span style="color:#75715e"># 禁止访问某个目录
</span><span style="color:#75715e"></span><span style="color:#66d9ef">location</span> ~<span style="color:#e6db74">*</span> <span style="color:#e6db74">\.(txt|doc)</span>${
  <span style="color:#e6db74">root</span> $doc_root;
  <span style="color:#66d9ef">deny</span> <span style="color:#e6db74">all</span>;
<span style="color:#66d9ef">}</span></code></pre></div>
</div>
<h3 id="headline-30">
内置变量
</h3>
<p>
nginx的配置文件中可以使用的内置变量以美元符$开始，也有人叫全局变量。其中，部分预定义的变量的值是可以改变的。另外，关注Java知音公众号，回复“后端面试”，送你一份面试题宝典！
   $args ：#这个变量等于请求行中的参数，同$query_string
   $content_length ：请求头中的Content-length字段。
   $content_type ：请求头中的Content-Type字段。
   $document_root ：当前请求在root指令中指定的值。
   $host ：请求主机头字段，否则为服务器名称。
   $http_user_agent ：客户端agent信息
   $http_cookie ：客户端cookie信息
   $limit_rate ：这个变量可以限制连接速率。
   $request_method ：客户端请求的动作，通常为GET或POST。
   $remote_addr ：客户端的IP地址。
   $remote_port ：客户端的端口。
   $remote_user ：已经经过Auth Basic Module验证的用户名。
   $request_filename ：当前请求的文件路径，由root或alias指令与URI请求生成。
   $scheme ：HTTP方法（如http，https）。
   $server_protocol ：请求使用的协议，通常是HTTP/1.0或HTTP/1.1。
   $server_addr ：服务器地址，在完成一次系统调用后可以确定这个值。
   $server_name ：服务器名称。
   $server_port ：请求到达服务器的端口号。
   $request_uri ：包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。
   $uri ：不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。
   $document_uri ：与$uri相同
</p>

  
  <h4><i class="fas fa-share-alt" aria-hidden="true"></i>&nbsp;Share!</h4>
<ul class="share-buttons">
	<li><a href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fstoneepigraph.github.io%2fpost%2fmiddle%2fnginx-note%2f" target="_blank" title="Share on Facebook"><i class="fab fa-facebook" aria-hidden="true"></i><span class="sr-only">Share on Facebook</span></a>
	</li>&nbsp;&nbsp;&nbsp;
	<li><a href="https://twitter.com/intent/tweet?source=https%3a%2f%2fstoneepigraph.github.io%2fpost%2fmiddle%2fnginx-note%2f" target="_blank" title="Tweet"><i class="fab fa-twitter" aria-hidden="true"></i><span class="sr-only">Tweet</span></a>
	</li>&nbsp;&nbsp;&nbsp;
	<li><a href="https://plus.google.com/share?url=https%3a%2f%2fstoneepigraph.github.io%2fpost%2fmiddle%2fnginx-note%2f" target="_blank" title="Share on Google+"><i class="fab fa-google-plus" aria-hidden="true"></i><span class="sr-only">Share on Google+</span></a>
	</li>&nbsp;&nbsp;&nbsp;
	<li><a href="http://www.tumblr.com/share?v=3&u=https%3a%2f%2fstoneepigraph.github.io%2fpost%2fmiddle%2fnginx-note%2f" target="_blank" title="Post to Tumblr"><i class="fab fa-tumblr" aria-hidden="true"></i><span class="sr-only">Post to Tumblr</span></a>
	</li>&nbsp;&nbsp;&nbsp;
	<li><a href="http://pinterest.com/pin/create/button/?url=https%3a%2f%2fstoneepigraph.github.io%2fpost%2fmiddle%2fnginx-note%2f" target="_blank" title="Pin it"><i class="fab fa-pinterest-p" aria-hidden="true"></i><span class="sr-only">Pin it</span></a>
	</li>&nbsp;&nbsp;&nbsp;
	<li><a href="http://www.reddit.com/submit?url=https%3a%2f%2fstoneepigraph.github.io%2fpost%2fmiddle%2fnginx-note%2f" target="_blank" title="Submit to Reddit"><i class="fab fa-reddit-alien" aria-hidden="true"></i><span class="sr-only">Submit to Reddit</span></a>
	</li>
</ul>


<style>
	ul.share-buttons{
	  list-style: none;
	  padding: 0;
	}

	ul.share-buttons li{
	  display: inline;
	}

	ul.share-buttons .sr-only{
	  position: absolute;
	  clip: rect(1px 1px 1px 1px);
	  clip: rect(1px, 1px, 1px, 1px);
	  padding: 0;
	  border: 0;
	  height: 1px;
	  width: 1px;
	  overflow: hidden;
	}
</style>


  
<div class="prev-next-post pure-g">
  <div class="pure-u-1-24" style="text-align: left;">
    
    <a href="https://stoneepigraph.github.io/post/live/%E5%A4%8D%E7%9B%98%E5%9F%BA%E7%A1%80/"><i class="fa fa-chevron-left"></i></a>
    
  </div>
  <div class="pure-u-10-24">
    
    <nav class="prev">
      <a href="https://stoneepigraph.github.io/post/live/%E5%A4%8D%E7%9B%98%E5%9F%BA%E7%A1%80/">复盘基础</a>
    </nav>
    
  </div>
  <div class="pure-u-2-24">
    &nbsp;
  </div>
  <div class="pure-u-10-24">
    
  </div>
  <div class="pure-u-1-24" style="text-align: right;">
    
  </div>
</div>


  
  
  
  

  

</div>

</div>
</div>
<script src="https://stoneepigraph.github.io/js/ui.js"></script>
<script src="https://stoneepigraph.github.io/js/menus.js"></script>








<script src="/js/math-code.js"></script>
  <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
  


</body>
</html>

