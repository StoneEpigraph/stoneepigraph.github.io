<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>函数式 on 石记</title>
    <link>https://stoneepigraph.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/</link>
    <description>Recent content in 函数式 on 石记</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Wed, 04 Sep 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://stoneepigraph.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java8函数式编程</title>
      <link>https://stoneepigraph.github.io/posts/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</guid>
      <description>&lt;h2 id=&#34;函数式编程&#34;&gt;函数式编程&lt;/h2&gt;&#xA;&lt;p&gt;函数式编程中没有赋值语句,因此变量一旦有了值,就不会再改变了.更通俗地说,函数式编程完全没有副作用.&lt;/p&gt;&#xA;&lt;h2 id=&#34;lambda表达式&#34;&gt;Lambda表达式&lt;/h2&gt;&#xA;&lt;h3 id=&#34;格式&#34;&gt;格式&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;() -&amp;gt; {}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;参数：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;(): 表式没有参数&lt;/li&gt;&#xA;&lt;li&gt;单个参数可不加括号&lt;/li&gt;&#xA;&lt;li&gt;参数可以不加类型，由编译器去推断类型，也可以加上类型。加类型的话需要使用小括号包起来。&lt;/li&gt;&#xA;&lt;li&gt;参数引用的值而不是变量。但不必须写final变量。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;主体：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可以是一个表达式，也可以是一段代码块，如果是一段代码块需要使用大括号包起来。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;函数式接口&#34;&gt;函数式接口&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Java里函数式接口的主要类型&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;接口&lt;/th&gt;&#xA;          &lt;th&gt;参数&lt;/th&gt;&#xA;          &lt;th&gt;返回类型&lt;/th&gt;&#xA;          &lt;th&gt;示例&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&lt;/td&gt;&#xA;          &lt;td&gt;&amp;mdash;-&lt;/td&gt;&#xA;          &lt;td&gt;&amp;mdash;&amp;mdash;&amp;ndash;&lt;/td&gt;&#xA;          &lt;td&gt;&amp;mdash;-&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Predicate&amp;lt;T&amp;gt;&lt;/td&gt;&#xA;          &lt;td&gt;T&lt;/td&gt;&#xA;          &lt;td&gt;boolean&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Consumer&amp;lt;T&amp;gt;&lt;/td&gt;&#xA;          &lt;td&gt;T&lt;/td&gt;&#xA;          &lt;td&gt;void&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Function&amp;lt;T, R&amp;gt;&lt;/td&gt;&#xA;          &lt;td&gt;T&lt;/td&gt;&#xA;          &lt;td&gt;R&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Supplier&amp;lt;T&amp;gt;&lt;/td&gt;&#xA;          &lt;td&gt;None&lt;/td&gt;&#xA;          &lt;td&gt;T&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;UnaryOperator&amp;lt;T&amp;gt;&lt;/td&gt;&#xA;          &lt;td&gt;T&lt;/td&gt;&#xA;          &lt;td&gt;T&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;BinaryOperator&amp;lt;T&amp;gt;&lt;/td&gt;&#xA;          &lt;td&gt;T, T&lt;/td&gt;&#xA;          &lt;td&gt;T&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;流-stream&#34;&gt;流（Stream）&lt;/h2&gt;&#xA;&lt;p&gt;Stream是用函数式编程方式 在集合类上进行复杂操作的工具。&lt;/p&gt;&#xA;&lt;h3 id=&#34;特点&#34;&gt;特点：&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;惰性求值。看返回值是Stream就是惰性求值。如果返回值是另一个值 或空，那么就是及早求值。&lt;/li&gt;&#xA;&lt;li&gt;可链式操作。&lt;/li&gt;&#xA;&lt;li&gt;和Iterator类似，Stream是一种内部迭代试。内部迭代将更多的控制权交给了集合类。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;常用流操作&#34;&gt;常用流操作&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;collect(toList())&#xA;生成一个列表，及早求值操作。&lt;/li&gt;&#xA;&lt;li&gt;map&#xA;将一个流中的值转换成一个新的流。参数是一个只接受一个String类型参数并返回一个新的String的Lambda（Function）。&lt;/li&gt;&#xA;&lt;li&gt;filter&#xA;过滤流中的数据。参数是一个Predicate式的Lambda表达式。&lt;/li&gt;&#xA;&lt;li&gt;flatMap&#xA;可用Stream替换值，然后并多个Stream连接成一个Stream。参数 是一个Function接口的Lambda表达式。&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;multiList.stream()&#xA;  .flatmap(item -&amp;gt; item.getSubList())&#xA;        .filter(obj -&amp;gt; obj.getLength() &amp;gt; 100)&#xA;        .map(obj -&amp;gt; obj.getName())&#xA;        .collect(Collections.toList());&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;max和min&#xA;参数是一个Comparator对象。&lt;/li&gt;&#xA;&lt;li&gt;reduce&#xA;实现从一组值中生成一个值。参数是BinaryOperator式的Lambda表达式。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;类库&#34;&gt;类库&lt;/h2&gt;&#xA;&lt;h3 id=&#34;基本类型&#34;&gt;基本类型&lt;/h3&gt;&#xA;&lt;p&gt;Stream类的某些方法对基本类型和装箱类型做了区分。&#xA;&amp;gt; e.g. ToLongFunction(), LongFunction()&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java Stream简单了解</title>
      <link>https://stoneepigraph.github.io/posts/language/java/stream/</link>
      <pubDate>Tue, 03 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/language/java/stream/</guid>
      <description>&lt;h2 id=&#34;stream&#34;&gt;Stream&lt;/h2&gt;&#xA;&lt;h3 id=&#34;stream的创建方式&#34;&gt;Stream的创建方式&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;通过Collection系列集合提供&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();&#xA;Stream&amp;lt;String&amp;gt; stream1 = list.stream();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;通过Arrays中的静态方法获取数组流&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String[] emps = new String[10];&#xA;Stream&amp;lt;String&amp;gt; stream2 = Arrays.stream(emps);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;通过Stream类中的静态方法of()&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Stream&amp;lt;String&amp;gt; stream3 = Stream.of(&amp;quot;aa&amp;quot;, &amp;quot;bb&amp;quot;, &amp;quot;cc&amp;quot;);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;创建无限流&#xA;&lt;ol&gt;&#xA;&lt;li&gt;迭代&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Stream&amp;lt;Integer&amp;gt; stream4 = Stream.iterate(0, x -&amp;gt; x + 2);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;生成&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Stream.generate(() -&amp;gt; Math.random())&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;中间操作&#34;&gt;中间操作&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;筛选与切片&#xA;&lt;ol&gt;&#xA;&lt;li&gt;filter&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;stream.filter(Predicate)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;limit&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;stream.filter(long)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;skip&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;stream.skip(long)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;distinct&#xA;通过hashcode(),equals()进行去重&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;stream.distinct()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;映射&#xA;&lt;ol&gt;&#xA;&lt;li&gt;map&#xA;将元素转换成其他形式或提取信息。map中的Function本身也会返回一个流。&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;map(Function)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;flatMap&#xA;会整合Function本身返回的流。&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;flatMap(Function)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;排序&#xA;&lt;ol&gt;&#xA;&lt;li&gt;sorted()&#xA;自然排序&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;stream.sorted()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;sorted(Comparator)&#xA;定制排序，指定Comparator&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;stream.sorted(Comparator)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;终止操作&#34;&gt;终止操作&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;查找与匹配&lt;/li&gt;&#xA;&lt;li&gt;allMatch&#xA;检查是否匹配所有元素&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;!--listend--&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;stream.allMatch()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;anyMatch&#xA;检查是否至少匹配一个元素&lt;/li&gt;&#xA;&lt;li&gt;nonMatch&#xA;检查是否没有匹配所有元素&lt;/li&gt;&#xA;&lt;li&gt;findFisrt()&#xA;返回第一个元素&lt;/li&gt;&#xA;&lt;li&gt;findAny&#xA;返回当前流中的任意元素&lt;/li&gt;&#xA;&lt;li&gt;count&#xA;返回流中的元素的个数&lt;/li&gt;&#xA;&lt;li&gt;max(Comparator)&#xA;返回流中的最大值&lt;/li&gt;&#xA;&lt;li&gt;min(Comparator)&#xA;返回流中的最小值&lt;/li&gt;&#xA;&lt;li&gt;归约&#xA;&lt;ul&gt;&#xA;&lt;li&gt;reduce(T, BinaryOperator)&#xA;将流中的元素反复结合起来，得到一个新值。&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Stream.of(1,2,3,4,5).reduce(0, (x, y) -&amp;gt; x + y)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;收集&#xA;&lt;ul&gt;&#xA;&lt;li&gt;collect(Collector)&#xA;将流转换为其他形式,包括转换，分组，分区等&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Stream.of(&amp;quot;11&amp;quot;, &amp;quot;aa&amp;quot;, &amp;quot;bb&amp;quot;).collect(Collectors.toSet());&#xA;Stream.of(&amp;quot;11&amp;quot;, &amp;quot;aa&amp;quot;, &amp;quot;bb&amp;quot;).collect(Collectors.coutning());&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;并行流与串行流&#34;&gt;并行流与串行流&lt;/h3&gt;&#xA;&lt;p&gt;了解使用Fork/Join框架&#xA;Stream可以使用parallel()与sequential()切换并行流与顺序流。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
