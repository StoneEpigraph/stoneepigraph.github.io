<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on 石记</title>
    <link>https://stoneepigraph.github.io/tags/java/</link>
    <description>Recent content in Java on 石记</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Wed, 04 Sep 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://stoneepigraph.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java8函数式编程</title>
      <link>https://stoneepigraph.github.io/posts/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</guid>
      <description>&lt;h2 id=&#34;函数式编程&#34;&gt;函数式编程&lt;/h2&gt;&#xA;&lt;p&gt;函数式编程中没有赋值语句,因此变量一旦有了值,就不会再改变了.更通俗地说,函数式编程完全没有副作用.&lt;/p&gt;&#xA;&lt;h2 id=&#34;lambda表达式&#34;&gt;Lambda表达式&lt;/h2&gt;&#xA;&lt;h3 id=&#34;格式&#34;&gt;格式&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;() -&amp;gt; {}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;参数：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;(): 表式没有参数&lt;/li&gt;&#xA;&lt;li&gt;单个参数可不加括号&lt;/li&gt;&#xA;&lt;li&gt;参数可以不加类型，由编译器去推断类型，也可以加上类型。加类型的话需要使用小括号包起来。&lt;/li&gt;&#xA;&lt;li&gt;参数引用的值而不是变量。但不必须写final变量。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;主体：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可以是一个表达式，也可以是一段代码块，如果是一段代码块需要使用大括号包起来。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;函数式接口&#34;&gt;函数式接口&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Java里函数式接口的主要类型&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;接口&lt;/th&gt;&#xA;          &lt;th&gt;参数&lt;/th&gt;&#xA;          &lt;th&gt;返回类型&lt;/th&gt;&#xA;          &lt;th&gt;示例&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&lt;/td&gt;&#xA;          &lt;td&gt;&amp;mdash;-&lt;/td&gt;&#xA;          &lt;td&gt;&amp;mdash;&amp;mdash;&amp;ndash;&lt;/td&gt;&#xA;          &lt;td&gt;&amp;mdash;-&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Predicate&amp;lt;T&amp;gt;&lt;/td&gt;&#xA;          &lt;td&gt;T&lt;/td&gt;&#xA;          &lt;td&gt;boolean&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Consumer&amp;lt;T&amp;gt;&lt;/td&gt;&#xA;          &lt;td&gt;T&lt;/td&gt;&#xA;          &lt;td&gt;void&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Function&amp;lt;T, R&amp;gt;&lt;/td&gt;&#xA;          &lt;td&gt;T&lt;/td&gt;&#xA;          &lt;td&gt;R&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Supplier&amp;lt;T&amp;gt;&lt;/td&gt;&#xA;          &lt;td&gt;None&lt;/td&gt;&#xA;          &lt;td&gt;T&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;UnaryOperator&amp;lt;T&amp;gt;&lt;/td&gt;&#xA;          &lt;td&gt;T&lt;/td&gt;&#xA;          &lt;td&gt;T&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;BinaryOperator&amp;lt;T&amp;gt;&lt;/td&gt;&#xA;          &lt;td&gt;T, T&lt;/td&gt;&#xA;          &lt;td&gt;T&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;流-stream&#34;&gt;流（Stream）&lt;/h2&gt;&#xA;&lt;p&gt;Stream是用函数式编程方式 在集合类上进行复杂操作的工具。&lt;/p&gt;&#xA;&lt;h3 id=&#34;特点&#34;&gt;特点：&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;惰性求值。看返回值是Stream就是惰性求值。如果返回值是另一个值 或空，那么就是及早求值。&lt;/li&gt;&#xA;&lt;li&gt;可链式操作。&lt;/li&gt;&#xA;&lt;li&gt;和Iterator类似，Stream是一种内部迭代试。内部迭代将更多的控制权交给了集合类。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;常用流操作&#34;&gt;常用流操作&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;collect(toList())&#xA;生成一个列表，及早求值操作。&lt;/li&gt;&#xA;&lt;li&gt;map&#xA;将一个流中的值转换成一个新的流。参数是一个只接受一个String类型参数并返回一个新的String的Lambda（Function）。&lt;/li&gt;&#xA;&lt;li&gt;filter&#xA;过滤流中的数据。参数是一个Predicate式的Lambda表达式。&lt;/li&gt;&#xA;&lt;li&gt;flatMap&#xA;可用Stream替换值，然后并多个Stream连接成一个Stream。参数 是一个Function接口的Lambda表达式。&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;multiList.stream()&#xA;  .flatmap(item -&amp;gt; item.getSubList())&#xA;        .filter(obj -&amp;gt; obj.getLength() &amp;gt; 100)&#xA;        .map(obj -&amp;gt; obj.getName())&#xA;        .collect(Collections.toList());&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;max和min&#xA;参数是一个Comparator对象。&lt;/li&gt;&#xA;&lt;li&gt;reduce&#xA;实现从一组值中生成一个值。参数是BinaryOperator式的Lambda表达式。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;类库&#34;&gt;类库&lt;/h2&gt;&#xA;&lt;h3 id=&#34;基本类型&#34;&gt;基本类型&lt;/h3&gt;&#xA;&lt;p&gt;Stream类的某些方法对基本类型和装箱类型做了区分。&#xA;&amp;gt; e.g. ToLongFunction(), LongFunction()&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java Stream简单了解</title>
      <link>https://stoneepigraph.github.io/posts/language/java/stream/</link>
      <pubDate>Tue, 03 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/language/java/stream/</guid>
      <description>&lt;h2 id=&#34;stream&#34;&gt;Stream&lt;/h2&gt;&#xA;&lt;h3 id=&#34;stream的创建方式&#34;&gt;Stream的创建方式&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;通过Collection系列集合提供&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();&#xA;Stream&amp;lt;String&amp;gt; stream1 = list.stream();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;通过Arrays中的静态方法获取数组流&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String[] emps = new String[10];&#xA;Stream&amp;lt;String&amp;gt; stream2 = Arrays.stream(emps);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;通过Stream类中的静态方法of()&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Stream&amp;lt;String&amp;gt; stream3 = Stream.of(&amp;quot;aa&amp;quot;, &amp;quot;bb&amp;quot;, &amp;quot;cc&amp;quot;);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;创建无限流&#xA;&lt;ol&gt;&#xA;&lt;li&gt;迭代&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Stream&amp;lt;Integer&amp;gt; stream4 = Stream.iterate(0, x -&amp;gt; x + 2);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;生成&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Stream.generate(() -&amp;gt; Math.random())&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;中间操作&#34;&gt;中间操作&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;筛选与切片&#xA;&lt;ol&gt;&#xA;&lt;li&gt;filter&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;stream.filter(Predicate)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;limit&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;stream.filter(long)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;skip&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;stream.skip(long)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;distinct&#xA;通过hashcode(),equals()进行去重&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;stream.distinct()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;映射&#xA;&lt;ol&gt;&#xA;&lt;li&gt;map&#xA;将元素转换成其他形式或提取信息。map中的Function本身也会返回一个流。&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;map(Function)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;flatMap&#xA;会整合Function本身返回的流。&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;flatMap(Function)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;排序&#xA;&lt;ol&gt;&#xA;&lt;li&gt;sorted()&#xA;自然排序&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;stream.sorted()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;sorted(Comparator)&#xA;定制排序，指定Comparator&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;stream.sorted(Comparator)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;终止操作&#34;&gt;终止操作&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;查找与匹配&lt;/li&gt;&#xA;&lt;li&gt;allMatch&#xA;检查是否匹配所有元素&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;!--listend--&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;stream.allMatch()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;anyMatch&#xA;检查是否至少匹配一个元素&lt;/li&gt;&#xA;&lt;li&gt;nonMatch&#xA;检查是否没有匹配所有元素&lt;/li&gt;&#xA;&lt;li&gt;findFisrt()&#xA;返回第一个元素&lt;/li&gt;&#xA;&lt;li&gt;findAny&#xA;返回当前流中的任意元素&lt;/li&gt;&#xA;&lt;li&gt;count&#xA;返回流中的元素的个数&lt;/li&gt;&#xA;&lt;li&gt;max(Comparator)&#xA;返回流中的最大值&lt;/li&gt;&#xA;&lt;li&gt;min(Comparator)&#xA;返回流中的最小值&lt;/li&gt;&#xA;&lt;li&gt;归约&#xA;&lt;ul&gt;&#xA;&lt;li&gt;reduce(T, BinaryOperator)&#xA;将流中的元素反复结合起来，得到一个新值。&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Stream.of(1,2,3,4,5).reduce(0, (x, y) -&amp;gt; x + y)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;收集&#xA;&lt;ul&gt;&#xA;&lt;li&gt;collect(Collector)&#xA;将流转换为其他形式,包括转换，分组，分区等&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Stream.of(&amp;quot;11&amp;quot;, &amp;quot;aa&amp;quot;, &amp;quot;bb&amp;quot;).collect(Collectors.toSet());&#xA;Stream.of(&amp;quot;11&amp;quot;, &amp;quot;aa&amp;quot;, &amp;quot;bb&amp;quot;).collect(Collectors.coutning());&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;并行流与串行流&#34;&gt;并行流与串行流&lt;/h3&gt;&#xA;&lt;p&gt;了解使用Fork/Join框架&#xA;Stream可以使用parallel()与sequential()切换并行流与顺序流。&lt;/p&gt;</description>
    </item>
    <item>
      <title>JVM简述</title>
      <link>https://stoneepigraph.github.io/posts/jvm/</link>
      <pubDate>Sun, 17 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/jvm/</guid>
      <description>&lt;h2 id=&#34;类的加载-连接与初始化&#34;&gt;类的加载,连接与初始化&lt;/h2&gt;&#xA;&lt;h3 id=&#34;加载&#34;&gt;加载&lt;/h3&gt;&#xA;&lt;p&gt;指的是将类的.class文件中的二进制数据读入到内存当中,将其放在运行时数据区的方法区内,然后在内存中创建一个java.lang.Class对象.&lt;/p&gt;&#xA;&lt;h4 id=&#34;类的加载方式&#34;&gt;类的加载方式&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;从本地系统中直接加载&lt;/li&gt;&#xA;&lt;li&gt;从网络下载.class&lt;/li&gt;&#xA;&lt;li&gt;从zip, jar等归档中加载.class文件&lt;/li&gt;&#xA;&lt;li&gt;从专有数据库中提取.class文件&lt;/li&gt;&#xA;&lt;li&gt;将Java源文件动态的编译为.class文件&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;连接&#34;&gt;连接&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;验证确保被加载的类的正确性&lt;/li&gt;&#xA;&lt;li&gt;准备为类的静态变量分配内存,并将其初始化为默认值&lt;/li&gt;&#xA;&lt;li&gt;解析把类中的符号引用转换为直接引用&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;类的使用&#34;&gt;类的使用&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;主动使用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;创建类的实例&lt;/li&gt;&#xA;&lt;li&gt;访问某个类或接口的静态变量或对静态变量赋值&lt;/li&gt;&#xA;&lt;li&gt;访问类的静态方法&lt;/li&gt;&#xA;&lt;li&gt;反射&lt;/li&gt;&#xA;&lt;li&gt;初始化一个类的子类&lt;/li&gt;&#xA;&lt;li&gt;Java虚拟机启动时被标明为启动类的类&lt;/li&gt;&#xA;&lt;li&gt;JDK1.7开始提供的动态语言支持：java.lang.invoke.MethodHandler实例的解析结果REF_getStatic, REF_PUTsTATIC, REF_invokeStatic句柄对应的类没有初始化，则初始化。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;被动使用&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;初始化&#34;&gt;初始化&lt;/h3&gt;&#xA;&lt;p&gt;所有的Java虚拟机实现必须在每个类或接口被Java程序&amp;quot;首次主动使用&amp;quot;时才进行初始化.&lt;/p&gt;&#xA;&lt;h4 id=&#34;注意&#34;&gt;注意&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;当一个常量的值并非编译期间可以确定的,那么其值就不会被放到调用类的常量池中,这时在程序运行时,会导致主动使用这个常量所在的类,显然会导致这个类被初始化.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;主动使用的方式&#34;&gt;主动使用的方式&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;创建类的实例&lt;/li&gt;&#xA;&lt;li&gt;访问某个类或接口的静态变量,或者对该静态变量赋值&lt;/li&gt;&#xA;&lt;li&gt;调用类的静态方法&lt;/li&gt;&#xA;&lt;li&gt;反射如Class.forName(&amp;ldquo;com.path.ClassName&amp;rdquo;)&lt;/li&gt;&#xA;&lt;li&gt;初始化一个类的子类&lt;/li&gt;&#xA;&lt;li&gt;Java虚拟机启动时被标明为启动类的类&lt;/li&gt;&#xA;&lt;li&gt;JDK1.7开始提供的动态语言支持.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;虚拟机参数&#34;&gt;虚拟机参数&lt;/h2&gt;&#xA;&lt;h3 id=&#34;tips&#34;&gt;Tips&lt;/h3&gt;&#xA;&lt;h3 id=&#34;说明&#34;&gt;说明&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;-XX:+&amp;lt;option&amp;gt;, 表示开启option选项&lt;/li&gt;&#xA;&lt;li&gt;-XX:-&amp;lt;option&amp;gt;, 表示关闭option选项&lt;/li&gt;&#xA;&lt;li&gt;-XX:&amp;lt;option&amp;gt;=&amp;lt;value&amp;gt;, 表示将option选项的值设置为value&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;参数&#34;&gt;参数&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&amp;ndash;XX:+TraceClassLoading: 用于追踪类的加载信息并打印出来.&lt;/li&gt;&#xA;&lt;li&gt;-Xss1M: 设置最大调用深度，防止栈举出。StackOverflowError。&lt;/li&gt;&#xA;&lt;li&gt;-XX:MaxTenuringThreshold: 指定新征伐对象经过多少次回收后进入老年代，默认为15次。&lt;/li&gt;&#xA;&lt;li&gt;-XX:PretenureSizeThreshold: 指定对象的大小超过在指定的大小之后，直接晋升老年代。&lt;/li&gt;&#xA;&lt;li&gt;TLAB&#xA;&lt;ol&gt;&#xA;&lt;li&gt;-XX:+UseTLBA: 使用TLAB, 默认开启。&lt;/li&gt;&#xA;&lt;li&gt;-XX:+TLABSize: 设置TLAB大小&lt;/li&gt;&#xA;&lt;li&gt;-XX:TLABRefillWasteFraction：设置维护进入TLAB空间的单个对象大小，他是一个比例值，默认为64,即如果对象大于整个空间的1/64,则在堆创建对象。&lt;/li&gt;&#xA;&lt;li&gt;-XX:+printTLAB：查看TLAB。&lt;/li&gt;&#xA;&lt;li&gt;-XX:ResizeTLAB: 自调整TLABRefillWasteFraction阀值。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;垃圾收集器&#xA;&lt;ol&gt;&#xA;&lt;li&gt;-XX：UseSerialGC： 使用串行垃圾回收器。&lt;/li&gt;&#xA;&lt;li&gt;-XX:+useParNewGC: 新生代使用ParNew回收器。老年代使用串行回收器。&#xA;&lt;ol&gt;&#xA;&lt;li&gt;-XX:parallelGCThreads： 指定Parnew收集器的线程数。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ParallelGC&#xA;&lt;ol&gt;&#xA;&lt;li&gt;-XX:MaxGCPauseMills: 设置最大垃圾收集停顿时间。&lt;/li&gt;&#xA;&lt;li&gt;-XX：GCTimeRatio： 设置吞量大小，它是一个0到100之间的整数，默认为100。&lt;/li&gt;&#xA;&lt;li&gt;-XX:UseAdaptiveSizePolicy: 打开自适应模式。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;CMS&#xA;&lt;ol&gt;&#xA;&lt;li&gt;-XX:+UseConcMarkSweepGC&lt;/li&gt;&#xA;&lt;li&gt;-XX:ConcGCThreads:设置并发线程数量。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;虚拟机调优策略&#34;&gt;虚拟机调优策略&lt;/h3&gt;&#xA;&lt;p&gt;JVM参数调优主要设置堆内存，主要让GC不要去频繁回收垃圾，减少对老年代的回收。配置时让-Xms与-Xmx一致。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
