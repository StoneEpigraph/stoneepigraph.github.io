<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>函数式 on 石记</title>
    <link>https://stoneepigraph.github.io/categories/%E5%87%BD%E6%95%B0%E5%BC%8F/</link>
    <description>Recent content in 函数式 on 石记</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Wed, 04 Sep 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://stoneepigraph.github.io/categories/%E5%87%BD%E6%95%B0%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java8函数式编程</title>
      <link>https://stoneepigraph.github.io/posts/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://stoneepigraph.github.io/posts/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</guid>
      <description>&lt;h2 id=&#34;函数式编程&#34;&gt;函数式编程&lt;/h2&gt;&#xA;&lt;p&gt;函数式编程中没有赋值语句,因此变量一旦有了值,就不会再改变了.更通俗地说,函数式编程完全没有副作用.&lt;/p&gt;&#xA;&lt;h2 id=&#34;lambda表达式&#34;&gt;Lambda表达式&lt;/h2&gt;&#xA;&lt;h3 id=&#34;格式&#34;&gt;格式&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;() -&amp;gt; {}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;参数：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;(): 表式没有参数&lt;/li&gt;&#xA;&lt;li&gt;单个参数可不加括号&lt;/li&gt;&#xA;&lt;li&gt;参数可以不加类型，由编译器去推断类型，也可以加上类型。加类型的话需要使用小括号包起来。&lt;/li&gt;&#xA;&lt;li&gt;参数引用的值而不是变量。但不必须写final变量。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;主体：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可以是一个表达式，也可以是一段代码块，如果是一段代码块需要使用大括号包起来。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;函数式接口&#34;&gt;函数式接口&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Java里函数式接口的主要类型&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;接口&lt;/th&gt;&#xA;          &lt;th&gt;参数&lt;/th&gt;&#xA;          &lt;th&gt;返回类型&lt;/th&gt;&#xA;          &lt;th&gt;示例&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&lt;/td&gt;&#xA;          &lt;td&gt;&amp;mdash;-&lt;/td&gt;&#xA;          &lt;td&gt;&amp;mdash;&amp;mdash;&amp;ndash;&lt;/td&gt;&#xA;          &lt;td&gt;&amp;mdash;-&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Predicate&amp;lt;T&amp;gt;&lt;/td&gt;&#xA;          &lt;td&gt;T&lt;/td&gt;&#xA;          &lt;td&gt;boolean&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Consumer&amp;lt;T&amp;gt;&lt;/td&gt;&#xA;          &lt;td&gt;T&lt;/td&gt;&#xA;          &lt;td&gt;void&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Function&amp;lt;T, R&amp;gt;&lt;/td&gt;&#xA;          &lt;td&gt;T&lt;/td&gt;&#xA;          &lt;td&gt;R&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Supplier&amp;lt;T&amp;gt;&lt;/td&gt;&#xA;          &lt;td&gt;None&lt;/td&gt;&#xA;          &lt;td&gt;T&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;UnaryOperator&amp;lt;T&amp;gt;&lt;/td&gt;&#xA;          &lt;td&gt;T&lt;/td&gt;&#xA;          &lt;td&gt;T&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;BinaryOperator&amp;lt;T&amp;gt;&lt;/td&gt;&#xA;          &lt;td&gt;T, T&lt;/td&gt;&#xA;          &lt;td&gt;T&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;流-stream&#34;&gt;流（Stream）&lt;/h2&gt;&#xA;&lt;p&gt;Stream是用函数式编程方式 在集合类上进行复杂操作的工具。&lt;/p&gt;&#xA;&lt;h3 id=&#34;特点&#34;&gt;特点：&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;惰性求值。看返回值是Stream就是惰性求值。如果返回值是另一个值 或空，那么就是及早求值。&lt;/li&gt;&#xA;&lt;li&gt;可链式操作。&lt;/li&gt;&#xA;&lt;li&gt;和Iterator类似，Stream是一种内部迭代试。内部迭代将更多的控制权交给了集合类。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;常用流操作&#34;&gt;常用流操作&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;collect(toList())&#xA;生成一个列表，及早求值操作。&lt;/li&gt;&#xA;&lt;li&gt;map&#xA;将一个流中的值转换成一个新的流。参数是一个只接受一个String类型参数并返回一个新的String的Lambda（Function）。&lt;/li&gt;&#xA;&lt;li&gt;filter&#xA;过滤流中的数据。参数是一个Predicate式的Lambda表达式。&lt;/li&gt;&#xA;&lt;li&gt;flatMap&#xA;可用Stream替换值，然后并多个Stream连接成一个Stream。参数 是一个Function接口的Lambda表达式。&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;multiList.stream()&#xA;  .flatmap(item -&amp;gt; item.getSubList())&#xA;        .filter(obj -&amp;gt; obj.getLength() &amp;gt; 100)&#xA;        .map(obj -&amp;gt; obj.getName())&#xA;        .collect(Collections.toList());&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;max和min&#xA;参数是一个Comparator对象。&lt;/li&gt;&#xA;&lt;li&gt;reduce&#xA;实现从一组值中生成一个值。参数是BinaryOperator式的Lambda表达式。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;类库&#34;&gt;类库&lt;/h2&gt;&#xA;&lt;h3 id=&#34;基本类型&#34;&gt;基本类型&lt;/h3&gt;&#xA;&lt;p&gt;Stream类的某些方法对基本类型和装箱类型做了区分。&#xA;&amp;gt; e.g. ToLongFunction(), LongFunction()&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
