[{"content":" 数据密集型应用设计 数据系统基础 可靠、可扩展与可维护的应用系统 对于数据密集型应用，CPU的处理能力往往不是第一限制性因素，在于数据量、数据的复杂度及数据的快速多变性。数据密集型应用通常也是基于标准模块构建而成，每个模块负责单一的常用功能。例如，许多应用系统都包含以下模块：\n数据库： 用以存储数据，这样之后应用可以再次访问 调整缓存：缓存那些复杂或操作代价昂贵的结果，以加快下一次访问。 索引：用户可以按安搜索数据并支持各种过滤。 流式处理：持续发送消息臻另一个进程，处理采用异步方式 批处理：定期处理大量的累积数据。 可靠性\n当出现意外情况，如硬件、软件故障、人为失误等，系统应可以继续正常运转：虽然性能可能有所降低，但确保功能正确。对于软件,典型的可靠性期望包括:\n应用程序执行用户据期望的功能. 可以容忍用户出现错误或者不正确的软件使用方法 性能可以应对典型场景, 合理负载原动力和数据量 系统可防止任何示经授权的访问和滥用 硬件故障 软件故障\n原因\n由于软件错误 一个应用进程使用了某些共享资源,但却不幸失控 系统统带于某些服务,但该服务突然或无响应 级联故障 人为失误\n如果假定人是不可靠的,那么该如何保证系统的可靠性?\n以最小出错的方式来设计系统. 想办法分离最容易出错的地方,容易引发故障的接口. 充分的测试 当出现人为失误时,提供快速的恢复机制以尽量减少故障影响 设置详细而清晰的监控子系统 推行管理流程并加以培训. 可靠性的重要性 可扩展性\n随着规模的增长，例如数据量、流量或复杂性，系统应以合理的方式来匹配这种增长。可扩展性是描述系统应对负载增加能力的术语。它并不是衡量一个系统的一维指标，谈论“x是可扩展的”或“y不扩展”没有太大意义。相反，讨论可扩展性通常要考虑这类问题：“如果系统以某种方式增长，我们应对增长的措施有哪些”，“我们该如何添加计算资源来处理额外的负载”。\n描述负载\n负载可以用称为负载参数的若干数字来描述，参数的最佳选择取决于系统的体系结构。如Web服务器的每秒请示处理次数，数据库中定稿的比例等。\n描述性能\n延迟和响应时间\n延迟和响应时间容易混淆使用，通常响应时间是客户端看到的：除了处理请示时间外还包括来回网络延迟和各种排除延迟。延迟是请示花费在处理上的时间。有时，即使所有请示都相同，也会由于其他变量因素而引入一些延迟拉动，这些因素包括上下文切换和进程调度、网络数据包丢失和TCP重传、垃圾回收暂停、缺页中断和磁盘IO,甚至服务器机架的机械振动等。我们经常考察的是服务请示的平均响应时间，然后如果想知道更典型的响应时间，平均值并不是合适的指标，因为它掩盖了一些信息，无法告诉有多少用户实际经历了多少延迟。因此最好使用百分位数(percentiles)。如果已经搜集到了响应时间信息，将其从最快到最慢排序，中位数(median)就是列表中间的响应时间。中位数指标非常适合描述多少用户需要等待多长时间，通常缩写为p50。为了弄清楚异常值有多糟糕，需要关注更大的百分位数，如觉的p95, p99和p999。采用较高的响应时间百分位数很重要，因为它们直接影响用户的总体服务体验。百分位数通常用于描述、定义服务质量目标（Service Level Objectives, SLO）和服务质量协议（Service Level Agreements, SLA），这些是规定服务预期质量和可用性的合同。排队延迟往往在高百分数响应时间中影响很大。由于服务器并行处理的请示有限，正在处理的少数请示可能会阻挡后续请示，这种情况有时被称为队头阻塞。即使后续请示可能处理很简单，但它阻塞在等待先前请示的完成，客户端会观察到极慢的响应时间。\n应对负载增加的方法\n把无状态服务分布然后扩展臻多台机器相对比较容易，而有状态服务从单个节点扩展到分布式多机环境的复杂性会大大增加。出于这个原因，址到最近通常的做法一直是，将数据库运行在一个节点上（采用垂直扩展策略），直到高扩展性或高可用性的要求近使不得不做水平扩展。超大规模的系统往往针对特定应用而高度定制，很验证有一种通用的架构。背后取舍因素包括数据读取量、写入量、待存储的数据量、的复杂程度、响应时间要求、访问模式等，或者更多的是上述所有因素的叠加，再加上其他更复杂的问题。对于特定应用来说，扩展能力好的架构通常会做出某些假设，然后有针对性地优化设计，如哪些操作是最频繁的，哪 些负载是少数情况。可扩展架构通常都是从通用模块逐步构建而来， 背后往往有规律可循。\n可维护性\n随着时间的失衡，许多新的人员参与到系统开发和运维，以维护现有功能或甜酸新场景等，可维护性包括维护与缺陷修复，监控系统来保持正常运行、故障排查、适配新平台、搭配新场景、技术担风险的完善以及增加新功能等。\n我们需要特别关注软件系统的三个设计原则\n可运维性\n方便运营团队来保持系统平衡运行。\n运营团队负责的主要内容\n监视系统的健康状况，并在服务出现异常状态时快速恢复服务。 追踪问题的原因，例如系统故障或性能下降。 保持软件和平台臻最新状态 了解不同系统如何相互影响，避免执行带有破坏性的操作。 预测未来可能的问题，并在问题发生之前即解决。 建立用于部署、配置管理待良好的实中规范和工具包。 执行复杂的维护任务 当配置更改时，维护系统的安全稳健 制定流程来规范操作行为，并保持生产环境稳定。 保持相关知识的传承（如对系统的理解）。 数据系统设计要点\n提供对系统运行时行为和内部的可观测性，方便监控。 支持自动化，与标准工具集成。 避免绑定特定的机器，这样在整个系统不间断运行的同时，允许机器停机维护。 提供良好的文档和易于理解的操作模式。 提供良好的默认配置，且允许管理员在需要时方便地修改默认值。 尝试自我修复，在需要时让管理员手动控制系统状态。 行为可预测，减少意外发生。 简单性\n简化系统复杂性，使新工程师能够轻松理解系统。复杂性有各种各样的表面方式：状态空间的膨胀，模块紧耦合，令人纠结的相互依赖关系，不一致的命名和术语，为了性能而的特殊片，为解决某特定问题而引入的特殊框架等。简化系统设计并不意味关减少系统功能，而主要意味着意外方面的复杂性。消除意外复杂性最好手段之一是抽象。\n可演化性\n后续工程师能够轻松地对系统进行改进，并根据需求变化将其适配到非典型场景，也称为可延伸性、易修改性可可塑性。\n数据模型与查询语言 关系模型与文档模型\n关系模型\n关系模型所做的是定义了所有数据的模式：关系（表）只是元组（行）的分文不值一，公此而已。没有复杂的嵌套结构，也没胡复杂的访问路径。可以读取表中的任何一行或者所有行，支持任意条件查询。可以指定某些列作为键并匹配这些列来读取特定行。可以在任何表中插入新行，而不必担心与其他表之间的外键关系。关系模型的一个核心要点是：只需要构建一次查询优化器，然后使用该数据库的所有应用程序都可以从中受益。\nNoSQL\n采用NoSQL数据库的驱动因素\n比关系数据库更好的扩展性需求，錍巴拉圭超 大数据集或超市写入吞量 普通偏爱免费和开源软件而不是商业数据库产品。 关系模型不能很好地支持一些特定的查询操作。 对关系模式一些限制性感到沮丧，渴望更具动态和表达力的数据模型。 对象-关系不匹配 多对一与多对多的关系\n使用ID比使用纯文本字符串的优势\n所有的数据保持和输入值一致。 避免歧义。 易于更新。 本地化支持。 更好的搜索支持。 网络模型\n也被称为CODASYL模型，是层次模型的推广。在层次模型的要结构中，每个记录只有一个父结点；而在网络模型中，一个记录可能有多个父结点。\n关系数据库与文档数据库现状\n支持文档数据模型的主要论点是模式灵活性，由于局部性而带来较好的性能，对于某些应用来说，它更接近于应用程序据使用的数据结构。关系模型则强在联结操作、多对一和多对多关系更简洁的表达上。\n哪种数据模型的应用代码更简单？\n如果应用数据具有类似文档的结构，那么使用文档模型更为合适。而关系型模型则倾向于某种数据分解，它把文档结构分解为多个表，有可能使得模式更为笨重，以及不必要的应用代码复杂化。文档也有一定的局限性：例如，不能直接引用文档中的嵌套项，然而只要文档嵌套不太深，这通常不是问题。在文档数据库中，对联结的支持不足是否是问题取决于应用程序。但是如果应用程序确实使用了多对多关系，那么文档模型就变得不太吸引人。通常无法一概而论哪种数据模型的应用代码更简单。这主要取决于数据项之间的关系类型。\n文档模型中的模式灵活性\n文档数据库有时被称为无模型，wxjg这具有误导性，因为读数据的代码通常采用某种结构因而存在某种隐形模式，而不是由数据库强制执行。更准确的术语应该是读时模型，与写时模式（关系数据库的一种传统方法，模式是显式的，并且数据库确保数据写入时都必须遵循）相对应。读时模式类似编程语言中的动态（运行时）类型检查，而写时模式类似于静态（编译时）类型检查。\n查询数据局部性\n文档通常存储为编码为JSON、XML或其它二进制变化的连接字符串。如果应用程序需要频繁访问整个文档，则存储局部性具有性能优势。如果数据被在多个表中，则需要进行多次索引查找来检索所有数据，蹭可能需要更多的duteIO并花费更多的时间。局部性优势公适用需要同时访问文档大部分内容的场景。由于数据库通常会加载整个文档，如果应用只是访问其中的一小部分，则对于大型文档数据来讲就有些浪费。对于文档更新时，通常会重写整个文档，而只有修改量不改变源文件大小时，原地覆盖更新有更有效。因此，通常建议文档应该尽量小且避免定稿时增加文档大小。这些性能方面的不利因素大大限制了文档数据库的适用场景。\n文档数据库与关系数据库的融合 数据查询语言\n声明式查询\n声明式查询语言很有吸引力，它比命令式API更加简洁和容易使用。但更重要的是，它对外隐藏了数据库引擎的很多实现细节，这样数据库系统能够在不改变查询语句的情况下提高性能。声明式语言通常适合于并行执行,它仅仅指定了结果所满足的模式，而不指定如何得到结果的具体算法。所以如果可以的话，数据库者倾向于采用并行方式实现查询语言。\nWeb上的声明式查询\ncss xpath MapReduce查询\nMapReduce既不是声明式查询语言，也不是一个完全命令式的查询API,而是介于两者之间：查询的逻辑用代码片段来表示，这些代码片段可以被处理框架重复地调用。它主要基于许多函数式编程语言中的map（也称为collect)和reduce(也称为fold或inject)函数。 map和reduce函数对于可执行的操作有所限制。它们必须是纯函数，这意味着只能使用传递进去的数据作为输入，而不能执行额外的数据库查询，也不能有任何副作用。这些限制使得数据库能够在任何位置、以任意顺序来运行函数，并在失败时重新运行这些函数。\n图状数据模型\n如果多对多的关系在数据中很觉，随着数据之间的关联越来越复杂，将数据建模转的为图模型会更加自然。图由两种对象组成：顶点（也称为结点或实体）和边（也称为关系或弧）。很多数据可以建模为图，例如：社交网络，web图，公路或铁路网。有多种不同但相关的方法可以构建和查询图中的数据。我们讨论属性图模型（property graph, 以Neo4j、Titan和InfiniteGraph为代表）和三元存储模型（triplestore、以Datomic、AllegroGraph等为代表）。讨论三种声明式图查询语言：Cypher、SPARQL和Datalog.这外，还有像Gremlin这样的命令式图查询语言，以及Pregel这样的图处理框架。\n图属性\n在属性图模型中，每个顶点包括：\n唯一的标识符 出边的集合 入边的集合 属性的集合（键值对） 每个边包括：\n唯一的标识符 边开始的顶点（尾部顶点） 边结束的顶点（头部顶点） 描述两个顶点间关系类型的标签 属性的集合（健值对） 可以将图存储看作由两个关系表组成，一个用于顶点，一个用于边。关于图模型一些值得注意的地方：\n任何顶点都可以连接到其他任何顶点。没有模式限制哪种事物可以或不可以关联。 给定某个顶点，可以高效地得到它的所有入边和出边，从而遍历图，即沿着这些顶点链条一直有向前或向后。 通过对不同类型的关系使用不同的标签，可以在单个图中存储多种不同类型的信息，同时仍然保持整洁的数据模型。 Cypher查询语言\nCypher是一种用于属性图的声明式查询语言，最早为Neo4j图形数据库而创建。一个例子：\ncreate (NAmerica:Location {name: 'North America', type:'continet'}), (USA:Location {name: 'United States', type:'country'}) (Idaho:Location {name:'Idaho', type:'state'}), (Lucy:Person {name:'Lucy'}), (Idaho) - [:WITHIN]-\u0026gt; (USA) -[:WITHIN]-\u0026gt;(NAmerica), (Lucy) -[:BORN_IN]-\u0026gt; (Idaho) SQL中的图查询\nCrypher可以用:WITHIN*0..非常简洁地表达它沿着一个WINTHIN边遍历零次或多次。SQL:1999标准以后，查询过程中这种可变的遍历路径可以使用称为递归公用表表达式（即WITH RECURSIVE语法）来表示，但与Cypher相比，语法仍显得非常笨拙。\n三元存储与SPARQL\n三元存储模式几乎等同于 属性图模型，只是使用不同的名词描述了相同的思想。在三元存储中，所有信息都以非常简单的三部分形式存储（主体，谓语，客体）。三元组的主体相当于图中的顶点。而客体则是以下两种之一：\n原始数据类型中的值，如字符串或数字。在这种情况下，三元组的谓语和客体分别相当于主体（顶点）属性中的键和值。 图中的另一个顶点。此时，谓语是图中的边，主体是尾部顶点，而客体是头部顶点。 语义网 RDF数据模型 SPARQL查询语言\nSPARQL是一种采用RDF数据模型的三元存储查询语言，名字是SPARQL Protocol和RDF Query Language的缩写一个例子：\nPREFIX : \u0026lt;urn:example:\u0026gt; select ?personName where { ?person :name ?personName. ?person :bornIn / :within* / :name \u0026quot;United States\u0026quot;. ?person :livesIn / :within* / :name \u0026quot;Europe\u0026quot;. } 可以看到总体结构与Cypher非常相似。\n(person) -[:BORN_IN]-\u0026gt; () -[:WITHIN*0..] -\u0026gt; (location) #Cypher ?person :bornIn / :within* ?location. #SPARQL 由于RDF不区分属性和边，可以同时对两者执行谓语操作，所以可以采用相同的语法来匹配属性上的查询条件。\nDatalog基础\nDatalog的数据模型类似于三元存储模式，但更为通用一些。它采用“谓语（主体，客体）”的表达方式而不是三元组（主体，谓语，客体）。已经定义好了数据之后，可以执行之前类似的查询，Datalog是Prolog的子集。一个例子：\nname(usa, 'United States'). type(usa, country). within(usa, namerica). within_recursive(Location, Name) :- name(Location, Name). # 规则1 within_recursive(Location, Name) :- within(Location, Via), within_recursive(Via, Name). # 规则2 magrated(Name, BornIn, LivingIn) :- name(Person, name), born_in(Person, BornLoc), within_recursive(BornLoc, BornIn), livs_in(Person, LivingLoc), within_recursive(LivingLoc, LivingIn). # 规则3 ?- migrated(Who, 'United States', \u0026quot;Europe\u0026quot;). Datalog方法需要采取与其他查询语言略有不同的思维方式，但它非常强大，特别是规则可以在不同的查询中组合和重用。对于简单的一次性查询来说，这或许不太方便，但是如果数据非常复杂，处理起来会更加游刃有余。\n小结\n历史上，数据最初被表示为一棵大树（层次模型），但是这不利于表示多对多关系，所以发明了关系模型来解决这个问题。最近，开发人员发现一些应用程序也不太适合关系模型。新的非关系“NoSQL”数据存储在两个主要方向上存在分歧：\n文档数据库的目标用例是数据来自于自包含文档，且一个文档与其他文档之间的关联很少。 图数据库则针对相反的场景，目标用命是所有数据都可能会互相关联。所有这三种模型（文档模型、关系模型和图模型），如今都有广泛使用，并且在各有自的目标领域都足够优秀。 数据存储与检索 从最基本的层面看，数据库只需要做两件事情：向它插入数据时，它就保存数据；之后查询时，它应该返回那些数据。\n数据库核心：数据结构\n索引\n索引是基于原始数据派生而来的额外数据结构。由于每次写数据时，需要更新索引，因此任何类型的索引通常都会降低写的速度。这里涉及存储系统中重要的权衡设计：适当的索引可以加速读取查询，但每个索引都会减慢写速度。为此，默认情况下，数据库通常不会对所有内容进行fphx,它需要应用开发人员或数据库管理员，基于对应用程序典型查询模式的了解，来手动选择索引。目的是为了应用程序提供最有利加速的同时，避免引入过多不必要的开销。\n哈希索引\n哈希索引的局限性\n哈希表必须全部放入内存，所以如果有大量的键，就没那么幸运了。原则上，可以在磁盘上维护hash map,但是不幸的是，很难使磁盘上的hash map表现良好。它需要大量的随机访问IO,当哈希变满时，继续增长代价昂贵，并且哈希冲突时需要复杂的处理逻辑。 区间查询效率不高。 SSTables和LSM-Tree\n简单改变key-value日志文件的格式：要求key-value对的顺序按键排序。这种格式称为排序字符串表，或简称为SSTable.它要求每个键在每个合并的段文件中只能出现一次。 SSTable相比哈希索引的日志段，具有以下优点：\n合并段更加简单高效，即使文件大于可用内存。 在文件中查找特定的键时，不再需要在内存中保存所有键的索引。 由于读请示往往需要扫描后未范围内的多个key-value对，可以考虑将这些记录保存到一个上并在写磁盘之前将其压缩。然后稀疏内存索引的每个条目指向压缩块的开头。除了节省磁盘空间，压缩还减少了IO带宽的占用。 构建和维护SSTables\n存储引擎的基本工作流程如下：\n当写入时，将其添加到内存跌平衡树数据结构中（例如红黑树）。这个内存中的树有时被称为内存表。 当内存表大于某个阈值（通常为几兆字节）时，将其作为SSTable文件写入磁盘。由于树已经维护了按键排序的key-value对，写磁盘可以比较高效。新的SSTable文件成为数据库的最新部分。当SSTable写磁盘的同时，写入可以继续添加到一个新的内存表实例。 为了处理读请示，首先尝试在内存表中查找键，然后是最新的段文件，接下来是次新的谁的，以此类推，直到找到目标（或为空）。 后台进程周期性地执行段合并与压缩过程，以合并多个段文件，并丢弃那些已经被覆盖或删除的值。上述方案可以很好地工作。但它还存在一个问题：如果数据库崩溃，最近的定稿（在内存表中但尚未写入磁盘）将会丢失。 从STables到LSM-Tree\n基于合并和压缩排序文件原理的存储引擎通常都被称为LSM存储引擎。\n性能优化\n查找数据库中某个不存在的键时，LSM-Tree算法可能很慢：在确定键不存在之前必须先检查内存表，然后将段一直回溯访问到最旧的段文件。为了优化这种访问，存储引擎通常使用额外的过滤器。还有一同的策略会影响甚至决定SSTables压缩和合并时的具体顺序和时机。最觉的方式是大小分组和分层压缩。在大小分级的压缩中，较新的和较小的SSTables被连续合并到较旧和较大的SSTables.在分层中，键的范围分裂成多个更小的SSTables,旧数据被移动到单独的“层级”，这样压缩可以逐步进行并节省磁盘空间。\nB-trees\nB-tree将数据库分解成固定大小的块或页、传统上大小为4KB（有时更大），页是内部读/写的最小单元。这种设计更接近底层硬件，因为磁盘也是以固定大小的块排列。每个页面都可以使用地址或位置进行标识，这样可以让一个页面引用另一个页面，类似指针，不过是指向磁盘地址，而不是内存。可以使用这些页面引用来构造一个树状页面，某一页被指定为B-tree的楖每当查询索引中的一个键时，总是从这里开始。该页面包含若干个键和对子页的引用。每个孩子 都负责一个连续范围内的键，相信引用之间的键可以指示这些范围之间的边界。 B-tree中一个页所包含的子页引用数量称为分支因子。在实际中，分支因素取决于存储页面引用和范围边界据需的空间总量，通常为几百个。如果需要更新B-tree中现有的值，首先搜索包含该键的叶子页，更改该页的值，并将页写回到磁盘。如果要添加新键，则需要找到其范围包含新键的页，并将其添加到该页。如果页中没有足够的可用空间来容纳新的那家，则将其分裂为两个半满的页，并且父页也需要更新以包含分裂之后的新的键范围。该算法确保树保持平衡：具有N个键的B-tree总是具有O(log n)的深度。\n使B-tree可靠\nB-tree底层的基本写操作操作是使用新数据覆盖磁盘上的旧页。它假设覆盖不会改变页的磁盘存储位置，也就是说，当页被覆盖时，对该页的所有引用保持不变。为了使数据库能从崩溃中恢复，常见B-tree的实现需要支持磁盘上的额外的数据结构：预写日志（write-ahead log, WAL），也称为重做日志。这是一个公支持追加修改的文件，每个B-tree的修改必须先更新WAL然后再修改树本身的页。原地更新页的另一个复杂因素是，如果多个线程要同时访问B-tree,则需要注意并发控制，否则线程可能会看到树处于不一致的状态。通常使用锁存器（轻量级锁）保护树的数据结构来完成。\n优化B-tree\n一些数据库不使用覆盖页和维护RAL来进行崩溃恢复，而是使用写时复制方案。修改的页被定稿不同的位置，树中父页的新版本被创建，并指向新的位置。这种方法对于前功尽弃控制也很有帮助。 保存键的缩略信息，而不是完整的键，这样可以节省页空间。 一般来说，页可以放在磁盘上的任何位置；没有要求相信的页需要放在磁盘的相信位置。如果查询需要按照排序扫描大段的键范围，考虑到每个读取的页都可能需要磁盘IO,所以逐页的而已可能是低效的。因此，许多B-tree的实现深度对树进行布局，以便相信叶子页可以按顺序保存在磁盘上。 添加额外的指针到上。例如每个叶子页面可能会向左和向右引用其同级的兄弟页，这样可以顺序扫描键，而不用跳回到父页。 B-tree的谈何如分形树，借鉴了一些日志结构的想法来减少磁盘寻道。 对比B-tree和LSM-tree\n根据经验，LSM-tree通常对于定稿更快，而B-tree被认为对于读取更快。\nLSM-tree的优点\nLSM-tree通常能够承受比B-tree更高的写入吞量，原因是磁盘的顺序写比随机写要快的多。 LSM-tree可以支持更好的压缩，因此通常磁盘上的文件比B-tree小很多。 LSM-tree的缺点\n日志结构存储的缺点是压缩过程有时会干扰正在进行的读写操作。 高写入吞量时，磁盘的有一般说来a要在初始写入和后台运行的压缩线程之间所共享。如果写入吞量很高并且压缩没有仔细配置，那么就会发生压缩无法匹配新数据定稿速率的情况。 其它索引结构\n在索引中存储值\n索引中的键是查询搜索的对象，而值则可以是以下两类之一：它可能是实际行，也可以是对其他地方存储的行的引用。在保存其他地方引用时，存储行的具体位置被称为堆文件，并且它不以特定的顺序存储数据。在某些情况下，从索引到堆文件的额外跳转对于读取来说意味着太多的性能损失，因此可能希望交款地直接存储在索引中，这被称为聚焦索引。例如MySQL InnoDB存储引擎中，表的主键始终是聚集索引，二级索引引用主键。\n多列索引\n最常见的多列索引类型称为级联索引，它通过将一列追加到另一列，将几个字段简单地组合成一个键。\n全文搜索和模糊索引\n全文搜索引擎通常支持对一个音讯的所有同义词进行查询，并忽略音讯语法上的变化，在同一文档中搜索彼此接近的音讯珠出现，并且支持多种依赖语言分析的其他高级功能。\n在内存中保存所有内容\n内存数据库的性能优势并不是因为它们不需要从磁盘读取，而是因为它们避免使用写磁盘的格式对内存数据结构编码的开销。\n事务处理与分析处理\n事务主要指组成一个逻辑单元的一组读写操作。\nTable 1: 对比事务处理（OLTP）与分析系统（OLAP）的主要特征 属性 事务处理系统（OLTP） 分析系统（OLAP） 主要读特征 基于键，每次查询返回少量的记录 对大量记录进行汇总 主要写特征 随机访问，低延迟写入用户的输入 批量导入（ETL）或事件流 典型使用场景 终端用户，通过网络应用程序 内部分析师，为决策提供支持 数据表征 最新羼主（当前时间点） 随着时间而变化的所有事件历史 数据规模 GB到TB TB到PB 数据仓库\n使用单独的数据仓库而不是直接查询OLTP系统进行分析，很大的优势在于数据仓库可以针对分析访问模式进行优化。\nOLTP数据库和数据仓库之间的差异\n数据仓库的数据模型最常见的是关系型，因为SQL通常适合分析查询。\n星型与雪花型分析模式\n许多数据仓库都相当公式化的使用了星型模式，也称为维度建模。模式的中心是一个所谓的事实表。青衫表的每一行表示在特定的时间发生的事件。事实表中的列是属性, 其他列可能会引用其他表的外键，称为维度表。该模板一个谈何称为雪花模式，其中维度进一步细分为子空间。\n列式存储\n面向列存储的想法很简单：不要将一行中的所有值存储在一起，而是将每列中的所有值存储在一起。如果每个列存储在一个单独的文件中，查询只需要读取和解析在该查询中使用的那些列，这可以节省大量的工作。面向列的存储布局依赖一组列文件，每个文件以相同顺序保存着数据行。\n列压缩\n除了公从磁盘中加载查询所需的迾这个，还可以通过压缩数据来进一步降低对磁盘吞量的要求。\n内存带宽和矢量化处理 列存储的排序\n在列存储中，行的存储顺序并不太重要。最简单的是插入顺序保存。\n列存储的写操作\n面向列的存储、压缩和排序都非常有乃至于加速读取查询。但是，它们的缺点是让写入更加困难。我们可以使用LSM-tree.将所有的写入首行进入内存存储区，将其添加到已排序的结构中，接着再准备写入磁盘。执行查询时，需要检查磁盘上的烈vrnt内存中的最近的定稿，并结合这两者。\n聚合：数据立方体与物化视图\n如果许多不同查询使用相同的聚合，每次都处理原始数据将非常浪费，我们可以创建一种缓存：物化视图。物化视图是查询结果的实际副本，并被写到磁盘，而虚拟视图只是用于编写查询的快捷方式。当底层数据发生变化时，物化视图也需要随之更新，因为它是数据的非规范化副本。数据库可以自动执行，但这种更新方式会影响数据写入性能，这就是为什么在OLTP数据库中不经常使用物化视图的原因。\n数据编码与演化 数据编码格式\n程序通常使用（至少）两种不同的数据表示形式：\n在内存中，数据保存在对象、结构体、列表、数组、哈希表和树等结构中。这些数据结构针对CPU的高效访问和操作进行了优化（通常使用指针）。 将数据写入文件或通过网络发送时，必须将其编码为某种自包含的字节序列（例如JSON文档）。由于指针对其他进程没有意义，所以这个字节序列表示看起来与内存中使用的数据结构大不一样。 因此，在这两种表示之间需要进行类型的转化。\n从内存中的表示到字节序列的转化称为编码（或序列化等），相反的过程称为解码（或解析，反序列化）。 语言特定的格式\n许多编程语言都内置支持将内存跌对象编码为字节序列。这些编码库使用起来非常方便，然后这里也有一些深层次的问题：\n编码通常与特定的编程语言绑定在一起，而用另一种语言访问数据就非常困难。 为了在相同的对象类型中恢复数据，解码过程需要能够实例化任意的类型。这经常导致一些安全问题。 在这些库中，多版本数据通常是次要的，主要目标是快速且简单地编码数据，所以它们经常忽略向前和向后兼容性等问题。 效率（编码或解码花费的CPU时间，以及编码结构的大小）通常也是次要的。 JSON、XML与二进制变体\n目标转向可由不同编程语言编写和读取的标准化编码，显然JSON和XML是其中佼佼者。CSV是另一种流行的与语言无关的格式，尽管功能较弱。\nJSON、xml和CSV都是文件格式，因此具有不错的可读性 它们一些微妙的问题\n数字编码有很多模糊之处。 JSON和XML对Unicode字符串（即人类可读文本）有很好的支持，但是它们不支持二进制字符串（没有字符编码的字节序列）。 JSON和XML都有可选的模式支持。 CSV没有任何模式，因此应用程序需要定义每行和每列的含义。如果应用程序更改添加新的行或列，则必须手动处理该更改。 二进制编码\n对于仅在组织内部使用的数据，使用二进制编码格式则较为顺畅。\nThrift与Protocol Buffers\nThrift与protocol Buffers都需要要模式来编码任意的数据。\n字段标签和模式演化\n模式不可避免地需要随着时间而不断变化，称之为模式演化。一条编码记录只是一组编码字段的拼接。每个字段由其标签号标识，并使用数据类型进行注释。如果没有设置字段值，则将其从编码的记录中简单地忽略。由此可以看出，字段标签（filed tag）对编码数据的含义至关重要。可以轻松更改模式中字段的名称，而编码永远不直接引用字段名称。但是不能随便更改字段的标签，它会导致所有现有编码数据无效。可以添加新的字段到模式，只要给每个字段一个新的标记号码。如果旧的代码（不知道添加的新标记号码）试图读取新代码写入的数据，包括一个它不能识别的标记号码中新的字段，则它可以简单地忽略该字段。实现时，通过数据类型的注释来通知解析器跳过特定的字节数。这样可以实现向前兼容性，即旧代码可以读取由新代码编写的记录。\n数据类型和模式演化\n如果改变字段的数据类型，已存在值会丢失精度或被截断的风险。\nAvro\nApache Avro是另一种二进制编码格式。 Avro也使用模式来指定编码的数据结构。它有两种模式语言：一种Avro IDL用于人工编辑，另一种基于JSON更易于机器读取。\n写模式与读模式\n模式解析通过字段名匹配字段。如果读取数据的代码遇到出现在写模式但不在上的字段，则忽略。如果读取数据的代码需要某个字段，但是写模式不包含该名称的字段，则使用在读模式中声明的默认值填充。\n模式演化规则\n使用Avro,向前兼容意味着可以将新版本的模式作为writer,并将旧版本的模式作为reader.相反，向后兼容意味着可以用新版本的模式作为reader, 并用旧版本的模式作为writer. 为了保持兼容性，只能添加或删除具有默认值的字段。在某些编程语言中，null是所有变量可以接受的默认值。但是在Avro中并非如些：如果要允许字段为null,则必须使用联合类型。例出:union{null, long, string}.只有当null是联合的分支之一时，才可以使用它作为默认值。\n动态生成的模式 代码生成和动态类型语言 模式的优点\n它们可以比各种“二进制JSON”变体更紧凑，可以省略编码数据中的字段名称。 模式是一种有价值的文档形式，因为模式是解码所必需的，所以可以确定它是最新的 模式数据库允许在部署任何内容之前检查模式更改的向前和向后兼容性。 对于静态类型编程语言的用户来说，从模式生成代码的能力是有用的，它能够在编译时进行类型检查。 数据流模式\n基于数据库的数据流\n不同时间写入不同的值\n数据库通常支持在任何时候更新任何值。这意味着在单个数据库中，可能有一些值是在5ms前写入的，而有一些值在5年前写入的。\n归档存储 基于服务的数据流：REST和RPC\n对于需要通过网络进行通信的进程，有多种不同的通信方式。面向服务/微服务体系结构的一个关键的设计目标是：通过使服务可独立部署和演化，让应用程序更易于更改和维护。\n网络服务\n有两种流行的web服务方法： REST和SOAP.\nRest\nrest不是一种协议，而是一个基于HTTP原则的设计理念。它强调简单工，使用URL来标识资源，并使用HTTP功能进行缓存控制、身份验证和内容类型协商。\nSOAP\nSOAP是一种基于XML的协议，用于发出网络API请求。\n远程过程调用（RPC）的问题 基于消息传递的数据流\n与直接RPC相比，使用消息代理的优点\n如果接收方不可用或过载，它可以充当缓冲区，从而提高系统的可靠性。 它可以自动将消息重新发送到崩溃的进程，从而防止消息丢失。 它避免了发送方需要知道的接收方的IP地址和端口号 它支持将一条消息发送给多个接收方。 它在逻辑上将发送方与接收方分离。 分布式数据系统 出于以下目的，我们需要在多台机器上分布数据：\n扩展性当数据量或者读写负载巨大，严重超出了单台机器的处理上限，需要将负载分散到多台机器上。 容错与高可用性 延迟 数据复制 复制主要指通过互联网络在多台机器上保存相同数据的副本。\n通过复制方案，通常希望达到以下目的\n使数据在地理位置上更接近用户，从而降低访问延迟 当部分组件出现故障，系统依然可以继续工作，从而提高可用性 扩展至多台机器以同时提供数据访问服务，从而搞读吞吐量 主节点与从节点\n主从复制的工作原理\n指定某一个副本为主副本（或称为主节点）。当客户写数据库时，必须将写请求首行发送给主副本，主副本首行将新数据定稿本地存储。 其他副本则全部称为从副本（或称为从节点）。主副本把新数据写入本地存储后，然后将数据更改作为复制的日志或更改流发送给所有从副本。每个从副本获得更改日志之后将其应用到本地，且严格保持与主副本相同的写入顺序。 客户端从数据库中读数据时，可以在主副本或者从副本上执行查询。 同步复制与异步复制 配置新的从节点\n逻辑上添加新节点的主要步骤\n在某个时间节点对主节点的数据副本产生一个一致性快照，这样避免长时间锁定整个数据库。 将此快照拷贝到新的从节点。 从节点连接到主节点并请求快照点之后所发生的数据更改日志。 获得日志之后，从节点来应用这些快照点之后所有数据变更。 处理节点失效\n从节点失效：追赶式恢复\n如果失效的是从节点，而且从节点还能重新启动连接，那么只需要从失效的最后一条事务追赶日志即可。\n从节点失效：节点切换\n如果失效的是主节点，需要选择某个从节点将其提升为主节点，客户端也需要更新，这样之后的写请求会发送给新的主节点，然后其他从节点要接受来自新的主节点上的变更数据。\n自动切换主节点的步骤\n确认主节点失效。 选举新的主节点。 重新配置系统使新主节点生效。 常见问题\n如果使用了异步复制，且失效前，新的主节点并未收到原主节点的所有数据，在选举之后，原主节点很快又重新上线并加入到集群，接下来的写操作时新的主节点很可能会收到冲突的写请求，这是因为原主节点未意识到角色的yoqx,还会深度同步其他从节点，但其中的一个现在已经接管成为现任主节点。常见的方案是，原主节点上未完成复制的写请求就此丢弃。 如果在数据库之外有其他系统依赖玗数据库的内容并在一起协同使用，丢弃数据的方案就特别危险。 在某些故障情况下，可能会发生两个节点同时都自认为是主节点。 如何设置合适的超时来检测主节点失效？主节点失效后，超时时间设置得越长也意味着总体恢复时间就越长。 复制日志的实现\n基于语句的复制\n主节点记录所执行的每个写请求并将该操作语句作为日志发送给从节点。\n不适用场景\n调用任何非确定性函数的语句，如now()。 如果语句中使用了自增列，或者依赖于数据库的现有数据，则所有副本必须按照完全相同的顺序执行，否则可能会带来不同的结果。 有副作用的语句，可能会在每个副本上产生不同的副作用。 基于预写日志（WAL）传输\n主要缺点是日志描述的数据结果非常底层：一个WAL包含了哪些磁盘块的哪些字节发生改变，诸如此类的细节。这使得复制方案和存储引擎紧密耦合。如果数据库的存储格式从一个版本改为另一个版本，那么系统通常无法支持主从节点上运行不同版本的软件。\n基于行的逻辑日志复制\n关系数据库的逻辑日志通常是指一系列记录来描述数据表行级别的写请求：\n对于行插入，日志包含所有相关列的新值。 对于行删除，日志里有足够的信息来唯一标识已删除的行，通常是靠主键，但如果表上没有定义主键，就需要记录所有列的旧值。 对于行更新，日志包含足够的信息来唯一标识更新的行，以及所有列的新值（或至少包含所有已更新列的新值）。 如果一条事务涉及多行的修改，则会产生多个这样的日志记录，并在后面跟着一条记录，指出该事务已提交。 MySQL的二进制日志binlog（当配置为基于行的复制时）使用该方式。由于逻辑日志与存储引擎逻辑解耦，因此可以更容易地保持向后兼容，从而使主节点能够运行不同版本的软件甚至是不同的存储引擎。\n基于触发器的复制\n基于触发器的复制通常比其他复制方式开销更高，也比数据库内置复制更容易出错，或者暴露一些限制。然而，其调度灵活性仍有用武之地。\n复制滞后问题\n如果一个应用正好从一个异步的从节点读取数据，而该副本落后于主切点，则应用可能会读到过期的信息。\n读自己的写\n基于主从复制的系统该如何实现写后读一致性？\n如果用户访问可能会被修改的内容，从主切点读取；否则，在从节点读取。 如果应用的大部分内容都可能被所有用户修改，那么上衣服针不太有效，它会导致大部分内容都必须经由主节点。 客户端还可以记住最近更新捍的时间戳，并附带在誌上，据此信息，系统可以确保对该用户提供读服务时都应该至少包含了该时间戳的更新。 如果副本分布在多数据中心，情况会照相结。必须先把请求路由到主节点所在的数据中心。 如果同一用户可能会从多个设备访问数据，情况会变得更加复杂，需要考虑更多的一些问题\n记住用户上次更新时间戳的方法实现起来会比较困难，因为在一台设备上运行的代码完全无法知道在其他设备上发生了什么。些时，元数据必须做到全局共享。 如果副本分布在多数据中心，无法保证来自不同设备的连接经过路由之后都到达同一个数据中心。 单调读\n单调读保证，如果某个用户依次进行多次读取，则他绝不会看到回滚现象，即在读取较新值之后又发生读旧值的情况。实现单调读的一种方式是，确保每个总是从固定的同一副本执行读取。\n前缀一致读\n如果数据库总是以相同的顺序写入，则读取总是看到一致的序列，不会发生逻辑混乱。然后，在许多分布式数据库中，不同的分区独立运行，因此不存在是全局写入顺序。这就导致当用记从数据库中读数据时，可能会看到数据库的某部分旧值和另一部分新值。一个解决方案是确保任何具有因果顺序关系的写入都交给一个分区来完成，但该方案真实实现效率会大打折扣。\n复制滞后的解决方案\n使用最终一致性系统时，最好事先京思考这样的问题：如果复制延迟增加到几分钟甚至几小时，那么应用层的行为会是什么样子？如果答案是“没问题”，那没得说。但是，如果带来糟糕的用户体验，那么在设计系统时，就要考虑提供一个更xkjr一致性保证，比如写后读。\n多主节点复制\n主从复制明显的缺点\n系统只有一个主节点，而所有写入都必须经过主节点。如果由于某种原因，例如与主节点之间的网络中断而导致主节点无法连接，主从复制方案就会影响所有的写入操作。\n适用场景\n在一个数据中心内部使用多主节点基本没有太大意义，其复杂性已经超过所能带来的好处。\n多数据中心\n在每个数据中心都配置主节点，在每个数据中心内，采用常规的主从复制议案而在数据中心之间，由各个数据中心的主节点来负责同其他数据中心的主节点进行数据的交换、更新。\n缺点\n不同的数据中心可能会同时修改相同的数据，因而必须解决潜在的写冲突。\n离线客户端操作\n另一种多主复制比较适合的场景是，应用在与网络断开后还需要继续工作。\n协作编辑 处理写冲突\n同步与异步冲突检测\n理论上，也可以做到同步冲突检测，即等待写请求完成所有副本的同步，然后再通知用户写入成功。但是，这样做将会失去多主节点的主要优势：允许每个主节点独立接受写请求。如果确实想要同步方式冲突检测，或许应该考虑采用单主节点的主从复制模型。\n避免冲突 收敛于一致状态\n实现收敛的冲突解决有以下可能的方式\n给每个写入分配唯一的ID。挑选最高ID的写入作为胜利者，并将其他写入丢弃。虽然这种方法很流行，但是很容易千万数据丢失。 为每个副本分配一个唯一的ID,并制定规则，例如序号高的副本写入始终优先于序号低的副本。这种方法也可能会导致数据丢失。 以某种方式将这些值合并在一起。 利用邓定义好的格式来记录和保留冲突相关的所有信息，然后依靠应用层的逻辑，事后解决冲突。 自定义冲突解决逻辑 拓扑结构\n最常见的拓扑结构是全部-全部，即每个主节点将其写入同步到其他所有主节点。还是环形拓扑，星形拓扑，星形拓扑还可以推到树状拓扑。\n无主节点复制\n客户端直接将其写请求发送到多副本。\n节点失效时写入数据库\n读修复与反熵\n复制模型应确保所有数据最终复制到所有的副本。当一个失效的节点重新上线之后，它如何赶上中间错过的那些写请求：\n读修复当客户端并行读取多个副本时，可以检测到过期的返回值。然后客户端判断最新的过期值，写入数据库。 反熵过程一些数据存储有后台进程不断查找副本之间数据的差异，将任何缺少的数据从一个副本复制到另一个副本。 读写quorum 监控旧值\n从运维角度来看，监视数据库是否返回最新结果非常重要。即使应用程序可以容忍读取旧值，也需要仔细复制的当前运行状态。如果已经出现了明显的滞后，它就是个重要的信号提醒我们需要采取必要措施来排查原因。对于主从复制的系统，数据库通常会导出复制滞后的相关指标，可以将其集成到统一监控模块。\n检测并发写\n最后写入者获胜（丢弃并发写入）\n需要确认哪个写入是最后的，可以为每个写入添加一个时间戳。\nHappens-before关系和并发 确定前后关系\n服务器判断操作是否并发的依据主要依靠对比版本号，而并不需要解释新旧值本身（值可以是任何数据结构）。算法的工作流程如下：\n服务器为每个主键维护一个版本号，每当主键新值写入时递增版本号，并将新版本号与写入的值一起保存。 当客户端读取主键时，服务器将返回所有（未被覆盖的）当前值以及最新的版本号。且要求写之前，客户必须先发送读请求。 客户端写主键，写请求必须包含之前读到的版本号、读到的值和新值合并后的集合。写请求的响应可以像读操作一样，会返回所有当前值。 当服务器收到带有特定版本号的写入时 ，覆盖该版本号或更低版本的所有值（因为知道这些值已经被合并到新传的值集合中），但必须保存更高版本号的所有值（因为这些值与当前的写操作属于并发）。 当写请求包含了前一次读取的版本号时，意味着修改的是基于以前的状态。如果一个写请求没有包含版本号，它将与所有其他写入同时进行，不会覆盖任何已民有值，其传入的值将包含在后续读请求的返回值列表当中。\n合并同时写入的值 版本矢量 数据分区 分区通常是这样定义的，即每一条数据（或者每条记录，每行或每个文档）只属于某个特定的分区。采用数据分区的主要目的是提高可扩展性。不同的分区可以放在一个无共享集群的不同节点上。这样一个大数据集可以分散在更锪磁盘上，查询负载也随之分布到时更多的处理器上。\n数据分区与数据复制\n分区通常与复制结合使用，即每个分区在多个节点都丰有副本。这意味着某条记录属于特定的分区，而同样的内容会保存在不同的节点上以提高系统的容错性。\n键值数据的分区\n分区的主要目标是将数据和查询负载均匀分布在所有节点上。\n基于关键字区间分区\n一种分区方式是为每个分区分配一段连续的关键字或者关键字区间范围。基于关键字的区间分区的缺点是某些访问模式会导致热点。\n基于关键字哈希值分区\n这种方式可以很好地将关键字均匀地分配到多个分区中。然而，通过关键字哈希进行分区，我们丧失了良好的区间查询特性。\n负载倾斜与热点 分区与二级索引\n二级索引是关系数据库的必备特性，在文档数据库中应用也非常普遍。但考虑到其复杂性，许多键-值存储并不支持二级索引； 但其他一些如Riak则开始患难夫妻二级索引的支持。此外，二级索引技术也是Solr和Elasticsearch等 全文索引服务器存在之根本。二级索引带来的主要挑战是它们不能规整的映射到分区中。有两种主要的方法来支持对二级索引进行分区：基于文档的分区和基于词条的分区。\n基于文档分区的二级索引\n在这种索引方法中，每个分区完全独立，各自维护自己的二级索引，且只负责自己分区内的文档而不关心其他分区中数据。\n基于词条二级索引分区\n这种方式，我们可以对所有的数据构建全局索引，而不是每个分区维护自己的本地索引。而且，为避免成为瓶颈，不能将全局索引存储在一个节点上，否则就破坏了设计分区均衡的目标。所以，全局索引也必须进行分区，且可以与数据关键字采用不同的分区策略。\n分区再平衡\n随着时间的失衡，数据库可能总会出现某些变化：\n查询原动力增加，因此需要更多的CPU来处理负载。 数据规模增加，因此需要更多的磁盘和内存来存储数据。 节点可能出现故障，因此需要其他机器来接管失效的节点。 这些变化都要求数据和请求可以从一个节点转移到另一个节点。这样一个迁移负载的过程称为再平衡。无论哪种分区方案，分区再平衡通常至少要满足：\n平衡之后，负载、数据存储、读写请求等应该在集群范围更均匀地分布。 再平衡执行过程中，数据库应该可以继续正常提供读写服务。 避免不必要的负载迁移，以加快动态再平衡，并尽量减少网络和磁盘IO影响。 动态再平衡的策略\n为什么不用取模\n对节点取模方法的问题是，如果节点数N发生了变化，会导致很多字需要从现有的节点迁移到另一个节点。\n固定数量的分区\n固定分区是创建远超实际节点数的分区数，然后为每个节点分配多个分区。不过每个分区也有些额外的管理开销，所以要根据实际情况选择分区总数。\n动态分区\n当分区的数据增长超过一个可配的参数阈值，它京拆分为两个分区，每个承担一半的数据量。相反，如果大量数据被删除，并且分区缩小到某个阈值以下，则将其与相信分区进行合并。该过程类似于B树的分裂操作。\n按节点比例分区\n使分区数与集群节点数成正比关系。每个节点具有固定数量的分区。当一个新节点加入集群时，它随机选择固定数量的现有分区进行分裂，然后拿走这些分区的一半数据量，将另一半数据留存原节点。随机选择分区边界的前提要求采用基于哈希分区。\n自动与手动再平衡操作\n全自动式再平衡会更加方便，它在正常维护之外所增加听操作很少。但是，也有可能出现结果难以预测的情况。再平衡总体讲是个比较昂贵的操作，它需要重新路由请求并将大量数据从一个节点迁移到另一个节点。万一执行过程中间出现异常，会使网络或节点的负载过重，并影响其他请求的性能。出于这样的考虑，让管理员介入到再平衡可能是个更好的选择。\n请求路由\n将数据集分布到多个节点后，我们需要考虑，当客户端需要发送请求时，如何知道应该连接哪个节点？如果发生了分区再平衡，分区与节点的对应关系随之还会变化。概括来讲，这是一个服务发现问题，这个问题有以下几种不同的处理策略：\n允许客户端连接任意的节点。如果节点恰好拥有所请求的分区，则直接处理该请求；否则，将请求转发到下一个合适的节点，接收答复，并将答复返回给客户端。 将所有端的请求都发送到一个路由层，由后者负责将请求转到对应的分区节点上。路由层本身不处理任何请求，它仅充当一个分区感知的负载均衡器。 客户端感知分区和节点分配关系。此时，客户端可以直接连接到目标节点，而不需要任何中介。 不管哪种方法，核心问题是：作出路由决策的组件如何知道分区与节点的对应关系以及其变化情况？\n并行查询执行 事务 事务是指将应用的多个读、写操作捆绑在一起成为一个逻辑操作单元。即事务中的所有读写是一个执行的整体，整个事务要么成功，要么失败。如果失败，应用程序可以安全地重试。\n深入理解事务\nACID的含义\nA Atomicity 原子性 C Consistency 一致性 I Isolation 隔离性 D Durability 隔离性 原子性\nACID中的原子性并不关税多个操作的并发性，它并没有描述多个线程试图访问相同的数据会发生什么情况，这是ACID的隔离性所定义。 ACID原子性其实描述了客户端发起一个包含多个写操作的请求时可能发生的情况；把多个写操作纳入到一个原子事务，万一出现了上述故障而导致没法完成最终提交时，则事务会中止，并且数据库须丢弃或撤销那些局部完成的更改。因此ACID中原子性所定义的特殊是：在出错时中止事务，并将部分完成的写入全部丢弃。也许可中止性比原子性更为准备，不过我们还是沿用原子性这个惯用术语。\n一致性\n一致性在不同场景有着不同的具体含义：\n副本一致性以及异步复制模型时，引出了最终一致性问题 一致性哈希则是某些系统用于动态分区再平衡的方法 CAP理论中，一致性一词用来表示线性化 而在ACID中，一致性主要指数据库处于应用程序所期待的“预期状态”。 ACID中的一致性的主要是指对数据有特定的预期状态，任何数据更改必须满足这些状态约束（或者恒等条件）。这种一致性本质上要求应用层来维护状态一致（或者恒等），应用程序有责任正确地定义事务来保持一致性。原子性，隔离性和持久性是数据库自身的属性，而ACID中的一致性更多是应用层的属性。应用程序可能借助数据库提供的原子性和隔离性，以达到一致性，但一致性本身并不源于数据库。\n隔离性\nACID主义中的隔离性意味着并发执行的多个事务相互隔离，它们不能互相交叉。经典的数据库教材把隔离定义为可串行化，这意味着可以假装它是数据库上运行的唯一事务。虽然实际上它们可能同时运行，但数据库系统要确保当事务提交时，其结果与品德执行完全相同。\n持久性\n持久性保证一旦事务提交成功，即使存在硬件故障或数据库崩溃，事务所写入的任何数据也不会消失。\n单对象与多对象事务操作\n单对象写入 多对象事务的必要性\n许多分布式数据存储系统不支持多对象事务，主要是因为当出现跨分区时，多对象事务非常难以正确实现，同时在高可用或者极致性能的场景下也会带来很多负面影响。的确有一些情况，只进行单个对象的插入、更新和删除就足够了。但是，还有许多其他情况要求写入多个不同的对象进行协调：\n对于关系数据模型，表中的某行可能是另一个表中的外键。类似地，在图数据模型中，顶点具有多个边链接到其他的顶点。多对象事务用以确保这些外键引用的有效性。 对于文档数据模型，如果待更新的字段都在同一个文档中，则可视为单个对象，此时不需要多对象事务。但是，缺少join支持的文档数据库往往会滋生反规范化，当更新这种非规范化数据时，就需要一次更新多个文档。 对于带有二级索引的数据库，每次更改值时都需要同步更新索引。从事务角度来看，这些索引是不同的数据库对象：如果没有事务隔离，就会出现部分索引更新。 处理错误与中止\n事务的一个关键特性是，如果发生的意外，所有操作被中止，之后可以安全地重试。ACID数据库基于这样的一个理念：如果存在违反原子性、隔离性或持久性的风险，则安全放弃整个事务，而不是部分放弃。重试中止的事务虽然是一个简单有效的错误处理机制，但它并不完美：\n如果事务实际已经执行成功，但返回给客户端的消息在网络传输时发生意外，那么重试就会导致重复执行，此时需要额外的应用级重复数据删除机制。 如果错误是由于系统超所导致，则重试事务将使情况变得更糟。为此，可以设定一个重试次数上限，例如指数回退，同时要尝试解决系统过载本身的问题。 由临时性故障所导致的错误需要重试。但出现了永久性故障，则重试毫无意义。 如果在数据库之外，事务还产生其他副作用，即事务被中止，这些副作用可能已事实生效。如果想要确保多个不同的系统同时提交或者放弃，可以考虑采用两阶段提交。 如果客户端进程在重试过程中也发生失败，没有其他人继续负责重试，则那些待写入的数据可能会因此而丢失。 弱隔离级别\n并发相关的错误很难通过测试发现，这类错误通常只在某些特定时刻才会触发，这种时机相关的问题发生概率低，稳定重现比较困难。实现隔离绝不是想象的那么简单。可串行化的隔离会严重影响性能，而许多数据库去函 愿意牺牲性能，因而更多倾向于采用较弱的隔离级别，它可以防止某些但并非全部的并发问题。\n读-提交\n读-提交是最基本的事务隔离级别，它只提供以下两个保证：\n读数据库时，只能看到已成功提交的数据（防止“脏读”）。 写数据时，只会覆盖已成功提交的数据（防止“脏写”）。 防止脏读\n假定某个事务已经完成部分数据写入，但事务尚未提交或中止，此时另一个事务是否要以看到沿未提交的数据呢？如果是的话，那就是脏读。当有以下需求时，需要防止脏读：\n如果事务需要更新多个对象，脏读意味着另一个事务可能会看到部分更新，而非全部。 如果事务发生中止，则所有写入操作都需要回滚。 防止脏写\n如果两个事务同时尝试更新相同的对象，不清楚写入顺序，但是可以想象后写的操作会覆盖较早的写入。但是，如果先前的写入是尚未提交事务的一部分，如果还被覆盖的话，就是脏写。读-提交隔离级别下所提交的事务可以防止脏写，通常的方式是推迟第二个写请求，直到前面的事务完成提交或中止。防止脏写可以避免以下并发问题：\n如果事务需要更新多个对象，脏写会带来非预期的错误结果。 但是，读-提交隔离并不能解决计数器增量的竞争情况。\n实现读-提交\n数据库通常采用行级锁来防止脏写：娄事务想修改某个对象时，它必须首先获取该对象的鎻；然后一直持有鎻到事务提交或中止。给定时刻，只有一个事务可以拿到特定对象的鎻，如果有另一个事务尝试更新同一个对象，则必须等待，直到前面的事务完成了提交或中止后，才能获得鎻并继续。要防止脏读，一种选择是使用相同的鎻，所有试图读取该对象的事务必须先申请鎻，事务完成后释放鎻。然而，读鎻的方式在实际中并不可行，因为运行时间较长的写事务会导致许多只读的事务等待太长时间，这会严重影响只读事务的响应延迟，县域可操作性差：由于读鎻，应用程序任何局部的性能问题会扩散进而影响整个应用，产生连锁反应。因此，大多数数据库采用，对于每个待更新的对象，数据库都会维护其旧值和当前持鎻事务将要设置的新值两个版本。在事务提交之前，所有其他读操作都读取旧值；仅当写事务提交之后，才会切换到读取新值。\n快照级别隔离与可重复读\n快照级别隔离可以防止不可重复读取或读倾斜。\n实现快照级别隔离\n为了实现快照级别隔离，考虑到多个正在进行的事务可能会在不同的时间点查看数据库状态，所以数据库保留了对象多个不同的提交版本，这种技术因此也被称为多版本并发控制（Multi-Version Concurrency Control MVCC）。\n一致性快照的可见性规则\n当事务读数据库时，通过事务ID可以决定哪些对象可见，哪些不可见。要想对上层应用维护好快照的一致性，需要精心定义数据的可见性规则。例如：\n每笔事务开始时，数据库列出所有当时尚在进行中的其他事务，然后忽略这些事务完成的部分写入，即不可见。 所有中止事务所做的修改全部不可见。 较晚事务ID所做的任何修改不可见，不管这些事务是否完成了提交。 除此之外，其他所有的写入都对应用查询可见。换句话说，仅当以下两个条件都成立，则该数据对象对事务可见： 事务开始的时刻，创建该对象的事务已经完成了提交。 对象没有被标记为删除；或者即使标记了，但删除事务在当前事务开始时还没有完成提交。 索引与快照级别隔离 可重复读与命名混淆 防止更新丢失\n更新丢失可能发生在这样一个操作场景中：应用程序从数据库读取某些值，根据应用逻辑做出修改，然后写回新值。当有两个事务在同样的数据对象上执行类似操作时，由于隔离性，第二个写操作并不包括第一个事务修改后的值，最终会导致第一个事务的修改值可能会丢失。这种冲突还可能在其他不同的场景下发生，例如：\n递增计数器，或更新账户余额。 对某复杂对象的一部分内容执行修改。 两个用户同时编辑wiki页面，且每个用户都尝试将整个页面发送到服务器，覆盖数据库中现有内容以使更改生效。 原子写操作\n许多数据库提供了原子更新操作，以避免在应用层代码完成“读-修改-写回”操作，如果支持的话，通常这就是最好的解决方案。原子操作通常采用对读取对象加独占鎻的方式来实现，这样在更新被提交之前不会其他事务可以读它。这种技术有时被称为游标稳定性。另一种实现方式是强制所有的原子操作都在单线程上执行。\n显式加鎻\n如果数据库不支持内置原子操作，另一种防止更新丢失的方法是由应用程序显式锁定待更新的对象。\n自动检测更新丢失\n原子操作和tjbj通过强制“读-修改-写回”操作序列串行扫行来防止丢失更新。另一种思路则是先让他们并发执行，但如果事务管理器检测到了更新丢失风险，则会中止当前事务，并强制回退到安全的“读-修改-写回”方式。\n原子比较和设置\n在不提供事务支持的数据库中，有时你会发现它们支持原子“比较和设置”操作。即只有在上次读取的数据没有发生变化时才允许下最新，如果已经发生了变化，则回退到“读-修改-写回”方式。\n冲突解决与复制\n对于支持多副本的数据库，防止丢失下最新还需要考虑另一个维度：由于多节点上的数据副本，不同的节点可能会并发修改数据，因此必须采取一些额外的措施来防止丢失下最新。\n写倾斜与幻读\n写倾斜可视为一种更广义的下最新丢失问题。即如果两个事务读取相同的一组对象，然后下最新其中一部分：不同事务可能下最新不同的对象，则可能发生写倾斜；而不同的事务如果下最新的是同一个对象，则可能发生脏写或更新丢失。对于写倾斜，可选的方案有很多限制：\n由于涉及多个对象，单对象的原子操作不起作用。 基于快照级别隔离来实现更新丢失自动检测也有问题。 某些数据库支持自定义约束条件，然后由数据库代为检查、执行约束。 如果不能使用可串行化级别隔离，一个次优的选择是对事务依赖的行来的加鎻。 串行化\n实际串行执行\n解决并发问题最直接的方法是避免并发。\n采用存储过程封装事务\n存储过程的优缺点\n每家数据库厂商都有自己的存储过程语言。 在数据库中运行代码难以管理。 因为数据库实例往往被多个应用服务器所共享，所以数据库通常比应用服务器要求更多的性能。数据库中一个设计不好的存储过程要比同样的应用服务器代码带来更大的麻烦。 存储过程与内存式数据存储使得单线程上报告所有事务变得可行。\n分区\n串行执行所有事务使得前功尽弃控制更加简单，但是数据库的吞量被限制在单机单个CPU核上。为了扩展到多个CPU核和多节点，可以对数据进行分区。如果你能找到一个方法来对数据集进行分区，使得单个事务只在单个分区内读写数据，这样每个分区都可以有自己的事务处理线程且独立运行。\n小结\n当满足以下约束条件时，串行执行可以实现串行化隔离：\n事务必须简短而高效。 仅限于活动数据集完全可以加载到内存的场景。 写入吞量必须足够低，才能在单个CPU核上处理；否则就需要采用分区，最好没有跨分区事务。 跨分区事务虽然也可以支持，但是占比必须很小。 两阶段加鎻\n两阶段加鎻，可以让多个事务同时读取同一对象，但只要出现任何写操作，则必须加鎻以独占访问：\n如果事务A已经读取了某个对象，此时事务B想要写入该对象，那么B必须等到A提交或中止之后才能继续。 如果事务A已经修改了对象，此时事务B想要读取该对象，则B必须等到A提交或中止之后才能继续。 实现两阶段加鎻\n如果事务要读取对象，必须先以共享模式获得鎻。可以有多个事务同时获得一个对象的共享鎻，但是如果某个事务已经获得了对象的独占鎻，则所有其他事务必须等待。 如果事务要修改对象，必须以独占模式获取鎻。不允许多个事务同时持有该鎻，换言之，如果对象上已被加鎻，则修改事务必须等待。 如果事务首行读取对象，然后尝试写入对象，则需要将共享鎻升级为独占鎻。 事务获得鎻之后，一直持有鎻直到事务结束。 两阶段加鎻的性能\n两阶段加鎻的主要缺点是性能：其事务吞吐量和查询响应时间相比于其他弱隔离级别下降了非常多。部分原因在于qimr获取和释放本身的开销，但更重要的是其降低了事务的并发性。\n可串行化的快照隔离\n悲观与乐观的并发控制\n相比于两阶段加鎻，可串行化的快照隔离则是一种乐观并发控制。在这种情况下，如果可能发生潜在冲突，事务会继续执行而不是中止，寄希望一切相安无事；而当事务提交时，数据库会检查是否确实发生了冲突，如果是的话，中止事务并接下来重试。\n基于过期的条件做决定 检测是否读取了过期的MVCC对象\n当事务提交时，数据库检查是否存在一些当初被忽略的写操作现在已经完成了提交，如果是则必须中止当前事务。\n检测写是否影响了之前的读 可串行化快照隔离的性能\n与两阶段加鎻相比，可串行化快照隔离的一大优点是事务不需要等待其他事所持有的鎻。这一点和快照隔离一样，读写通常不会互相阻塞。这样的设计使得查询延迟更加稳定、可预测。与串行执行相比，可串行化快照隔离可以突破单个CPU核的限制。需要指出，事务中止比例会显著影响SSI的性能表现。\n分布式系统的挑战 故障和部分失效\n单台节点上的软件通常不应该出现模棱两可的现象，一个合格的软件状态要么是功能正常，要么是完全失效，而不会介于两者之间。在分布式系统中，可能会出现系统的一部分工作正常，但其他某些部分出现难以预测的故障，我们称之为“部分失效”。问题的难点在于这种部分失效是不确定的。正是因为这种不确定性和部分失效大大提高了分布式系统的复杂性。\n云计算和超算\n构建大规模计算系统有以下几种不同的思路：\n高性能计算（HPC），包含成千上万个CPU的超级计算机构成一个庞大的集群。 另一个极端是云计算。 企业数据中心则位于以上两个极端之间。 不可靠网络\n发送请求之后等待响应过程中，有很多事情可能会出错\n请求可能已经丢失 请求可能正在某个队列中等待，无法马上发送 远程接收节点可能已经失效 远程接收节点可能暂时无法响应 远程接收节点已经完成了请求处理，但回复却在网络中丢失 远程接收节点已经完成了请求处理，但回复却被延迟处理 处理这些问题通常采用超时机制，在等待一段时间之后，如果仍然没有收到回复则选择放弃，并且认为响应不会到达。\n现实中的网络故障\n处理网络故障并不意味着总是需要复杂的容错措施：一种简单的方法是对用户提示错误信息。但前提是，必须非常清楚接下来软件会如何应对，以确保系统最终可以恢复。\n检测故障\n许多系统都需要自动检测节点失效这样的功能。\n超时与无限期的延迟\n如果超时是故障检测唯一可串行的方法，那么超时应该设多长呢？不幸的是没有标准答案。\n网络拥塞与排队\n计算机网络上的数据包延迟的变化根源往往在于排队：\n当多个不同节点册时发送数据包到相同的目标节点时。 当数据包到达目标机器drgk,如果所有CPU核都牌繁忙状态。 在虚拟化环境下，CPU核会切换虚拟栅，从而导致正在运行的操作系统会突然暂停几十毫秒。 TCP执行流量控制。 同步与异步网络 不可靠时钟\n单调时钟与墙上时钟\n墙上时钟\n根据某个日历返回当前的日期与时间。墙上时钟可以与NTP同步。\n单调时钟\n更适合测量持续时间段。\n时钟同步与准确性\n单调时钟不需要同步，但是墙上时钟需要根据NTP服务器或其他外部时间源做必要的调整。\n依赖同步的时钟\n时间戳与事件顺序 时钟的置信区间 全局快照的同步时钟 进程暂停\n响应时间保证\n在一些软件系统中，软件有一个必须做出响应的上限：如果无法满足，会情致系统级故障，这就是的硬实时系统。提供实时保证需要来自软件栈的多个层面的支持：首先是一个实时操作系统，保证进程在给定的时间间隔内完成CPU时间片的调度分配；其次，库函数也必须考虑最坏的执行时间；然后，动态内存分配很可能要受限或者完全被禁止；最终还是需要大量、充分的测试和验证，以确保满足要求。\n调整垃圾回收的影响 知识，真相与谎言\n真相由多数决定\n节点不能根据自己的信息来判断自身的状态 。分布式系统不能完全依赖于单个节点。目前，许多分布式算法都依靠法定票数，即在节点之间进行投票。任何决策都需要来自多个节点的最小投票数，从而减少对特定节点的依赖。最常见的法定票数是取系统节点半数以上。\n主节点与鎻\n有很多情况，我们需要在系统范围内只能有一个实例，例如：\n只允许一个节点作为数据库分区的主节点，以防止出现脑裂。 只允许一个事务或客户端持有特定资源的鎻，以防止同时写入从而导致数据破坏。 只允许一个用户来使用特定的用户名，从而确保用户名可以唯一标识用户。 Fencing令牌\n当使用鎻和租约机制来保护资源的并发访问时，必须确保过期的“唯一的那个”节点不能影响其他正常部分。要实现这一目标，可以采用一种相当简单的技术fencing(栅栏，隔离之意)。我们假设每次锁服务在授予鎻或租约时，还会同时返回一个fencing令牌，该令牌每授予一次都会递增。然后，要求客户端每次向存储系统发送写请求时，都必须包含所持有的fencing令牌。\n拜占庭故障\n如果某个系统中即使发生部分节点故障，甚至不遵从协议，或者恶意攻击、干扰网络，但仍可继续正常运行，那么我们称之为拜占庭式容错系统。\n弱的谎言形式\n尽管我们假设节点通常是诚实的，但依然推荐增加必要的机制来防范一些不那么恶意的“谎言”。例如由于硬件问题千万的无效消息、软件BUG和配置错误。\n理论系统模型与现实\n关于计时方面，有三种常见的系统模型：\n同步 部分同步 异步 三种常见的节点失效系统模型：\n崩溃-中止模型 崩溃-恢复模型 拜占庭失效模型 算法正确性\n为了定义算法的正确性，我们可以描述它的属性令牌。\n安全与活性\n安全性通常可以理解为“没有发生意外”，而活性则类似“预期的事情最终一定会发生”。\n将系统模型映射到现实世界\n证明算法正确工不意味着真实系统上的某个具体实现一定是正确的。\n一致性与共识 一致性保证 可线性化\n可线性化基本想法是让一个系统看起来好像只有一个数据副本，且所有的操作都是原子的。在一个可线性化的系统中，一旦某个客户端成功提交写请求，所有客户端的读请求一定都能看到刚刚写入的值。\n如何达到线性化 线性化的依赖条件\n加鎻与主节点选举\n主从复制的系统需要确保有且只有一个主节点，否则会产生脑裂。选举新的主节点常见的方法是使用鎻：即每个启动的节点都试图获得鎻，其中只有一个可以成功即成为主节点。\n约束与唯一性保证\n研发的唯一性约束，常见如关系型数据库中主键的约束，则需要线性化保证。其他如外键或属性约束，则并不需要一定线性化。\n跨通道的时间依赖\n线性化违例之所以被注意到，是因为系统中存在其他的通信渠道。\n实现线性化系统\n系统容错最常见的方法就是采用复制机制。\n主从复制：部分支持可线性化 共识算法：可线性化 多主复制（不可线性化） 无主复制：可能不可线性化 线性化与quorum\n最安全的假定是类似Dynamo风格的无主复制系统无法保证线性化。\n线性化的代价\nCAP理论\n如果应用要求线性化，但由于网络方面的问题，某些副本与其他副本断开连接后无法继续处理请求，就必须等待网络修复，或者直接返回错误。无论哪种方式，结果是服务不可用。 如果应用不要求线性化，那么断开连接之后，每个副本可独立处理请求例如写操作（多主复制）。此时，服务可用，但结果行为不符合线性化。 可线性化与网络延迟\n虽然线性化是个很有用的保证，但实际上很少有系统真正满足线性化。如果想要满足线性化，那么读、写请求的响应时间至少要与网络中延迟成正比。考虑到多数计算机网络高度不确定的网络延迟，线性化冠以写的性能势必非常差。虽然没有足够快的线性化算法，但弱一致性模型的性能则快得多，这种聚会对于延迟敏感的系统非常重要。\n顺序保证\n顺序与因果关系\n因果关系对所发生的事件施加了某种排序，因果关系的依赖链条定义了系统跌因果顺序，即某件事应该发生另一件事情之前。如果系统服从因果关系所规定的顺序，我们称之为因果一致性。\n因果顺序并非全序\n全序关系支持任何两个元素之间进行比较，即对于任意两个元素，总是可以指出哪个更大，哪个更小。在一个可线性化的系统中，存在全序操作关系。在可线性化数据存储中不存在并发操作，一定有一个时间线将所有操作都全序执行。可能存在多个请求牌等待处理的状态，但是数据存储保证了在特定的时间点执行特定的操作，所以是单个时间轴，单个数据副本，没有并发。\n可线性化强于因果一致性\n任何可线性化的系统都将正确地保证因果关系。\n捕获因果依赖关系\n当事务提交时，数据库要检查事务读取的数据版本现在是否仍是最新的。为些，数据库需要跟踪事务读取了哪些版本的数据。\n序列号排序\n虽然因果关系很重要，但实际上口口口敁所有的因果关系不切实际。这里还有一个更好的方法：我们可以使用序列号或时间戳来排序事件。\n非因果序列发生器\n如果系统不存在这样唯一的主节点，如何产生序列号就不是那么简单了。在实中中可以采用以下方法：\n每个节点都独立产生自己的一组序列号。还可以在序列号中保留一些位物于嵌入所属节点的唯一标识符，确保不同的节点户均不会生成相同的序列号。 可以把墙上时间戳信息附加到每个操作上。 可以预告分配序列号的区间范围。 上述三种思路都可行，相比于把所有请求全部压给唯一的主节点具有更好的扩展性。它们为每个操作生成一个唯一的、挖增加的序列号。不过，它们也都存在一个问题：所产生的序列号与因果关系并不严格一致。所有这些序列号发生器都无法保证正确捕获跨节点操作的顺序，因而存在因果关系方面的问题：\n每个节点可能有不同的处理速度。 物理时钟的时间戳会受到时钟偏移的影响，也可能导致与实际因果关系不一致。 对于区间分配器，一个操作可能被赋予1001-2000之之之间的某个序列号，而后发生的操作则路由到另一个节点，拿到了某个1-1000之间的序列号，导致与因果关系不一致。 Lamport时间戳\n还有一个简单的方法可以产生与因果关系一致qkgn.它被称为兰伯特时间戳（Lamport timestamp）。 Lamport时间戳与物理墙上时钟并不存在直接对应关系，但它可以保证全序：给定两个Lamport时间戳，计数器较大的那个时间戳大；如果计数器值正好相同，则节点ID越大，时间戳越大。 Lamport时间戳的核心亮点在于使它们与因果性保持一致，具体如下：每个节点以及每个客户端都跟踪迄今为止所见到的最大计数器值，并在每个请求中附带该最大计数器值。当节点收到 某个请求（或者回复）时，如果发现请求内嵌的最大计数器值大于节点自身的计数器值，则它立即把自己的计数器修改为该最大值。只要把最大计数器值嵌入到每一个请求中，该方案可以确保Lamport时间戳与因果关系一致，而请求的因果依赖性一定会保证最后发生的请求得到更大的时间戳。\n时间戳排序依然不够 全序关系广播\n全序关系广播通常指节点之间交换消息的某个协议。下面是一个非正式的定义，它要求满足两个基本安全属性：\n可靠发送没有消息丢失，如果消息发送到某一个节点，则它一定要发送到所有节点。 严格有序消息总是以相同的顺序发送给每个节点。 使用全序关系广播\n全序关系广播另一个要点是顺序在发送消息时已经确定，如果消息发送成功，节点不允许追溯地将某条消息插入到先前的某个位置上。理解全序关系广播的另一种方式是将其视为日志。\n采用全序关系广播实现线性化存储\n全序关系广播是基于异步模型：保证消息以固定的顺序可靠地发送，但是不保证消息何时发送成功（因此某个接收者可能明显落后于其他接收者）。而可线性化则强调就近性：读取时保证能够看到最新的写入值。\n采用线性化存储实现全序关系广播\n与Lamport时间戳不同，通过递增线性化寄存器获得的数字不会存在任何间隙，如果节点完成了消息4的发送，且接收到了序列化6的消息，那么它对消息6回复之前必须等待消息5.Lamport时间戳则不是这样，而这也是区别全序关系广播与基于时间戳排序的关键。\n分布式事务与共识\n共识问题是分布式计算中最重要也是最基本的问题之一。\n","permalink":"https://stoneepigraph.github.io/posts/ddia/","title":"DDIA"},{"content":" 计算机系统漫游 信息就是位+上下文 程序被其他程序翻译成不同的格式 hello程序的生命周期是从一个高级C语言开始的，因为这种形式能够被人读懂。然而，为了在系统上运行hello.c程序，每条C诗句都必须被其他程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为可执行目标程序的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为可执行目标文件。\n了解编译系统如何工作是大有益处的 优化程序性能 理解链接时出现的错误 避免安全漏洞 处理器读并解释储存在中的指令 系统的硬件组成 总线 I/O设备 主存 处理器\n加载 存储 操作 跳转 高速缓存至关重要 存储设备形成层次结构 在处理器和一个较大较慢的设备（例如主存）之间插入一个更小更快的存储设备（例如高速红艳艳）的想法已经成为一个普通的观念。实际上，每个计算机系统中的存储设备都被组织成了一个存储器层次结构，在这个层次结构中， 从上至下，设备的访问速度起来越慢，容量越来越大，并且每字节的造价也越来越便宜。\n操作系统管理硬件 所有应用程序对硬件的操作深度都必须通过操作系统。\n操作系统有两个基本功能 防止硬件被失控的应用程序滥用 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。 操作系统通过几个基本的抽象概念来实现这两个功能 进程进程则是对处理器、主存和I/O设备的抽象表示。 虚拟内存虚拟内存是对主存和磁盘I/O设备的抽象表示 文件文件是对I/O设备的抽象表示 进程 线程 虚拟内存\n虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。在Linux中，地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都是一样。地址空间的底部区域存放用户进程定义的代码和数据。注意，地址是从下往上增大的。从下往上依次是：\n程序代码和数据。 堆 共享库 栈 内核虚拟内存 文件\n文件就是字节序列，每个I/O设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件。\n系统之间利用网络通信 程序结构和执行 信息的表示和处理 信息存储 十六进制表示法 字数据大小 寻址和字节顺序\n大端法小端法\n表示字符串\nC语言中字符串被编码为一个以null(其值为0)字符结尾的字符数组。每个字符都同某个标准编码来表示，最常见的是ASCII字符码。\n表示代码 布尔代数简介\n二进制值是计算机编码、存储和操作信息的核心，所以围绕数值0和1的研究已经深化出了丰富的数学知识体系。被称作布尔代数。\nC语言中的位级运算\n| \u0026amp; ^ C语言中的逻辑运算\n类型\n|| \u0026amp;\u0026amp; ! 与位级运算的区别\n逻辑运算认为所有非零的参数都表示TRUE，而参数0表示FALSE 逻辑运算符\u0026amp;\u0026amp;和||与它们对应的位级运算\u0026amp;和|之间第三个重要的区别是，如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。 C语言中的移位运算\n类型\n\u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; 整数表示 一些术语 符号 类型 含义 B2T_w 函数 二进制转补码 B2U_w 函数 二进制转无符号数 U2B_w 函数 无符号数转二进制 U2T_w 函数 无符号转补码 T2B_w 函数 补码转二进制 T2U_w 函数 补码转无符号数 TMin_w 常数 最小补码值 TMax_w 常数 最大补码值 UMax_w 常数 最大无符号数 +^t_w 操作 补码加法 +^u_w 操作 无符号数加法 *^t_w 操作 补码乘法 *^u_w 操作 无符号乘法 -^t_w 操作 补码取反 -^u_w 操作 无符号取反 整数数据类型\nC语言支持多种整形数据类型——表示有限范围的整数。每种类型都能用关键字来指定大小，这些关键字包括char、short、long，同时还可以指示被表示的数字是非负数(声明为unsigned),歌者可能是负数（默认）。\n无符号数的编码 补码编码\n最常见的有符号数的计算机表示方式誻补码形式。在这个定义中，将字的最高有效位解释为负权。补码的范围是不对称的： |TMin| = |TMax| + 1, 也就是说，TMin没有与之对应的正数。最大的无符号数值刚好比补码的最大值的两倍大一点： UMax = 2TMax + 1。 C语言标准并没有要求要用补码形式来表示有符号整数，但是几乎所有的机器都是这么做的。 C库中的文件 \u0026lt;limits.h\u0026gt;定义了一组常量，来限定编译器运行的这台机器的不同整形数据类型的取值范围。 ISOC99标准在文件stdint.h中引入了这个整数类型类。这个文件定义了一组数据类型，它们的声明形式如intN_t和uintN_t,对应不同的N值指定N位有称号和无符号整数。关于整数数据类型的范围和表示，Java标准是非常明确的。它要求采用补码表示。在Java中，单字节数据类型称为byte,而不是char。这些非常具体的要求都是为了保证无论在什么机器上运行，Java程序都能表现地完全一样。\n有符号数和无符号数之间的转换\nC语言允许在各种不同的数字数据类型之间做强制类型转换。对于大多数C语言的实现，处理同样字长的有符号数和无符号数之间的转换的一般规则是：数值可能会改变，但是位模式不变。\nC语言中的有符号数与无符号数\nC语言支持所有整形数据类型的有符号和无符号运算。尽管C语言标准i同有指定有符号数要采用某种表示，但是几乎所有的机器都使用补码。 C语言允许无符号数和有符号数之间的转换。虽然C标准没有精确规定应如何进行这种转换，但大多数系统遵循的原则是底层的位表示保持不变。另外，当一种类型的表达式被赋值给另外一种类型的变量时，转换是隐式发生的。\n扩展一个数字的位表示 截断数字 关于有符号数与无符号数的建议 整数运算 无符号加法\n当执行C程序时， 不会将溢出作为错误而发信号。不过有的时候，我们可能希望判定是否发生的溢出。\n补码加法 补码的非\n对于w位的补码加法来说， TMin是自己的加法的逆，而对其他任何数值x都有-x作为基加法的逆。\n无符号乘法\nC语言中的无符号乘法被定义为产生w位的值，就是2w位的整数税种的低w从头再来表示的值。\n补码乘法 乘以常数\n由于整数乘法比移位和加法的代价要大得多，许多C语言编译器试图以移位、加法和减法的组和来消除很多整数乘以常数的情况。\n除以2的幂\n除以2的幂也可以用移位运算来实现，只不过我们用的是右移，而不是左移。\n关于整数运算的最后思考 浮点数 浮点数表示对形如V=x*2^y的有理数进行编码。它对执行涉及非常大的数字、非常接近于0的数字，以及更普遍地作为实数运算的近似值的计算，是很有用的。\n二进制小数\n数字权的与十进制的小数点符号相关，这意味着小数点左边的数字的权是10的正幂，得到整数值，而小数点右边的数字的权是10的负幂，得到小数值。假定我们公考虑有限长度的编码，那么十进制表示法不能准确地表达像三分之一这样的数。类似，小数的二进制表示法只能表示那些能够被写成x*2^y的数。其他的值只能够被近似的表示。\nIEEE浮点表示\nIEEE浮点标准用V=(-1)^s*M*2^E的形式来表示一个数\n符号sign: s决定这个ovtj是负数还是正数 尾数significand M是一个二进制小数 阶码 exponent E的作用是对浮点数加权，这个权重是2的E次幂（可能是负数）。 表示的数值类型\n规格化的值这是最普遍的情况，当exp的位模式既不全为0,也不全为1 非规格化的值当阶码哉为全0时 特殊值当阶码全为1的时候。当小数域全为0时，得到的值表示无穷，当s=0时是正无穷，当s=1时为负无穷。 数字示例 舍入\n因为表示方法限制了浮点数的范围和精度，所以浮点运算只能挖地表示实数运算。因此，对于值x,我们一般想用一种系统的方法，能够找到“最接近的”匹配值x\u0026rsquo;，它可以用期望的浮点形式表示出来。这就是舍入运算的任务。\n浮点运算\n浮点加法不具有结合性。激战加法满足了单调性。\nC语言中的浮点数\n所有的C语言版本提供了两种不同的浮点数据类型:float和double。\n当int, float和double格式之间进行强制类型转换时，程序改变数值和位模式的原则如下（假设int是32位的）\n从int转换成float,数字不会溢出，但是可能被舍入。 从int或float转换成double,因为double有更大的范围，也有更高的精度，所以能够保留精确的数值。 从double转换成float,因为范围要小一些，所以值可能溢出成正无穷或负无穷。另外，由于精确度较小，它还可能被舍入。 从float或者double转换成int,值将会向零舍入。例如1.99将被转换成1,而-1.99将被转换成-1。 程序的机器级表示 程序编码 机器级代码\n汇编代码表示非常接近于机器代码。与机器代码的二进格式相比，汇编代码的主要特点是它用可读性更好的文本格式表示。一条机器指令只执行一个基本的操作。\n示例\n查看C语言编译器产生的汇编代码 gcc -Og -S filename.c 汇编代码 gcc -Og -c filename.c 生成可执行文件 gcc -Og -p prog file1.c file2.c 反汇编 objdump -d program.o 关于格式的注解\ngcc产生的汇编代码中所有以.形状的行都是指导汇编器和链接器工作的伪指令。我们通常可以忽略这些行。\n数据格式 由于是从16位体系结构扩展成32位的，Intel用术语“字（word）”表示16位数据类型。因此，称32位数为“双字（double word）”， 64位数为“四字（quad word）”\nC声明 Intel数据类型 汇编代码后缀 大小（字节 char 字节 b 1 short 字 w 2 int 双字 l 4 long 四字 q 8 char* 四字 q 8 float 单精度 s 4 double 双精度 l 8 大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如：数据传送指令有四个变种：movb, movw, movl, movq\n访问信息 一个x86-64的CPU包含一组16个存储64位值的通用目的寄存器。这些寄存器用来存储整数数据和指针。整数寄存器。所有16个寄存器的低位部分都可以作为字节、字（16位）、双字（32位）和四字（64位）数字来访问。\n63 31 15 7 0 %rax %eax %ax %al 返回值 %rbx %ebx %bx %bl 被调用者保存 %rcx %ecx %cx %cl 第4个参数 %rdx %edx %dx %dl 第3个参数 %rsi %esi %si %sil 第2个参数 %rdi %edi %di %dil 第1个参数 %rbp %ebp %bp %bpl 被调用者保存 %rsp %esp %sp %spl 栈指针 %r8 %r8d %r8w %r8b 第5个参数 %r9 %r9d %r9w %r9b 第6个参数 %r10 %r10d %r10w %r10b 调用者保存 %r11 %r11d %r11w %r11b 调用者保存 %r12 %r12d %r12w %r12b 被调用者保存 %r13 %r13d %r13w %r13b 被调用者保存 %r14 %r14d %r14w %r14b 被调用者保存 %r15 %r15d %r15w %r15b 被调用者保存 对于生成小于8字节结果的指令，寄存器中剩下的字节会怎样，对此有两条规则 生成1字节和2字节数字的指令会保持剩下的字节不变。 生成4字节数字的指令会把高4个字节置0. 操作数指示符\n大多数指令有一个或多个操作数(operand)，指示出执行一个操作中要使用的源数据值，以及旋转结果的目的位置。\n各种不同的操作数的可能性被分为三种类型。 立即数(immediate): 用来表示常数值在ATT格式的汇编代码中，立即数的书写方式是$后面跟一个用标准C表示法表示的整数。不同的指令允许的立即数值范围不同，汇编器会自动造势最紧凑的方式进行数值编码。 寄存器(register): 它表示某个寄存器的内容 16个寄存器的低位1字节，2字节，4字节，8字节中的一个作为操作数，这些字节数分别对应于8位，16位，32位，64位。我们使用rN来表示任意寄存器N,用引用R[rN]来表示它的值，这是将寄存器集合看成一个数组R. 内存引用它会根据计算出来的地址访问某个内存位置。我们使用Mb[Addr]表示对存储在内存中从地址Addr开始的b个字节值的引用。 寻址模式有多种不同的寻址模式，允许不同形式的内存引用。下表中Imm(r_b,r_i, s)表示的是最常用的形式。这样的引用有四个组成部分： 一个立即数偏移Imm,一个基址寄存器r_b,一个变址寄存器r_i和一个比例因子s,这里s必须是1,2,4或者8。基址和变址寄存器都必须是64位寄存器。有效地址被计算为Imm+R[r_b] + R[r_i] * s。操作数模式 类型 格式 操作数值 名称 立即数 $Imm Imm 立即数寻址 寄存器 r_a R[r_a] 寄存器寻址 存储器 Imm M[Imm] 绝对寻址 存储器 (r_a) M[R[r_a]] 间接寻址 存储器 Imm(r_b) M[Imm+R[r_b]] （基址+偏移量）寻址 存储器 (r_b, R_i) M[R[r_b] + R[r_i]] 变址寻址 存储器 Imm(r_b, r_i) M[Imm+R[r_b] + R[r_i]] 变址寻址 存储器 (,r_i,s) M[R[r_i] * s] 比例变址寻址 存储器 Imm(,r_i, s) M[Imm + R[r_i] * s] 比例变址寻址 存储器 (r_b, r_i, s) M[R[r_b] + R[r_i] * s] 比例变址寻址 存储器 Imm(r_b, r_i, s) M[Imm + R[r_b] + R[r_i] * s] 比例变址寻址 数据传送指令\n源操作数指定的值是一个立即数，存储在寄存器中或者内存中。目的操作紵个位置，要么是一个寄存器，要么是一个内存地址。 x86-64加了一条限制，传送指令的两个操作数不能都指向内存地址。大多数情况下，MOV指令只会更新目的操作数指定的那些寄存器字节或内存位置。唯一例外的是movl指令以寄存器作为目的时，它会把该寄存器高位4字节设置为0。\n指令 效果 描述 MOV s, D D \u0026lt;- S 传送 movb 传送字节 movw 传送字 movl 传送双字 movq 传送四字 movabsq I, R R \u0026lt;- I 传送绝对的四字 MOV指令的一种可能的组合。第一个是源操作数，第二个是目的操作数。 movl $0x4050, %eax Immediate - Register, 4 bytes movw %bp, %sp Register - Register, 2bytes movb (%rdi, %rcx), %al Memory - Register, 1byte movb $-17, (%rsp) Immediate - Memory, 1byte movq %rax, -12(%rbp) Register - Memory, 8bytes 将较小的源值复制到较大的目的指令\nMOVZ类\n指令会把目的中简便的字节填充为0\n指令 效果 描述 MOVZ S, R R \u0026lt;- 零扩展(S) 以零扩展进行传送 movzbw 将做了零扩展的字节传送到字 movzbl 将做了零扩展的字节传送双字 movzwl 将做了零扩展的字传送到双字 movzbq 将做了零扩展的字节传送到四字 movzwq 将做了零扩展的字传送到四字 MOVS\n指令通过符号扩展来填充，把源操作的最高位进行复制。\n指令 效果 描述 MOVS S,R R \u0026lt;- 符号扩展（S） 传送符号扩展的字节 movsbw 将做了符号扩展的字节传送到字 movsbl 将做了符号扩展的字节传送到双字 movswl 将做了符号扩展的字传送到双字 movsbq 将做了符号扩展的字节传送到四字 movswq 将做了符号扩展的字传送到四字 movslq 将做了符号扩展的双字传送到四字 cltq %rax \u0026lt;- 符号扩展(%eax) %eax符号扩展到%rax 压入和弹出栈数据\n栈指针%rsp保存着栈顶元素的地址。\n指令 效果 描述 pusq S R[%rsp] \u0026lt;- R[%rsp] - 8; M[R[%rsp]] \u0026lt;- S 将四字压入栈 popq D D \u0026lt;- M[R[%rsp]]; R[%rsp] \u0026lt;- R[%rsp] + 8 将四字弹出栈 算术和逻辑操作 整数算术和逻辑操作，大多数操作都分成了指令类，这些指令类有各种带不同大小操作数的变种（只有lead没有其他大小的变种）。这些操作被分为四组：加载有效地址，一元操作，二元操作和移位。\n指令 效果 描述 leaq S,D D \u0026lt;- \u0026amp;S 加载有效地址 INC D d \u0026lt;- d + 1 加1 DEC D D \u0026lt;- D - 1 减1 NEG D D \u0026lt;- -D 取负 NOT D D \u0026lt;- ~D 取补 ADD S,D D \u0026lt;- D + S 加 SUB S,D D \u0026lt;- D - S 减 IMUL S,D D \u0026lt;- D * S 乘 XOR S,D D \u0026lt;- D ^ S 异或 OR S,D D \u0026lt;- D 或 S 或 AND S,D D \u0026lt;- D \u0026amp; S 与 SAL K,D D \u0026lt;- D \u0026lt;\u0026lt; K 左移 SHL K,D D \u0026lt;- D \u0026lt;\u0026lt; K 左移（等同于SAL） SAR K,D D \u0026lt;- D \u0026gt;\u0026gt; K 算术右移 SHR K,D D \u0026lt;- D \u0026gt;\u0026gt;\u0026gt; K 逻辑右移 加载有效地址\n加载有效地址leaq实际上是movq指令的变形。它的指令形式是从内存读数据到寄存器但实际上它根本就没有引用内存。它的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数。\n一元和二元操作\n第二组中的操作是一元操作，只有一个操作数，既是源又是目的。这个操作数可以是一个寄存器，也可以是一个内存位置。第三组是二元操作，其中，第二个操作数既是源又是目的。不过，要注意，源操作数是第一个 ，目的操作数是第二个。第一个操作数可以是立即数、寄存器或是内存位置。第二个操作数可以是寄存器或是内存位置。注意，当第二个操作数为内存地址时，处理器必须从内存读出值，执行操作，再把结果写回内存。\n移位操作\n最后一组是移位操作，先给出移位量，然后第二项给出的是要移位的数。\n说明\n算术和逻辑操作的大多数指令，既可以用于无符号运算，也可以用于补码运算。只有右移操作要求区分有符号和无符号数。\n特殊的算术操作\n两个64位有符号整数相乘得到的乘积需要128位来表示。x86-64指令对128位（16字节）数的操作提供有限的支持。Intel把16字节的数称为八字（oct word）。支持产生两个64位数字的全128位税种以及整数除尘的指令如下：\n指令 效果 描述 imulq S R[%rdx]: R[%rax] \u0026lt;- S * R[%rax] 有符号全乘法 mulq S R[%rdx]: R[%rax] \u0026lt;- S * R[%rax] 无符号全乘法 clto R[%rdx]: R[%rax] 符号扩展（R[%rax]） 转换为八字 idivq S R[%rdx] \u0026lt;- R[%rdx]: R[%rax] mod S 有符号除法 divq S R[%rdx] \u0026lt;- R[%rdx]: R[%rax] mod S 无符号除法 控制 条件码\n除了整数寄存器，CPU还维护着一组单个位的条件码（condition code）寄存器，它们描述了最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。最常见的条件码有：\nCF：进位标志。阳近的操作使最高位产生了进位。可用来检查无符号操作的溢出。 ZF：零标志。最近的操作得出的结果为0。 SF：符号标志。最近的操作得到的结果为负数。 OF：溢出标志。最近的操作导致一个补码溢出\u0026ndash;正溢出或负溢出。 比较和测试指令 指令 基于 描述 CMP S1, S2 S2 - S1 比较 cmpb 比较字节 cmpw 比较字 cmpl 比较双字 cmpq 比较四字 TEST S1, S2 S1 \u0026amp; S2 测试 testb 测试字节 testw 测试字 testl 测试双字 testq 测试四字 访问条件码\n条件码通常不会直接读取，常用的使用方法有三种：我们将这一豆类指令称为SET指令。\n可以根据条件码的某种组合，将一个字节设置为0或1,2 可以条件中转到程序的某个其他的部分 可以有条件地传送数据 指令 同义名 效果 设置条件 sete D setz D \u0026lt;- ZF 相等/零 setne D setnz D \u0026lt;- ~ZF 不等/非零 sets D D \u0026lt;- SF 负数 setns D D \u0026lt;- ~SF 非负数 setg D setnle D \u0026lt;- ~(SF ^ OF) \u0026amp; ~ZF 大于（有符号\u0026gt;） setge D setnl D \u0026lt;- ~(SF ^ OF) 大于等于（有符号\u0026gt;=） setl D setnge D \u0026lt;- SF ^ OF 小于（有符号\u0026lt;） setle D setng D \u0026lt;- (SF ^ OF) 或 ZF 小于等于（有符号\u0026lt;=） seta D setnbe D \u0026lt;- ~CF \u0026amp; ~ZF 超过（无符号\u0026gt;） setae D setnb D \u0026lt;- ~CF 超过或相等（无符号\u0026gt;=） setb D setnae D \u0026lt;- CF 低于（无符号\u0026lt;） setbe D setna D \u0026lt;- CF 或 ZF 低于或相等（无符号\u0026lt;=） 跳转指令\n正常执行的情况下，指令按照它们出现的顺序一条一条地执行。跳转（jump）指令会导致执行切换到程序中一个全新的位置。这些跳转的目的地通常用一个标号（label）指明。下表列举了不同的跳转指令。jmp指令是无条件跳转。它可以是直接跳转，即跳转目标是作为指令的一部分编码的;也可以是间接跳转，即跳转目标是从寄存器或内存位置中读出的。汇编语言中，直接跳转是给出一个标号作为跳转目标的，间接跳转的写法是*后面跟一个操作数指示符。例如：jmp *%rax 用寄存器%rax中的值作为跳转目标 jmp *(%rax) 以%rax中的值作为读地址，从内存中读出跳转目标。\n指令 同义名 跳转条件 描述 jmp Label 1 直接跳转 jmp *Operand 1 间接跳转 je Label jz ZF 相等/零 jne Label jnz ~ZF 不相等/非零 js Label SF 负数 jns Label ~SF 非负数 jg Label jnle ~(SF ^ OF) \u0026amp; ~ZF 大于 jge Label jnl ~(SF ^ OF) 大于或等于 jl Label jnge SF ^ OF 小于 jle Label jng (SF ^ OF) 或 ZF 小于或等于 ja Label jnbe ~CF \u0026amp; ~ZF 超过 jae Label jnb ~CF 超过或相等 jb Label jnae CF 低于 jbe Label jna CF 或 ZF 低于或相等 跳转指令的编码 用条件控制来实现条件分支 用条件传送来实现条件分支\n条件传送指令\n指令 同义名 传送条件 描述 cmove S,R cmovz ZF 相等/零 cmovne S,R cmovnz ~ZF 不相等/非零 循环\nC语言提供了多种循环结构，即do-while，while和for。\ndo-while while for\nfor (init-expr; test-expr; update-expr) { body-statement } 这样一个循环的行为与下面这段使用while循环的代码的行为一样\ninit-expr; while (test-expr) { body-statement update-expr; } switch语句\nswitch(开关)语句可以根据一个整数索引值进行多重分支。在处理具有多种可能结果的测试时，这种语句特别有用。它们不公提高了C代码的可读性，而且通过使用跳转表(jump table)这种数据结构使得实现更加高效。和使用一组很长的if-else语句相比，使用跳转表的优点是执行开关语句的时间与开关情况的数量无关。\n过程 过程是软件中一种很重要的抽象。它提供了一种封闭代码的方式，用一组指定的参数和一个可选反返回值实现了某种功能。然后，可以在程序中不同的地方调用这个函数。要提供对过程的机器级支持，必须要处理许多不同的属性。为了讨论方便，假设过程P调用过程Q,Q执行后返回到P.这些动作包括下面一个或多个机制：\n传递控制：在进入过程Q的时候，程序计数器必须被设置成Q的代码的起始地址，然后在返回时，要把程序计数器设置为P中调用Q后面那条指令的地址。 传递数据：P必须能够向Q提供一个或多个参数，Q必须能够向P返回一个值。 分配和释放内存：在开始时，Q可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间。 运行时栈\nC语言过程调用机制的一个关键特性（大多数其他语言也是如此）在于使用了栈数据结构提供的后进先出的内存管理原则。在过程P调用过程Q的例子中，可以看到当Q在执行时，P以及所有在向上追溯到P的调用链中的过程，都是暂时被挂起的。当Q运行时，它只需要为局部变量分配新的存储空间，或者设置到另一个过程的调用。另一方面，当Q返回时，任何它所分配的局部存储空间都可以被释放。因此，程序可以用栈来管理它的过程所需要的存储空间，栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息。当P调用Q时，控制和数据信息添加到栈尾。当P返回时，这些信息会释放掉。当X86_64过程需要的存储空间走出寄存器能够存放的大小时，就会在栈上分配空间。这个部分称为过程的栈帧(stack fram)。当前正在执行的过程的帧总是在栈顶。通过寄存器，过程P可以传递最多6个整数值（也就是指针和整数），但是如果Q需要更多的参数，P可以在调用Q之前在自己的栈帧里存储好这些参数。为了提高空间和时间效率，x86_64过程只分配自己所需要的栈帧部分。例如，许多过程有6个或者更少的参数，那么所有的参数都可以通过寄存器传递。\n转移控制\n将控制从函数P转移到函数Q只需要简单地把程序计数器（PC）设置为Q的代码的起始位置。不过，当稍后从Q返回的时候，处理器必须记录好它需要继续P的执行的代码位置。在x86——64机器中，这个信息是用指令call Q调用过程Q来记录的。该指令会把地址A压入栈中，并将PC设置为Q的起始地址。压入的地址A被称为返回地址，是紧跟在call指令后面的那条指令的地址。对应的指令ret会从栈中弹出地址A,并把PC设置为A. call指令有一个目标，即指明被调用过程起始的指令地址。同跳转一样，调用可以是直接，也可以是间接的。在汇编代码中，直接调用的目标是一个标号，而间接调用的目标是*后面跟一个操作数指示符。\n数据传送\n当调用一个过程时，除了要把控制传递给它并在过程返回时再传递回来之外，过程调用还可能包括把数据作为参数传递，而从过程返回还有可能包括返回一个值。x86-64中，大部分过程间的数据传送是通过寄存器实现的。 x86-64中，可以通过寄存器最多传递6个整形（例如整数和指针）参数。寄存器的使用是有特殊顺序的，寄存器使用的名字取决于要传递的数据类型的大小，会根据参数在参数列表中的顺序为它们分配寄存器。\nTable 1: 传递函数参数的寄存器。 操作数据大小 1 2 3 4 5 6 64 %rdi %rsi %rdx %rcx %r8 %r9 32 $edi %esi %edx %ecx %r8d %r9d 16 %di %si %dx %cx %r8w %r9w 8 %dil %sil %dl %cl %r8b %r9b 如果一个函数有大于6个整形参数，走出个的部分就要通过栈来传递。把参数7-N个参数放到栈上，而参数7位于栈顶。通过栈传递参数时，所有的数据大小都向8的倍数对齐。\n栈上的局部存储\ne 些时候，局部数据必须存放在内存中，学见的情况包括：\n寄存器不足够存放所有的本地数据 对一个局部变量使用地址运算符\u0026rsquo;\u0026amp;\u0026rsquo;，因此必须能够为它产生一个地址 某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。 寄存器中的局部存储空间\n寄存器组是唯一被所有过程共享的资源。虽然在给定时刻只有一个过程是活动的，我们仍然必须确保当一个过程（调用者）调用另一个过程（被调用者）时，被调用者不会覆盖调用者稍后会使用的寄存器值。根据惯例，寄存器%rbx、%rbp和%r12-%r15被划分为被调用者保存寄存器。当过程P调用过程Q时，Q必须保存这些寄存器的值，保证它们的值在Q返回到P时与Q被调用时是一样的。过程Q保存一个寄存器的值不变，要么就是根据不去改变它，要么就是把原始值压入栈中，改变寄存器的值，然后在返回前从栈中弹出旧值。压入寄存器的值会在栈帧中创建标号为“保存的寄存器”的一部分。所有其他的寄存器，除了栈指针%rsp,都分类为调用者保存寄存器。这就意味着任何函数都能修改它们。可以这样来理解“调用者保存”这个名字：过程P在某个此类寄存器中有局部数据，然后调用过程Q。因为Q可以随意修改这个寄存器，所以在调用之前首先保存好这个数据是P（调用者）的现任。\n递归过程 数组分配和访问 基本原则\n对于数据类型T和整形常数N,声明如下： T A[N]; 起始位置表示为x_A。这个声明有两个效果。首先，它在内存中分配一个L*N字节的连续区域，这里的L是数据类型T的大小（单位为字节）。其次，它引入了标识符A,可以用A来作为指向数组开头的指针，这个指针的值就是x_A。可以用0-N-1的整数索引来访问该数组元素。数组元素i会被存放在地址为x_A + L * i的地方。\n指针运算\nC语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩。也就是说，如果p是一个指向类型为T的数据的指针，p的值为x_p，那么表达式p + i的值为x_p + L * i，这里的L是数据类型t的大小。单操作数操作符\u0026quot;\u0026amp;\u0026ldquo;t \u0026ldquo;*\u0026ldquo;可以产生指针和间接引用指针。也就是说，对于一个表示某个对象的表达式Expr, \u0026amp;Expr是给出该对象地址的一个指针。对于一个表示地址的表达式AExpr, *AExpr给出该地址处的值。因此，表达式Expr和*\u0026amp;Expr是等价的。数组引用A[i]等同于表达式*(A + i)。\n嵌套的数组 定长数组\nC语言编译器能够优化定长多维数组上的操作代码。\n变长数组\nC99允许数组的维度是表达式，在数组被分配的时候才计算出来。\n异质的数据结构 C语言提供了两种将不同匠对象组合到一起创建数据类型的机制：结构(structure)，用关键字struct来声明，将多个对象集合一个单位中; 联合(union)， 用关键字union来声明，允许用几种不同的类型来引用一个对象。\n结构\nC语言的struct声明创建一个数据类型，将可能不同类型的对象聚合到一个对象中。用名字来引用结构的各个组成部分。类似于数组的实现，结构的所有组成部分都存放在内存中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址。编译器维护关于每个结构类型的信息，指示每个字段的字节偏移。它以这些偏移作为内存引用指令中的位移，从而产生对结构元素的引用。结构的各个字段的选取完全是在编译时处理的。机器代码不包含关于字段声明或字段名字的信息。\n联合\n联合提供了一种方式，能够规避C语言的类型系统，允许以多种类型来引用一个对象。联合声明的语法与结构的语法一样，只不过主义相差比较大。它们是用不同的字段来引用相同的内存块。\n数据对齐\n许多计算机系统对基本数据类型的合法地址做出了一些限制，要求某种类型对象的地址必须是某个值K（通常是2、4、8）的倍数。这种对齐限制简化了形成处理器和内存系统之间接口的硬件设计。编译器在汇编代码中放入命令，指明僵尸数据所需的对齐。\n.align 8 对于包含结构的代码，编译器可能需要在字段的分配中插入间隙，以保证每个结构元素都满足它的对齐要求。而结构本身对它的起始地址也有一些对齐要求。\n在机器级程序中将控制与数据结合起来\n理解指针\n指针是C语言的一个核心特色。它们以一种统一方式，对不同数据结构中的元素产生引用。\n指针和它们映射到机器代码的关键原则\n每个指针都对应一个类型通常，如果对象类型为T,那么指针的类型为T*。特殊的void *类型代表通用指针。 每个指针都有一个值。这个值是某个指定类型的对象的地址。特殊的NULL(0)值表示该指针没有指向任何地方。 指针用\u0026rsquo;\u0026amp;\u0026lsquo;运算符创建这个运算符可以应用到任何lvalue类的C表达式上，lvalue意指可以出现在同仁语句左边的表达式。 * 操作衔用于间接引用指针其结果是一个值，它的类型与该指针的类型一致。 数组与指针紧密联系将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值。 指针也可以指向函数 使用GDB调试器\nTable 2: GDB命令示例 命令 效果 开始和停止 quit 退出GDB run 运行程序(在此给出命令行参数) kill 停止程序 断点 break multstore 在函数multstore入口处设置断点 break * 0x400540 在地址0x400540处设置断点 delete 1 删除断点1 delete 删除所有断点 执行 stepi 执行一条指令 stepi 4 执行4条指令 nexti 类似于stepi,但以函数调用为单位 continue 继续执行 finish 运行到当前函数返回 检查代码 disas 反汇编当前函数 disas multstore 反汇编函数multstore disas 0x400540 反汇编位于地址0x400540附近的函数 disas 0x400540,0x40054d 反汇编指定地址范围内的代码 print /x $rip 以十六进制输出程序计数器的值 检查数据 print $rax 以十进制输出%rax的内容 print /x $rax 以十六进制输出%rax的内容 print /t $rax 以二进制输出%rax的内容 print 0x100 输出0x100的十进制表示 print /x 555 输出555的十六进制表示 print /x ($rsp + 8) 以十六进制输出%rsp的内容加上8 print *(long *) 0x7fffffffe818 输出位于地址0x7fffffffe818的长整数 print *(long *)($rsp + 8) 输出位于地址%rsp+8处的长整数 x/2g 0x7fffffffe818 检查从地址0x7fffffffe818开始的双(8字节)字 x/20bmultstore 检查函数multstore的前20个字节 有用的信息 info frame 有关当前栈帧的信息 info registers 所有寄存器的值 help 获取有关GDB的信息 内存越界引用和缓冲区溢出\nC对于数组引用不进行任何边界检查，而且局部变量和状态信息（例如保存的寄存器值和返回地址）都存放在栈中。\n对抗缓冲区举出攻击\n栈随机化栈随机化的思想使得栈的位置在程序每次运行时都有变化。在Linux系统中，栈随机化已经变成了标准行为。它是更大的一类技术中的一种，这类技术称为地址空间布局随机化（Address-Space Layout Randomization），或者简称ASLR。 栈破坏检测计算机的第二道防线是能够检测到何时栈已经被破坏。最近的GCC版本在产生的代码中加入了一种栈保护者(stack protector)机制，来检测缓冲区越界。其思想是在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的金丝雀值。是在程序每次运行时随机产生的，因此，攻击同有简单的办法能够知道它是什么。在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者该函数调用 的某个函数的某个操作改变了。如果是的，那么程序异常中止。 限制可执行代码区域 支持变长栈帧\n为了管理变长栈帧，x86-64代码使用寄存器%rbp作为帧指针（frame pointer）（有时称为基指针(base pointer)，这也是%rbp中bp两个字母的由来）\n浮点代码 处理器的浮点体系结构包括多个方面，会影响对浮点数据操作的程序如何被映射到机器上，包括：\n如何存储和访问浮点数值。通常是通过某种寄存器方式来完成 对浮点数据操作的指令 向函数传递浮点数参数和从函数返回浮点数结果的规则 函数调用过程中保存寄存器的规则 浮点传送和转换操作 过程中的浮点代码 浮点运算操作 定义和使用浮点常数 在浮点代码中使用位级操作 浮点比较操作 对浮点代码的观察结论 处理器体系结构 一个处理器支持的指令和指令的字节级编码称为它的指令集体系结构（Instruction-Set Architecture, ISA）\nY86-64指令集体系结构 定义一个指令集体系结构包括定义各种状态单元、指令集和它们的编码、一组编程规范和异常事件处理。\n程序员可见的状态\nY86-64程序中的每条指令都会读取或修改处理器状态的某些部分。这称为程序员可见状态，这里的程序员既可以是用汇编代码写程序的人，也可以是产生机器级代码的编译器。在处理器实现中，只要我们保证机器 级程序能够访问程序员可见状态，就不需要完全按照ISA暗示的方式来表示和组织这个处理器状态。\nY86-64指令 指令编码\n比较CISC和最初的RISC指令集 CISC RISC 指令数量很多。Intel描述全套指令的文档有1200多页 指令数量少得多，通常少于100个 有些指令的延迟很长。包括将一个整块从内存的一个部分复制到另一部分的指令，以及其他一些将多个寄存器的值复制到内存或从内存复制到多个寄存器的指令 没有较长的延迟的指令。有些早期 的RISC机器甚至没有整数乘法指令，要求编译器通过一系列g加法为实现乘法。 编码是可变长度的。X86-64的指令长度可以是1-15个字节 编码是固定长度的。通常所有的指令都编码为4个字节 指定操作数的方式很多样。在X86-64中，内存操作数指示符可以有许多不同的组合，这些组合由领衔量、基址和变址寄存器以及伸缩因子组成 简单寻址方式。通常只有基址和统称量寻址 可以对内存和寄存器操作数进行算术和逻辑运算。 只能对寄存器操作数进行算术和逻辑运算，允许使用内存引用的只有load和store指令，load是从内存读到寄存器，store是从寄存器写到内存。这种方法被称为load/store体系结构 对机器级程序来说实现细节是不可见的。ISA提供了程序和如何执行程序之间的清晰的抽象 对机器级程序来说实现细节是可见的。有些RISC机器禁止某些特殊的指令序列，而有些跳转要到下一条指令执行完了以后才会第一次。编译器必须在这些约束条件下进行性能优化。 有条件码，作为指令执行的副产品，设置了一些特殊的标志位，可以用于条件分支检测 没有条件码。相反，对条件检测来说，要用明确的测试指令，这些指令会将测试结果放在一个普通的寄存器中。 栈密集的过程链接。栈被用来存取过程参数和返回地址。 寄存器密集的过程链接。寄存器被用来存取过程参数和返回地址。因此有些过程能完全避免内存引用。通常处理器有更多的（最多的有32个）寄存器 逻辑设计和硬件控制语言HCL 在硬件设计中，用电子电路来计算对位进行运算的函数，以及在各种存储器单元中存储位。大多数现代电路技术都是用信号线上的高电压和低电压来表示不同的位值。要实现一个数字系统需要三个主要的组成部分：计算对位进行操作的函数的组合逻辑、存储位的存储器单元，以及控制存储器单元更新的时钟信号。\n逻辑门\n逻辑门是数字电路的基本计算单元。它们产生的输出，等于它们输入位值的某个布尔函数。逻辑门总是活动的。一旦一个门的输入变化了，在很短的时间内，输出就会相应的变化。\n组合电路和HCL布尔表达式\n将很多的逻辑门组合成一个网，就能构建计算块，称为组合电路。\n构建这些网有几个限制\n每个逻辑门的输入必须连接到下述选项之一 一个系统输入（称为主输入） 某个存储器单元的输出 某个逻辑门的输出 两个或多个逻辑门的输出不能连接在一起。否则它们可能会使线上的信号矛盾，可能会导致一个不合法的电压a中电路故障。 这个网必须是无环的。 字级的组合电路和HCL整数表达式\n通过将逻辑门组合成大的网，可以构造出能计算更加复杂函数的组合电路。\n集合关系\n在处理器设计中，很多时候都需要将一个信号与许多可能匹配的信号做比较，以此来检测正在处理的某个指令代码是否属于某一类指令代码。\n存储器和时钟\n组合电路从本质上讲，不存储任何信息。相反，它们只是简单地响应输入信号，产生等于输入的某个函数的输出。为了产生时序电路，也就是有状态并且在这个状态上进行计算的系统，我们必须引入按位存储信息的设置。存储设备都是由同一个时钟控制的，时钟是一个周期性信号，决定什么时候要把新值加载到设軠中。\n考虑两类存储器设备 时钟寄存器（简称寄存器）：存储单个位或字。时钟信号控制寄存器加载输入值。 随机访问存储器（简称内存）存储多个字，用地址来选择该读或该写哪个字。 Y86-64的顺序实现 将处理组织成阶段\n通常，处理一条指令包括很多操作。将它们组织成霜个特殊的阶段序列，即使指令的动作差异很大，但所有的指令都遵循统一的序列。每一步的具体处理取决于正在执行的指令。创建这样一个框架，我们就能够设计一个充分利用硬件的处理器。下面是关于各个阶段以及各有阶段内执行操作的简略描述：\n取指(fetch): 指从内存读取指令字节，地址为程序计数器（PC）的值。 译码(decode): 执行(execute): 访存(memory): 写回(write back): 更新PC(PC udpate): SEQ硬件结构 SEQ的时序 SEQ阶段的实现 流水线的通用原理 流水线化的一个重要我就是提高了系统的吞量，也就是单位时间内服务的顾客总数，不过它也会轻微地增加延迟，就是服务一个用户所需要的时间。\n计算流水线 流水线操作的详细说明 流水线的局限性 带反馈的流水线系统 Y86-64的流水线实现 流水线冒险 优化程序性能 在程序开发和优化的过程中，我们必须考虑代码使用的方式，以及影响它的关键因素。通常程序员必须在实现和维护程序的简单性与它的运行速度之间做出权衡。研究程序的汇编代码表示是理解编译器以及产生的代码会如何运行的最有效手段之一。一个很有用的策略是只重写程序到编译器由此就能产生有效代码所需要的程度就好了。这样能尽量避免损害代码的可读性、模块性和可移植性，就好像我们使用的是具有最低能力的编译器。同样，通过测量值和检查生成的汇编代码，反复修改源代码和分析它的性能是很有帮助的。对于新手程序员来说，不断修改源代码，试图欺骗编译器产生有效的代码，看起来很奇怪，但这确实是编写很多高性能程序的方式。\n优化编译器的能力和局限性 现代编译器运用复杂精细的算法来确定一个程序中计算的是什么值，以及它们是被如何使用的。然后会利用一些机会来简化表达式，在几个不同的地方使用同一个计算，以及降低一个给定的计算必须被执行的次数。大多数编译器，包括GCC,向用户提供了一些对它们所使用的优化的控制。编译器必须很小心地对程序只使用安全的优化，也就是说对于程序可能遇到的所有可能的情况，在C语言标准提供的保证之下，优化后得到的程序和未优化的版本有一样的行为。限制编译器只进行安全的优化，消除了造成不希望的运行时行为的一些可能的原因，但是这也意味着程序员必须花费更大的力气写出编译器能够将之转换成有效机器代码的程序。\n表示程序性能 我们引入试题标准每元素的周期数（Cycles Per Element, CPE），作为一种表示程序性能并指导我们改进代码的方法。CPE这种试题标准帮助我们在更细节的级别上理解迭代程序的循环性能。这样的试题标准对执行重复计算的程序来说是很适当的。处理器活动的顺序是由时钟控制的，时钟提供了某个频率的规律信号，通常用千兆赫兹（GHz），即十亿周期每秒来表示。每个时钟周期的时间是时钟频率的倒数。通常是以纳秒（nanosecond, 1纳秒等于10^-9秒）或皮秒（picosecond, 1皮秒等于10^-12秒）为单位。用时钟周期来表示，度量值表示的是执行了多少条指令，而不是时钟运行得有多快。\n消除循环的低效率 将在循环中不改变的代码放到循环外边。\n减少过程调用 消除不必要的内存引用 理解现代处理器 整体操作\nICU从指令高速缓存（instruction cache）中读取指令，指令高速缓存是一个特殊的高速存储器，它包含最近访问的指令。当程序遇到分支时，现代处理器采用了一种分支预测的技术，处理器会猜测是否会选择分支，同时还预测分支的目的地址。指令译码逻辑接收实际的程序指令，，并将它们转换成一组基本操作（有时称为微操作）。 EU接收来自取指单元的操作。通常，每个时钟周期会接收多个操作。这些操作会被分派到一组功能单元中，它们会执行实际的操作。这些功能单元专门用来处理不同类型的操作。读写内存是由加载和存储单元实现的。在ICU中，退役单元（retirement unit）记录正在进行的处理，并确保它遵守机器级程序的顺序主义。任何对程序寄存器的更新都只会在指令退役时才会发生，只有在处理器能够确信导致这条指令的所有分支都预测正确了，才会这样做。控制操作数在执行单元间传送的最常见的机制称为寄存器重命名。\n功能单元的性能\n每个运算都是由以下这些数值来刻画的：一个是延迟（latency），它表示完成运算所需要的总时间，另一个是发射时间（issue time），它表示两个 连续的同类型的运算之间需要的最小时钟周期数，还有一个是容量（capactiy），它表示能够执行该运算的功能单元的数量。\n处理器操作的抽象模型\n作为分析在现代处理器上执行的机器级程序性能的一个工具，我们会使用程序的数据流（data-flow）表示，这是一种图形化的表示方法，展现了不同操作之间的数据相关是如何限制它们的执行顺序的。这些限制形成了图中的关键路径（critical path），这是执行一组机器指令所需时钟周期数的一个下界。\n循环展开 循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。\n提高并行性 多个累积变量\n对于一个可结合和可交换的合并运算来说，比如说整数加法或乘法，我们可以通过将一组合并运算分割成两个或更多的部分，并在最后合并结果来提高性能。\n重新结合变换\n重新结合变换能够减少计算中关键路径上操作的数量，通过更好地利用功能单元的流水线能力得到更好的性能。\n理解内存性能 加载的性能\n一个包含加载操作的程序的性能既依赖于流水线的能力，也依赖于加载单元的延迟。\n存储的性能\n与加载操作一样，在大多数情况中，存储操作能够在完全流水线化的模式中工作，每个周期开始一条新的存储。\n应用：性能提高技术 优化性能的基本策略\n高级设计：为遇到的问题选择适当的算法和数据结构。 基本编码原则 消除连续的函数调用 消除不必要的内存引用 低级优化 展开循环 通过使用例如多个累积变量和重新结合等技术，找到方法提高指令级并行 用功能性的风格重写条件操作，使得编译采用条件数据传送 确认和消除性能瓶颈 程序剖析\n程序剖析（profiling）运行程序的一个版本，其中插入了工具代码，以确定程序的各个部分需要多少时间。剖析的一个有力之处在于可以在现实的基准数据（benchmark data）上运行实际程序的同时，进行剖析。 Unix系统提供了一个剖析程序GPROF.\n使用剖析程序来指导优化 存储器层次结构 到目前为止，在对系统的研究中，我们依赖于一个简单的计算机系统模型，CPU执行指令，而存储器系统为CPU存放指令和数据。实际上，存储器系统是一个具有不同容量、成本和访问时间的存储设备的层次结构。CPU寄存器保存着最常用的数据。靠近CPU的小的、快速的调整缓存存储器作为一部分存储在相对慢速的主存储器中数据和指令的缓冲区域。主存缓存存储在容量较大的、慢速磁盘上的数据，而这些磁盘常常又作为存储在通过网络连接的其他机器的磁盘或磁带上的数据的缓冲区域。作为一个程序员，你需要理解存储器层次结构，因为它对应用程序的性能有着巨大的影响。如果你的程序需要的数据是存储在CPU寄存器中，那么在指令的执行期间，在0个周期内就能访问到它们。如果存储在调整缓存中，需要4-75个周期。如果存储在主存中，需要上百个周期。而如果存储在磁盘上，需要大约几千万个周期。这不是计算机系统中一个基本而持久的思想：如果你理解了系统是如何将数据在存储器层次结构中上上下下移动的，那么你就可以编写自己的应用程序，使得它们的数据项存储在层次结构中较高的地方，在那里CPU能更快地访问到它们。这个思想轻裘缓带着计算机程序的一个称为局部性的基本属性。具有良好局部性的程序倾向于一次又一次地访问相同的数据项集合，或是倾向于访问邻近的数据项集合。\n存储技术 随机访问存储器 RAM\n静态RAM SRAM 动态RAM DRAM 访问主存\n数据流通过称为总线的共享电子电路在处理器和DRAM主存之间来来回回。每次CPU和主存之间的数据传送都是通过一系列步骤来完成的，这些步骤称为总线事务。读事务从主存传送数据到CPU.写事务从CPU传送数据到主存。\n磁盘存储\n从磁盘上读信息的时间为毫秒级，比从DRAM读慢了10万倍，比从SRAM读慢了100万倍。\n磁盘构造 磁盘容量\n一个磁盘上可以记录的最大位数称为它的最大容量，或者简称为容量。磁盘容量是由以下技术因素决定的：\n记录密度：磁盘一英寸的上可以放入的位数。 磁道密度：从盘片中心出发半径一英寸的段内可以有的磁道数。 面密度：记录密度与磁道密度的乘积 磁盘操作\n磁盘用读写头来读写储存在磁性表面的位，而读写头连接到一个传送臂一端，通过沿着半径前后移动这个传动臂，鸡翅器可以将读写头定位在盘面上的任何磁道上。这样的机械运行称为寻道。一旦读写头定位到了期望的磁道上，那么当磁道上的每个经的下面时，读写头可以感知到这个位的值，也可以修改这个位的值。三产以扇区大小的块来读写数据。对扇区的访问时间有三个主要的部分：\n寻道时间 旋转时间 传送时间 固态硬盘\n固态硬盘是一种基于闪存的存储技术。固态硬盘随机访问时间比旋转磁盘要快，能耗更低，同时也更结实。不过反复写之后，闪存块会磨损，所以SSD也容易损坏。\n存储技术趋势\n不同的存储技术有不同的价格和性能折中 不同存储技术的价格和性能属性以截然不同的速率变化着 DRAM和磁盘的性能满后于CPU的性能 局部性 一个编写良好的计算机程序常常具有良好的局部性。局部性通常有两种不同的形式：时间局部性和空间局部性。\n对程序数据引用的局部性 取指令的局部性\n因为程序指令是存放在内存中的，CPU必须取出这些指令，所以我们也能够评价一个程序关于取指令的局部性。\n评价程序中局部性的一些简单原则\n重复引用相同变量的程序有良好的时间局部性。 对于具有步长为k的引用模式的程序，步长越小，空间局部性越好。具有步长为l的引用模式的程序有很好的空间局部性。在内存中以大步长跳来跳去的程序空间局部性会很差 对于取指令来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好。 存储器层次结构 存储器层次结构中的缓存\n层次结构中的每一层都缓存来自较低一层的数据对象。数据总是以块大小为传送单元在第K层和第K+1层之间来回复制的。\n缓存命中问题\n缓存命中当程序需要第K+1层的某个数据对象时，它首先在当前存储在第K层的一个块中查找。如果刚好缓存在第K层中，那么就是我们所说的缓存命中。 缓存不命中如果第K层中没有缓存数据对象，那么就是我们所说的缓存不命中。当发生缓存不命中时，第K层的缓存从第K+1层缓存中取出包含对象的那个块，如果第K层的缓存已经満了，可能就会覆盖现存的一个块。覆盖一个现存的块的过程称为替换或驱逐这个块。被驱逐的这个块有时也称为牺牲块。决定该替换哪个块是由缓存的替换策略来控制的。 缓存不命中的种类 冷不命中 冲突不命中 缓存管理 高速缓存存储器 通用的高速缓存存储器组织结构 映射映射高速缓存 组相联高速缓存 全相联高速缓存 有关写的问题 高速缓存参数的性能影响\n高速缓存大小的影响较大的高速缓存可能会提高命中率，但是使较大存储器运行得更快总是要难一些。 块大小的影响大的块有利有弊。较大的块能利用程序中可能存在的空间局部性，帮助提高命中率。不过对于给定的高速缓存大小，块越大就意味着高速缓存行数越少，这会损害时间局部性比空间局部性更好的程序中的命中率。 相联度的影响 写策略的影响 编写高速缓存友好的代码 确保代码高速缓存友好的基本方法\n让最常见的情况运行得快。 尽量减小每个循环内部的缓存不命中数量 将你的注意力集中在内循环上，大部分计算和内存访问都发生在这里 通过按照数据对象存储在内存中的顺序、以步长为1的来读数据，从而使得你程序中的空间局部性最大。 一旦从存储器中诗篇了一个数据对象，京尽可能多地使用它，从而使得程序跌时间局部性最大。 高速缓存对程序性能的影响 在系统上运行程序 链接 链接(linking)是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接可以执行于编译时（compile time），也就是在源代码被翻译成机器代码时;也可以执行于加载时（load time），也就是在程序被加载器（loader)加载到内存并执行时;甚至执行于运行时（run time）,也就是由应用程序来执行。在现代系统中，链接是由叫做链接器（linker）的程序自动执行的。链接器在软件开发中扮演着一个关键的角色，因为它们使得健康编译成为可能。\n理解链接器的重要性 理解链接器将帮助你构造大型程序 理解链接器将帮助你避免一些危险的编程错误 理解链接将帮助你理解语言的作用域规则是如何实现的 理解链接将帮助你理解其他重要的系统概念 理解链接将使你能够利用共享库 编译器驱动程序 一个例子： gcc -Og -o prog main.c sum.c\ncpp(C预处理器)将源程序翻译成一个ASCII码的中间文件main.i ccl（C编译器）将main.i翻译成一个ASCII汇编语言文件main.s as（汇编器）将main.s翻译成一个可重定位目标文件main.o 经过相同的过程生成sum.o ld(链接器)将main.o和sum.o以及一些必要的系统目标文件组合起来，创建一个可执行目标文件prog 静态链接 像Linux LD程序这样的静态链接器以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。为了构造可执行文件，链接器必须完成两个主要任务：\n符号解析 重定位 目标文件 目标文件有三种形式：\n可重定位目标文件。 可执行目标文件 共享目标文件 可重定位目标文件 典型的ELF可重定位目标文件内容\n内容 说明 ELF 头 以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息 .text 已编译程序的机器代码 .rodata 只读数据，比如printf语句中的格式串和开关语句的跳转表 .data 已初始化的全局和静态C变量 .bss 未初始化的僵尸和静态C变量，以及所有被初始化为0的全局或静态变量 .symtab 一个符号表，它存放在程序中定义和引用的函数和全局变量的信息 .rel.text 一个.text中位置的列表，当链接器把这个目标文件 和其他文件组合时，需要修改这些位置 .rel.data 被模块引用或pgyqr所有全局变量的重定位信息 .debug 一个高度符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的C源文件。只有以-g选项编译器驱动程序时，才会得到这张表。 .line 原始C源程序中的行号和.text节中机器指令之间的映射。只有以-g选项调用编译器驱动程序时，才会得到这张表 .strtab 一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。字符串表就是以null结尾的字符串的序列。 节头部表 符号和符号表 每个可重定位目标模块m都有一个符号表，它包含m定义和引用的符号的信息。在链接器的上下文中，有三种不同的符号：\n由模块m定义并能被其他模块引用的全局符号。全局链接器符号对应于非静态的C函数和全局变量 同其他模块定义并被模块m引用的全局符号。这些符号称为外部符号，对应于在其他模块中定义的非静态C函数和全局变量 只被模块m定义和引用的局部符号。它们对应于带static属性的C函数和全局变量。这些符号在模块m中任何位置都可见，但是不能被其他模块引用。 符号解析 链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。对那些和引用定义在相同模块中的局部符号的引用，符号解析是非常简单明了的。编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。不过，对全局符号的引用解析就棘手得多。当编译器遇到一个不是在当前模块中定义的符号(变量或函数名)时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理。如果链接吕在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条（通常很难阅读的）错误信息并终止。\n链接器如何解析多重定义的全局符号\n在编译时，编译器向汇编器输出每个全局符号，或者昌强或者是弱，而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱k答。根据强弱符号的定义，Linux链接器使用下面的规则来处理多重定义的符号名：\n不允许有多个同名的强符号 如果有一个强符号和多个弱符号同名，那么选择强符号。 如果有多个弱符号同名，那么从这些弱符号中任意选择一个。这是一个细微而令人讨厌的错误，尤其是因为它只会触发链接器发出一条警告。当你怀疑有此类错误时，用像GCC-fno-common标志这样的选项调用链接器，这个选项会告诉链接器，在遇到多重定义的全局符号时，触发一个错误。或者使用-Werror选项，它会的把所有的警告都变为错误。 与静态库链接\n所有的编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为静态库（static library），它可以用做链接器的输入。当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块。静态库概念被提出来，将相关的函数可以被编译为独立的目标模块，然后封装成一个单独的静态库文件。然后应用程序可以通过在命令行上指定单独的文件名字来使用这些库中定义的函数。在链接时，链接器将只复制被程序引用的目标模块，这就减少了可执行文件在磁盘和内存中的大小。在Linux系统中，静态库以一种称为存档（archive）的特殊文件格式存放在磁盘中。存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。\n链接器如何使用静态库来解析引用\n虽然静态库很有用，但是它们同时b民是一个程序员迷惑的源头，原因在于Linux链接器使用它们解析外部引用的方式。在符号解析阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。在这次扫描中，链接器维护一个可重定位目标文件的集合E, 一个未解析的符号集合U,以及一个在前面输入文件中已定义的符号集合D。初始时，E，U和D均为空。\n对于命令行上的每个输入文件f,链接器会判断f是一个目标文件还是一个存档文件。如果f是一个目标文件，那么链接器把f添加到E,修改U和D来反映f中的符号定义和引用，并继续下一个输入文件。 如果f是一个存档文件，那么链接器就深度匹配U中 esrr符号和由存档文件成员定义的符号。如果某个存档文件成员m,定义了一个符号来解析U中的一个引用，那么就将m添加到E中，并且链接器修改U和D来反映m中的符号定义和引用。对存档文件中所有的成员目标文件都依次进行这个过程，直到U和D都不再发生变化。此时，任何不包含在E中的成员目标文件都简单地被丢弃，而链接器将继续处理下一个输入文件。 如果当链接器完成对命令行上输入文件的扫描后，U是非空的，那么链接器就会输出一个错误并终止。否则，它会合并和重定位E中的目标文件，构建输出的可执行文件。不幸的是，这种算法会导致一些令人困扰的链接时错误，因为命令行上的库和目标文件的顺序非常重要。在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析，链接会失败。所以，关于库的一般准则是将它们放在命令行的结尾。如果各个库的成员是相互独立的（也誻说没有成员引用另一个成员定义的符号），那么这些库就可以以任何顺序放置在命令行的结尾处。另一方面，如果库不是相互独立的，那么必须对它们排序，使得对于每个被存档文件的成员外部引用的符号s,在命令行中至少有一个s的定义是在对s的引用之后的。如果需要满足依赖需求，可以在命令行上重复库。 重定位 一旦链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义关联起来。此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。现在就可以开始重定位步骤了，在这个步骤中，将合并输入模块，并为每个符号分配运行时地址。重定位由两步组成：\n重定位节和符号定义。在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。 重定位节中的符号引用。在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中称为重定位条目（relocation entry）的数据结构。 重定位条目\n当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置。它也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。代码的重定位条目放在.rel.text中。已初始化数据的重定位条目放在.rel.data中。 ELF重定位条目.每个条目表示一个必须被重定位的引用，并指明如何计算被修改的引用：\ntypedef struct { long offset; // 需要被修改的引用的节偏移 long type:32, // 告知链接器如何修改新的引用 symbol:32; // 标识被修改引用应该指向的符号 long addend; // 一些类型的重定位要使用它对被修改引用的值做偏移调整 } Elf64_Rela; ELF定义了32种不同的重定位类型，我们只关心其中两种最基本的重定位类型：\nR_X86_64_PC32 重定位一个使用32位PC相对地址的引用 R_X86_64_32 重定位一个使用32位绝对地址的引用 重定位符号引用\n重定位PC相对引用 重定位绝对引用 可执行目标文件\n可执行目标文件的格式类似于可重定位目标文件的格式。ELF头描述文件的总体格式。它还包括程序的入口点，也就是当程序运行时要执行的第一条指令的地址。.text、.rodata和.data节与可重定位目标文件中的节是相似的，除了这些节已经被重定位到它们最终的运行时内存地址以外。.init节定义了一个小函数，叫做_init，程序的初始化代码会调用它。因为可执行文件是完全链接的（已被重定位），所以它不再需要.rel节。\n加载可执行目标文件\n在Linux shell的命令行中我们可以使用./programName的方式调用可执行目标文件 programName。因为programName不是一个内置的shell命令，所以shell会认为它是一个可执行目标文件，通过调用某个驻留在存储器中称为加载器（loader）的操作系统代码来运行它。任何Linux程序都可以通过调用execve函数来调用加载器。加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。这个将程序复制到内存并运行的过程叫做加载。\n共享链接共享库\n静态库的缺点：需要定期维护和更新，一些代码会复制到每个运行进程的广西上。是对稀缺的内存系统资源的极大浪费。共享库（shared library）是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接（dynamic linking）,是由一个叫做动态链接器（dynamic linker）的程序来执行的。共享库也称为共享目标（shared object)，在Linux系统中通常用.so缀来表示。微软的操作系统大师地使用了共享库，它们称为DDL。共享库是以两种不同的方式来“共享”的。\n首先，在任何给定的文件系统中，对于一个库只有一个.so文件。所有引用该库的可执行目标文件共享这个.so文件中的代码和数据，而不是像静态库的内容那样被复制和嵌入到引用它们的可执行的文件中。 其次，在内存中，一个共享库的.text节的一个副本可以被不同的正在运行的进程共享。 一个例子，使用共享库libvector.so: -fpic选项指示编译器生成与位置无关的代码。 -shared选项指示链接器创建一个共享的目标文件。\ngcc -shared -fpic -o libvector.so addvec.c multvec.c 从应用程序中加载和链接共享库 位置无关代码\n共享库的一个主要目的就是允许多个正在运行的进程共享内存中的相同的库代码，因而节约富贵的内存资源。\nPIC数据引用\n编译器通过运用以下这个有趣的事实来生成对全局变量的PIC引用：无论我们在内存中的休息加载一个目标模块（包括共享目标模块），数据段与代码段的距离总是保持不变。因此，代码段中任何指令和数据上任何变量之间距离都是一个运行时常量，与代码段和数据wdmr绝对内存位置是无关的。想要生成对全局变量PIC引用的编译器利用了这个事实，它在数据段开始的地方创建了一个表，叫做全局统称量表（Global Offset Table, GOT）。在GOT中，每个被这个目标模块引用的全局数据目标（过程或全局变量）都有一个8字节条目。编译器还为GOT中每个条目生成一个重定位记录。在加载时，动态链接器会重定位GOT中的每个条目，使得它包含目标的正确的绝对地址。每个引用全局目标的目标模块都有自己的GOT.\nPIC函数调用\n假设程序调用一个由共享库定义的函数。编译器没有办法预测这个函数的运行时地址，因为定义它的共享模块在运行时可以加载到任意位置。GNU编译系统使用了一种很有趣的技术来解决这个问题，称为延迟绑定(lazy binding)，将过程地址的绑定推迟到第一次调用该过程时。所以第一次调用过程的运行时开销很大，但是其后的每次调用都只会花费一条指令和一个间接的内存引用。延迟绑定是通过两个数据结构之间简洁但又有些复杂的交互来实现的，这两个数据结构是：GOT和过程链接表（Procedure Linkage Table, PLT）。如果一个目标模块调用定义在共享库中的任何函数，那么它就有自己的GOT和PLT.\n库打桩机制\nLinux链接器支持一很强大的技术，称为库打桩（library interpositioning)，它允许你截获对共享库函数的调用，取而代之执行自己的代码。打桩可以发生在编译时、链接时或当程序被加载和执行的运行时。\n编译时打桩\n在gcc时使用-I参数进行打桩\n链接时打桩 运行时打桩 处理目标文件工具\n在Linux系统中有大量可用的工具可以理解和处理目标文件。特别地，GNU binutils包尤其有帮助，而且可以运行在每个Linux上。\nAR：创建静态库，插入、删除、列出和提取成员。 STRINGS：列出一个目标文件中所有可打印的字符串。 STRIP：从目标文件中删除符号表信息。 NM：列出一个目标文件符号表中定义的符号 SIZE：列出目标文件中节的名字和大小。 READELF： 显示一个目标文件的完整结构，包括ELF头中编码的所有信息。包含SIZE和NM的功能。 OBJDUMP：所有二进制工具之母。能够显示一个目标文件中所有的信息。它最大的作用是反汇编.text节中的二进制指令。 Linux系统为操作共享库还提供了LDD程序：\nLDD： 列出一个可执行文件在运行时所需要的共享库。 异常控制流 现代系统通过使控制流发生突变来对这些情况做出反应。一般而言，我们把这些突变称为异常控制流（Exceptional Control Flow, ECF）。\nECF的重要性\n理解ECF将帮助你理解重要的系统概念 理解ECF将帮助你理解应用程序是如何与操作系统交互的。 理解ECF将帮助你编写有趣的新应用程序。 理解ECF将帮助你理解并发。 理解ECF将理解软件异常如何工作。 异常 异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。异常就是控制流中的突变，用来响应处理器状态中的某些变化。在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做异常表（exception tablee）的跳转表，进行一个间接过程调用（异常），到一个专门设计用来处理这类事件的操作系统子程序（异常处理程序（exception handler））。当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下3种情况中的一种：\n处理程序将控制返回给当前指令，即当事件发生时正在执行的指令。 处理程序将控制返回给将会执行的下一条指令。 处理程序终止被中断的程序。 异常处理\n系统中可能的每种类型的异常都分配了一个唯一的非负整数的异常号（exception number）。其中一些号码是由处理器的设计者分配的，其他号码是由操作系统内核的设计者分配的。当系统启动时（当计算机重启或者加电时），操作系统分配和初始化一张称为异常表的跳转表，使得K包含异常K的处理程序的地址。异常号是到异常表中的索引，异常表的起始地址放在一个叫做异常表基地址寄存器（exception table base register）的特殊CPU寄存器里。\n异常处理类似于过程调用，但是有一些重要的不同之处： 过程调用时，在跳转到处理器程序之前，处理器将返回地址压入栈中。然后，根据异常的类型，返回地址要么是当前指令（当事件发生时正在执行的指令），要么是下一条指令（如果事件不发生，将会在当前指令后执行的指令）。 处理器也把一些额外的处理器状态压到栈里，在处理程序返回时，重新开始执行被中断的程序会需要这些状态。 如果控制从用户程序转移到内核，所有这些项目都被压到内核中，而不是压到用户栈中。 异常处理程序运行在内核模式下，这意味着它们对所有的系统资源都有完全的访问权限。 一旦硬件触发了异常，剩下的工作就是由异常处理程序在软件中完成。在处理程序处理完事件后，它通过执行一条特殊的“从中断返回”指令，可选地返回到被中断的程序，该指令将适当的状态绞架到处理器控制和数据寄存器中，如果异常中断的是一个用户程序，就将状态恢复为用户模式，然后将控制返回给被中断的程序。\n异常的类别\n异常可以分为四类：中断（interrupt），陷阱（trap），故障（fault）和终止（abort）.\nTable 3: 异常分类的属性 类别 原因 异常/同步 返回行为 中断 来自IO设备的信号 异步 总是返回到下一条指令 陷阱 有意的异常 同步 总是返回到下一条指令 故障 潜在可恢复的错误 同步 可能返回到当前指令 终止 不可恢复的错误 同步 不会返回 中断\n中断是异步发生的，是来自处理器外部的IO设备的信号的结果。硬件的中断的异常处理程序常常称为中断处理程序（interrupt handler）。剩下的异常类型（陷阱，故障和终止）是同步发生的 ，是执行当前指令的结果。我们把这类指令叫做故障指令（faulting instruction）。\n陷阱和系统调用\n陷阱是有意的异常，是执行一条指令的结果。就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用。从程序员的角度来看，系统调用和普通的函数调用是一样的。然而，它们的实现非常不同。普通的函数运行在用户模式中，用户模式限制了函数可以执行的指令的类型，而且它们只能访问与调用函数相同的栈。系统调用运行在内核模式中，内核模式允许系统调用执行特权指令，并访问定义在内核中的栈。\n故障\n故障由错误情况引起，它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的abort例程，abort例程会终止引起故障的应用程序。\n终止\n终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如DRAM或者SRAM位被损坏时发生的奇偶错误。终止处理程序从不将控制返回给应用程序。\nLinux/x86-64系统中的异常\nx86-64系统定义了一些异常有高达256种，0-31的号码对应的是由Intel架构师定义的异常，因此对任何x86-64系统都是一样的。32-255的号码对应的是操作系统定义的中断和陷阱。\nLinux/x86-64故障和终止 Linux/x86-64系统调用\n我们将系统调用和与它们相关联的包装函数都称为系统级函数，这两个术语可以互换使用。在x86-64系统上，系统调用 是通过一条称为syscall的陷阱指令来提供的。所有到Linux系统调用的参数都是通过通用寄存器而不是栈传递的。按照惯例，寄存器%rax包含系统调用号，寄存器%rdi、% rsi、%rdx、%10、%r8和%r9包含最多6个参数。从系统调用返回时，寄存器%rcx和%r11都会被破坏，%rax包含返回值。\nTable 4: Linux x86-64系统中常用的系统调用示例 编号 名字 描述 0 read 读文件 1 write 写文件 2 open 打开文件 3 close 关闭文件 4 stat 获得文件信息 9 mmap 将内存页映射到文件 12 brk 重置堆顶 32 dup2 复制文件描述符 33 pause 挂起进程直到信号到达 37 alarm 调度告警信号的传送 39 getpid 获得进程ID 57 fork 创建进程 59 execve 执行一个程序 60 _exit 终止进程 61 wait4 等待一个进程终止 62 kill 发送信号到一个进程 进程 异常是允许操作系统内核提供进程（process）概念的基本构造块，进程是计算机科学中最深度、最成功的概念之一。在现代系统上运行一个程序时，我们会到一个假象，就好像我们的程序是系统中当前运行的唯一的程序一样。我们的程序好像是独占地使用处理器和内存。进程的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文（context）中。上下文是由程序正确运行所需的状态组成的。它个状态包括存放在内存中的程序的代码和数据，它的栈、通用上的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。我们将关注进程提供给应用程序的关键抽象：\n一个独立的控制流，它提供一个假象，好像我们的程序独占地使用处理器。 一个私有的地址pwuj，它提供一个假象，好像我们的程序独占地使用内存系统。 逻辑控制流\n实际上进程昌轮流使用处理器的。每个进程执行它的流的一部分，然后被抢占（preempted）(暂时挂起)，然后轮到其他进程。\n并发流\n一个逻辑流的执行在时间上与另一个流重叠，称为并发流（concurrent flow），这两个流被称为并发地运行。多个流并发地执行的一般现象被称为并发（concurrency）。一个进程和其他进程轮流运行的概念称为多任务（multitasking）。一个进程执行它的控制流的一部分的每一时间叫做时间片（time slice）。因此，多任务也叫做时间分片（time slicing）。如果两个流并发地运行在不同的处理器核或者计算机上，那么我们称它们为并行流（parallel flow），它们并行地运行（running in parallel），且并行地执行（parallel execution）。\n私有地址空间\n进程也为每个程序提供一种假象，好像它独占地使用系统地址空间。\n用户模型和内核模式\n为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。处理器通常是用某个控制寄存器中的一个模式们（mode bit）来提供这种功能的，该寄存器描述了进程当前享有的特权。当设置了模式位时，进程就运行在内核模式中（有时叫做超级用户模式）。一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。没有设置模式位时，进程就运行在用户模式中。用户模式中的进程不允许执行特权指令（privileged instruction），也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。运行应用程序代码的进程初始时是在用户模式中的。进程从用户模式变为内核模式的唯一方法是通过诸如中断、故障或者陷入系统调用这样的异常。当异常发生时，控制传递到异常处理程序，处理器将模式从用户模式变为内核模式。 Linux提供了一种聪明的机制，叫做/proc文件系统，它允许用户模式进程访问内核数据结构的内容。/proc文件系统将许多内核数据结构的内容输出为一个用户程序可以yfnr广西文件的层次结构。\n上下文切换\n操作系统内核使用一种称为上下文切换（context switch）的较高层形式的异常控制流来实现多任务。内核为每个进程维持一个上下文（context）。上下文誻内核重新启动一个被抢占的进程所需的状态。安由一些对象的值组成，这些对象包括通用上的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做调度（scheduling），是由内核中称为调试器的（scheduler）的代码处理的。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程。上下文切换会：\n保存当前进程的上下文 恢复某个先前被抢占的进程被保存的上下文 将控制传递给这个新恢复的进程 当内核代表用户执行系统调用时，可能会发生上下文切换。如果系统调用因为等待某个事件发生而阻塞，那么内核可以让当前进程休眠，切换到另一个进程。\n系统调用错误处理 当Unix系统级函数遇到错误时，它们通常会返回-1,并设置全局整数变量errno来表示什么出错了。\n进程控制 获取进程ID\n每个进程都有一个唯一的正数（非零）进程ID（PID）。getpid函数返回调用进程的PID。getppid函数返回它的父进程的PID.\n#include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main() { pid_t pid = getpid(); printf(\u0026quot;current pid: %d\\n\u0026quot;, pid); return 0; } getpid和getppid函数返回一个类型为pid_t的整数值，在Linux系统上它在types.h中被定义为int。\n创建和终止进程\n从程序员的角度来看，我们可以认为进程总是处于下面三种状态之一：\n运行：进程要么在CPU上运行，要么在等待被执行且最终会被内核调度。 停止：进程的执行被挂起（suspended）,且不会被调试。 终止：进程永远地停止了。进程会因为三种原因终止： 收到一个信号，该信号的默认行为是终止进程 从主程序返回 调用exit函数 创建进程\n父进程通过调用fork函数创建一个新的运行的子进程。新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用fork时，子进程可以读写父进程打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的PID. fork函数是有趣的，因为它只被调用一次，却会返回两次：一次是在调用进程（父进程）中，一次是在新创建的子进程中。在父进程中，fork函数返回子进程的PID.在子进程中，fork返回0.\n回收子进程\n当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收（reaped）。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后热度已终止的进程，从此时开始，该进程就不存在了。一个终止了但还未被回收的进程被称为僵死进程(zommbie)。如果一个父进程终止了，内核会安排init进程成为它的孤独进程的养父。一个进程可以通过调用waitpid函数来等待它的子进程终止或者停止。 waitpid函数有点复杂。默认情况下（当options=0时），waitpid挂起调用进程的执行，直到它的等待集合中的一个子进程终止。如果等待集合中的一个进程在刚调用的时刻就已经终止了，那么waitpid就立即返回。在这两种情况中，waitpid返回导致waitpid返回的已终止子进程的pid。\n判断等待集合的成员等待集合的成员是由参数pid来确定的：\n如果Pid\u0026gt;0,那么等待集合就是一个单独折子进程，它的进程id等于pid。 如果Pid=-1,那么等待集合就是由父进程所有的子进程组成的。 修改默认行为可以通过将options设置为常量以下值修改默认行为\nWNOHANG WUNTRACED WCONTINUED 还可以用或运算把这些选项组合起来，例如：WNOHANG | WUNTRACED\n检查已回收子进程的退出状态如果statusp参数是非空的，那么waitpid京会在status中放上关于导致返回的子进程的状态信息，status是statusp指向的值。\n错误条件如果调用进程没有子进程，那么waitpid返回-1,并设置errno为ECHILD。如果waitpid函数被一个信号中断，那么它返回-1,并设置errno为EINTR。\nwait函数 wait函数是waitpid函数的简单版本。调用wait(\u0026amp;status)行人于调用waitpid(-1, \u0026amp;status, 0)。\n让进程休眠\nsleep函数将一个进程挂起一段指定的时间。\n#include \u0026lt;unistd.h\u0026gt; unsigned int sleep(unsigned int secs); 如果请求的时间量已经到了，sleep返回0,否则返回还剩下的要休眠的秒数。\n加载并运行程序\nexecve函数在当前进程的上下文中加载并运行一个新程序。\n#include \u0026lt;unistd.h\u0026gt; int execve(const char *filename, const char *argv[], const char *envp[]); execve函数加载并运行可执行目标文件filename,且带参数列表argv和环境变量列表envp。只有当出现错误时，例如找不到filename，execve才会返回到调用程序。所以，与fork一次调用返回两次不同，execve调用一次并从不返回。\n利用fork和execve运行程序 信号 一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。\nTable 5: Linux信号 序号 名称 默认行为 相应事件 1 SIGHUP 终止 终端线挂断 2 SIGINT 终止 来自键盘的中断 3 SIGQUIT 终止 来自键盘的退出 4 SIGILL 终止 非法指令 5 SIGTRAP 终止并转储内存 跟踪陷阱 6 SIGABRT 终止并转储内存 来自abort函数的终止信号 7 SIGBUS 终止 总线错误 8 SIGFPE 终止并转储内存 浮点异常 9 SIGKILL 终止 杀死程序 10 SINUSR1 终止 用户定义的信号1 11 SIGSEGV 终止并转储内存 无效的内存引用（段故障） 12 SIGUSR2 终止 用户定义的信号2 13 SIGPIPE 终止 向一个没有读用户的管道做写操作 14 SIGALRM 终止 来自alarm函数的定时器信号 15 SIGTERM 终止 软件终止信号 16 SIGSTKFLT 终止 协处理器上的栈故障 17 SIGCHLD 忽略 一个子进程停止或者终止 18 SIGCONT 忽略 继续进程如果该进程停止 19 SIGSTOP 停止直到下一个SIGCONT 不是来自终端的停止信号 20 SIGTSTP 停止直到下一个SIGCONT 严自终端的停止信号 21 SIGTTIN 停止直到下一个SIGCONT 后台进程从终端读 22 SIGTTOU 停止直到下一个SIGCONT 后台进程向终端写 23 SIGURG 忽略 套接字上的紧急情况 24 SIGXCPU 终止 CPU时间限制超出 25 SIGXFSZ 终止 文件大小限制超出 26 SIGVTALRM 终止 虚拟定时器期满 27 SIGPROF 终止 剖析定时器期满 28 SIGWINCH 忽略 窗口大小变化 29 SIGIO 终止 在某个描述符上可执行IO操作 30 SIGPWR 终止 电源故障 信号术语\n传送一个信号到目的进程是由两个不同步骤组成的：\n发送信号：内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程。 接收信号：当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。 一个发出而没有被接收的信号叫做待处理信号。在任何时刻，一种类型至多只会有一个待处理信号。如果一个进程有一个类型为k的待处理信号，那么任何接下来发送到这个进程的类型为k的信号都不会排队等待;它们只是被简单地丢弃。一个进程可以有选择性地阻塞接收某种信号。当一种信号被阻塞时，它仍可以被发送，但是产生的待处理信号不会被接收，直到进程取消对这种信号的阻塞。一个待处理信号最多只能被接收一次。\n发送信号\nUnix系统提供了大量向进程发送信号的机制。所有之些机制都是基于进程组（process group）这个概念的。\n进程组每个进程都只属于一个进程组，进程组是由一个正整数进程组ID来标识的。getpgrp函数返回当前进程的进程组ID 默认地，一个子进程和它的父进程同属于一个进程组。一个进程可以通过使用setpgid函数来改变自己或者其他进程的进程组。 #include \u0026lt;unistd.h\u0026gt; int setpgid(pid_t pid, pid_t pgid); setpgid函数将进程pid的进程组改为pgid。如果pid是0,那么就使用当前进程的pid。如果pgid是0,那么就用pid指定的进程的进程的pid作为进程组ID. 用/bin/kill程序发送信号 从键盘发送信号 用kill函数发送信号进程通过调用kill函数发送信号给其他进程（包括它们自己） #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;signal.h\u0026gt; int kill(pid_t pid, int sig); 如果pid大于零，那么kill函数发送信号号码sig给进程pid.如果pid等于零，那么kill发送信号sig给调用进程所在进程组中的每个进程，包括调用进程自己。如果pid小于零，kill发送信号sig给进程组|pid（pid的绝对值）中的每个进程。 用alarm函数发送信号进程可以通过调用alarm函数向它自己发送SIGALRM信号 #include \u0026lt;unistd.h\u0026gt; unsigned int alarm(unsigned int secs); alarm函数安排内核在secs秒后发送一个SIGALRM信号给调用进程。 接收信号\n当内核把进程p从内核模式切换到用户模式时，它会检查p进程的未被阻塞的待处理信号的集合，如果这个集合为空，那么内核将控制传递到p的逻辑控制流中的下一条指令。如果集合是非空的，那么内核选择集合中的某个信号K（通常是最小的K），并且强制p接收信号K.收到这个信号会触发进程采取某种行为。一旦进程完成了这个行为，那么控制就传递回p的逻辑控制流中的下一条指令。每个信号类型都有一个预定义的默认行为，是下面中的一种：\n进程终止 进程终止并转储内存 进程停止（挂起）直到被SIGCONT信号重启 进程忽略该信号 阻塞和解除阻塞信号\nLinux提供阻塞信号的隐匿和的机制：\n隐式阻塞机制。内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。 显式阻塞机制。应用程序可以使用sigprocmask函数和它的辅助函数，明确地阻塞和解除阻塞选定的信号。 编写信号处理程序\n信号处理是Linux系统编程最棘手的一个问题。处理程序有几个属性使得它们很难推理分析：\n处理程序与主程序并发运行，共享同样的全局变量，因此可能与主程序和其他处理程序互相干扰 如何以及何时接收信号的规则常常有违人的直觉 不同的系统有不同的信号处理语义 安全的信号处理\n一些保守的编写处理程序的原则\n处理程序要尽可能简单 在处理程序中只调用异步信号安全的函数异步信号安全的函数能够被信号处理程序安全地调用，原因有二：要么它可重入的，要么它不能被信号处理程序中断。 保存和恢复errno 许多Linux异步信号安全的函数都会在出错返回时设置errno.在处理程序中调用这样的函数可能会干扰主程序中其他依赖于errno的部分。 阻塞所有信号，保护对共享全局数据结构的访问。如果处理程序和主程序或其他处理程序共享一个全局数据结构，那么在访问该数据结构时，你的处理程序和主程序应该暂时阻塞所有的信号。 用volatile声明全局变量 volatile类型限定符定义一个变量，告诉编译器不要缓存这个变量。 用sig_atomic_t声明标志在常见的处理程序设计中，处理程序会写全局标志来记录收到 的信号。主程序周期性地读这个标志，响应信号，再清除该标志。对于通过这种方式来共享的标志，C提供一种整形数据类型sig_atomic_t,对它的读和写保证会是原子的（不可中断的），因为可以用一条指令来实现它们： volatile sig_atomic_t flag; 正确的信号处理\n信号的一个与直觉不符的方面是未处理的信号是不排队的。因为pending位微量中每种类型的信号只对应有一位，所以每种类型最多只能有一个未处理的信号。因此，如果两个类型k的信号发送给一个目的进程，而因为目的的进程当前正在执行信号k的处理程序，所以信号k被阻塞了，那么第二个信号就简单地被丢弃了; 它不会排队。\n可移植的信号处理\nUnix信号处理的另一个缺陷在于不同的系统有不同的信号处理语义。\nsignal函数的语义各有有不同。有些老的Unix系统在信号k被处理程序捕获之后就把对信号k的反应恢复到默认值。在这些系统上，每次运行之后，处理程序必须调用signal函数，显式地重新设置它自己。 系统调用可以被中断像read、write和accept这样的系统调用潜在地会阻塞进程一段较长的时间，称为慢速系统调用。在某些较早的Unix系统中，当处理程序捕获到一个信号时，被中断的慢速系统调用在信号处理程序返回时不再继续，而是立即返回给用户一个错误条件，并将errno设置为EINTR。在这些系统上，程序员必须包括手动重启被中断的系统调用的代码。 要解决这些问题，Posix标准定义了sigaction函数，它允许用户在设置信号处理时，明确指定他们想要的信号处理语义。\n#include \u0026lt;signal.h\u0026gt; int sigaction(int signum, struct sigaction *act,, struct sigaction *oldact); // 若成功则为0,出错则为-1 sigaction函数运用并不广泛，因为它要求用户设置一个复杂结构的条目。一个更简洁的方式，就是定义一个包装函数，称为Signal,它调用sigaction.它的调用方式与signal函数的调用方式一样。 Signal包装函数设置了一个信号处理程序，其信号处理语义如下：\n只有这个处理程序当前正在处理的那种类型的信号被阻塞。 和所有信号实现一样，信号不会排队等待。 只要可能，被中断的系统调用会自动重启。 一旦设置了信号处理程序，它就会一直保持，直到Signal带着handler参数为SIG_IGN或者SIG_DFL被调用。 同步流以避免的并发错误\n一般而言，流可能交错的数量与指令的数量呈指数关系。这些交错中的一些会产生正确的结果，而有些则不会。基本的问题是以某种方式同步并发流，从而得到最大的可行的交错的集合，每个可行的交错都能得到正确的结果。\n显式地等待信号\n有时候主程序需要显式地等待某个信号处理程序运行。例如，当Linux shell创建一个前台作业时，在接收下一条用户命令之前，它必须等等作业终止，被SIGCHLD处理程序回收。\n非本地跳转 C语言提供了一种用户级异常控制流形式，称为非本地跳转（nonlocal jump）,它将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用-返回序列。非本地跳转是通过setjmp和longjmp函数来提供的。\n操作进程的工具 Linux系统提供了大量的监控和操作进程的有用工具。\n虚拟内存 一个系统中的进程是与其他进程共享CPU和主存资源的。为了更加有效地管理内存并且少出错，现代系统提供了一种对主存的抽象概念，叫做虚拟内存（VM）。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大小、一致的和私有的地址空间。通过一个很清晰的机制，虚拟内存提供了三个重要的能力：\n它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。 它为每个进程提供了一致的地址空间，从而简化了内存管理。 它保护了每个进程的地址空间不被其他进程破坏。 我们为什么还需要理解虚拟内存：\n虚拟内存是核心的 虚拟内存是强大的 虚拟内存是危险的 物理和虚拟寻址 计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组，每个字节都有一个唯一的物理地址。给定这种简单的结构，CPU访问内存的最自然的方式就是使用物理地址。我们把这种方式称为物理寻址。早期的PC使用物理寻址，然而，现代处理器使用的是一种称为虚拟寻址的寻址形式。使用虚拟寻址，CPU通过生成一个虚拟地址来访问主存，这个虚拟地址在被送到内存之前先转换成适当的物理地址。将一个虚拟地址转换为物理地址的任务叫做地址翻译。CPU芯片上叫做内存管理单元（MMU）的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理。\n地址空间 地址空间是一个非负数地址的有序集合。一个地址空间的大小是由表示最大地址所需要的倍数来描述的。例如，一个包含N等于2的n次方的虚拟地址空间就叫做一个n位地址空间。现代系统通常支持32位或64位虚拟地址空间。一个系统还有一个物理地址空间，对应于系统中物理内存的M个字节。地址空间清楚地区分了数据对象（字节）和它们的属性（地址）。主存中的每字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。\n虚拟内存作为缓存的工具 概念上，虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组.每字节都有一个唯一的虚拟地址，作为到数组的索引。硬盘上的数组的内容被缓存在主存中。物理内存被分割为物理面，大小为P字节（物理页也被称为页帧（page frame））。在任意时刻，虚拟页面的集合都分为三个不相交的子集：\n未分配的：VM系统还未分配（或者创建）的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。 缓存的：当前已缓存在物理内存中的已分配页。 未缓存的：未缓存在物理内存中的已分配页。 DRAM缓存的组织结构\n我们使用术语SRAM缓存来表示位于CPU和主存之间的L1,L2，和L3调整缓存，使用术语DRAM缓存来表示虚拟内存系统的缓存，它在主存中缓存虚拟页。与硬件对SRAM缓存相比，操作系统对DRAM缓存使用了更复杂精密的替换算法。因为对磁盘的访问时间很长，DRAM缓存总是使用写回，而不是直写。\n页表\n同任何缓存一样，虚拟内存系统必须有某种方法来判定一个虚拟页是否缓存在DRAM中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理内存中造势一个牺牲页，并将虚拟页从磁盘复制到DRAM中，替换这个牺牲页。这个功能是由软硬伯联合提供的，包括操作系统软件、MMU（内存管理单元）中的地址翻译硬件和一个存放在物理内存中叫做页表（page table）的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。操作系统负责维护页表的内容，以及在磁盘与DRAM之间来回传送页。\n页命中 缺页\n在虚拟内存的习惯说法中，DRAM缓存不命中称为缺页（page fault）。在磁盘和内存之间传送页的活动叫做交换（swapping）或者页面调度（paging)。\n分配页面 又是性救了我们\n尽管在整个运行过程中程序引用的不同页面的总数可能超出物理内存总的大小，但是局部性原则保证了在任意时刻，程序将趋向于在一个较小的活动页面（active page）集合上工作，这个集合叫做工作集（working set）或者常驻集合（resident set）。\n虚拟内存作为内存管理的工具 虚拟内存提供了一种机制，利用DRAM缓存来自通常更大的虚拟地址空间的页面。操作系统为每个进程提供了一个独立的页表，因而也就是一个独立的虚拟地址空间。按需页面调度和独立的虚拟地址空间的结合，对系统中内存的使用和管理造成了深远的影响。特别地，VM简化了链接和加载、代码和数据共享，以及应用程序的内存分配。\n简化链接独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处。 简化加载虚拟内存还使得容易向内存中加载可执行文件和共享对象文件。将一组连续的虚拟页映射到任意一个文件中的任意位置的表示法称作内存映射（memory mapping）。Linux提供一个称为mmap的系统调用，允许应用程序自己做内存映射。 简化共享独立地址空间为操作系统提供了一个管理用户进程和操作系统自身之间共享的一致机制。然而，在一些情况中，还是需要进程来共享代码和数据。例如，每个进程必须调用相同的操作系统内核代码，而每个C程序都会调用C标准库中的程序。操作系统通过将不同进程中适当的虚拟页面映射到相同的物理页面，从而安排多个进程共享这部分代码的一个副本，而不是在每个进程中都包括单独的内核和C标准库的副本。 简化内存分配虚拟内存为向用户进程提供一个简单的分配额外内存的机制。 虚拟内存作为内存保护的工具 任何现代计算机系统必须为操作系统提供手段来控制对内存系统的访问。\n地址翻译 内存映射 Linux通过将一个虚拟内存区域与磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射(memory mapping)。虚拟内存区域或以映射到两种类型的对象中的一种：\nLinux文件系统中的普通文件 匿名文件 动态内存分配 动态内存分配器维护着一个进程的虚拟内存区，称为堆。分配器将堆视为一组不同大小的块（block）的集合来维护。每个块就是一个连续的虚拟内存处，要么是已分配的，要么是空闲白的，已分配的块显示地保留为供应用程序使用。空闲块可用来分配。分配器有两种基本风格。\n显式分配器要求应用显式地释放任何已分配的块。 隐式分配器要求分配器检测一个已分配块何时不再被程序所使用，那么就翻译这个块。隐式分配器也叫做垃圾收集（garbage collection）。 malloc和free函数\nmalloc函数返回一个指针，指向大小为至少需要分配的size字节的内存块，这个块会为可能包含在这个块内的任何数据对象类型做对齐。在32位模式中， malloc返回的块的地址总是8的倍数。在64位模式中，该地址总是16的倍数。如果malloc遇到问题，那么它就返回NULL，并设置errno。\n为什么要使用动态内存分配\n程序使用动态内存分配的最重要的原因是经常直到程序实际运行时，才知道某些数据结构的大小。\n分配器的要求和目标\n显式分配器必须在一些相当严格的约束条件下工作：\n处理任意请求序列。 立即响应请求 只使用堆 对齐块（对齐要求） 不修改已分配的块。 在这些限制条件下，分配器的编写者试图实现吞率最大化和内存使用率最大化，而这两个性能目标通常是相互冲突的。\n最大化吞率 最大化内存利用率 碎片\n造成堆利用率很低的主要原因是一种称为碎片(fragmentation)的现象，当虽然有未使用的内存但不能用来满足分配请求时，就会发生这种现象。有两种形式的碎片：内部碎片（internal fragmentation）和外部碎片（external fragmentation）。\n内部碎片是在一个已分配块比有效载荷大时发生的。 外部碎片是当空闲内存合计起来足够满足一个分配请求，但是没有一个单独的空闲块足够大可以来处理这个请求时发生的。 隐式空闲链表\n任何实际的分配器都需要一些数据结构，允许它来区别块边界，以及区别已分配块和空闲块。\n分割空闲块\n一旦分配器找到一个匹配的空闲块，它就必须做另一个策略决定，那就是分配这个空闲块中多少空间。\n获取额外的堆内存\n如果分配器不能为请求块找到合适的空闲块将发生什么？一个选择是通过合并那些在内存中物理上相信的空闲块来创建一些更大的空闲块。然而，如果这样还是不能生成一个足够大的块，或者如果空闲块已经最大程度地合并了，那么分配器就会通过调用sbrk函数，向内核请求额外的堆内存。\n合并空闲块\n为了解决假碎片问题，任何实际的分配器都必须合并相信的空闲块，这个过程称为合并（coalescing）。何时合并？\n可以是立即合并，也就是在每次一个块被释放时，就合并所有的相信块。立即合并可以在常数时间内执行完成，但是对于某些请求模式，这种方式会产生一种形式的拉动，块会反复地合并，然后马上分割。 可以推迟合并，也就是等到某个的时候再合并空闲块。 带边界标记的合并 显式空闲链表 分离的空闲链表\n简单分离存储\n使用简单分离存储，每个大小类的空闲链表包含大小相等的块，每个块的大小就是这个大小类中最大元素的大小。为了分配一个给定大小的块，我们检查相应的空闲链表。如果链表非空，我们简单地分配其中第一块的全部。空闲块是不会分割以满足分配请求的。如果链表为空，分配器就向操作系统请求一个固定大小的额外内存片，将这个片分成大小相等的块，并将这些块链接起来形成新的空闲链表。\n优点\n分配和释放块都是很快的常数时间操作。 每个片中都是大小相等的块，不分割，不合并，这意味着每个块只有每少的内存开销。 已分配块不需要头部，同时因为没有合并，它们也不需要脚部。 在任何块中都需要的唯一字段是每个空闲块中的一个字的succ指针，因此最小块大小就是一个字。 缺点\n很容易造成内部和外部碎片。\n因为空闲块是不会被分割的，扬剧脍 造成内部碎片。 因为不会合并空闲块，所以某些引用模式会引起极多的外部碎片。 分离适配\n分配器维护着一个空闲链表的数组。每个空闲链表是和一个大小类相关联的，并且被组织成某种类型的显式或隐式链表。每个链表包含潜在的大小不同的块，这些块的大小是大小类的成员。有许多种不同的分离适配分配器。分离适配方法是一种常见的选择，C标准库中提供的GNU malloc包就是采用的这种方法。\n伙伴系统\n是分离适配的一种特使，其中每个大小类都是2的幂。\n垃圾收集 垃圾收集器(garbage collector)是一种动态内存分配器，它自动释放程序不再需要的已分配块。这些块被称为垃圾。自动回收堆存储的过程叫做垃圾收集。\n垃圾收集器的基本知识\n垃圾收集器将内存视为一张有向可达图（reachability graph）。当存在一条从任意根节点出发并到达p的有向路径时，我们说节点p是可达的（reachable）。\nMark \u0026amp; Sweep 垃圾收集器\nMark\u0026amp;Sweep傅粉何郎食品在由标记（mark）阶段和清除（sweep）阶段组成，标记阶段标记出根节点的所有可达的已分配的后继，而后面的清除阶段释放每个未被标记的已分配块。\nC程序中常见的与内存有关的错误 间接引用坏指针\n在进程的虚拟地址空间中有较大的洞，没有映射到任何有意义的数据。如果我们试图间接引用一个指向这些洞的指针，那么操作系统就会以段异常中止程序。而且，虚拟内存的某些区域是只读的。试图写这些区域将会以保护异常踏上这个程序。\n读未初始化的内存\n虽然bss内存位置（诸如未初始化的全局C变量）总是被加载器初始化为零，但是对于堆内存却并不是这样的。\n允许栈缓冲区溢出\n如果一个程序不检查输入串的大小就写入栈中的目标缓冲区，那么这个程序就会有缓冲区溢出错误（buffer overflow bug）。\n假设指针和它们指向的对象是相同大小的 造成错位错误 引用指针，而不是它所指向的对象\n如果不太注意C操作符的优先级和结合性，我们就会错误地操作指针，而不是指针所指向的对象。\n误解指针运算 引用不存在的变量 引用空闲堆块中的数据\n引用已经被释放了的堆块中的数据。\n引起内存泄漏\n当程序员不小心忘记释放已分配块，而在堆里创建垃圾时，会发生这种问题。\n小结 虚拟内存是对主存的一个抽象。支持虚拟内存的处理器通过使用一种叫做虚拟寻址的间接形式来引用主存。处理器产生一个虚拟地址，在被发送到主存之前，这个地址被翻译成一个物理地址。从虚拟地址空间到物理地址空间的地址翻译要求硬件和软件紧密合并。专门的硬件通过使用页表翻译虚拟地址，而页表的内容是由操作系统提供的。虚拟内存提供三个重要的功能，第一，它在主存中自动缓存最近使用的存放磁盘上的虚拟地址空间的内容。虚拟内存缓存中的块叫做页。对磁盘上页的引用会触发缺页，缺页将控制转移到操作系统中的一个缺页处理程序。缺页处理程序将页面从磁盘复制到主存缓存，如果必要，将写回被驱逐的页。第二，虚拟内存简化了内存管理，进而又简化了链接、在进程间共享数据、进程的内存分配以及程序加载。最后虚拟内存通过在每条页表条目中加入 保护位，从而简化了内存保护。地址翻译的过程必须和系统中的所有的硬件缓存的操作集成在一起，大多数页表条目位于L1高速缓存中，但是一个称为TLB的页表条目的片上高速缓存，通常会消除访问在L1上的页表条目的开销。现代系统通过将虚拟内存片和磁盘上的文件片关联起来，来初始化虚拟内存片，这个过程称为内存映射。内存映射为共享数据、创建新的进程以及加载程序提供了一种高效的机制。应用可以使用mmap函数来手动地创建和删除虚拟地址空间的区域。然而，大多数程序依赖于动态内存分配器，例如malloc，它管理虚拟地址空间区域内一个称为堆的区域。动态内存分配器是一个感觉像系统级程序的应用级程序，它直接操作内存，而无需要类型系统的很多帮助。分配器有两种类型。显示分配器要求应用显式地释放它们的内存块。隐匿分配器（垃圾收集器）自动释放任何未使用的和不可达的块。\n程序间的交互和通信 系统级I/O I/O是在主存和外部设备（例如磁盘驱动器、终端和网络）之间复制数据的过程。输入操作是从IO设备复制数据到主丰，而输出操作是从主存复制数据到IO设备。\nUnix I/O 所有的IO设备都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行：\n打开文件一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备。 Linux shell创建的每个进程开始时都有本个打开的文件：标准输入，标准输出和标准错误。 改变当前的文件位置。对于每个打开的文件，内核保持着一个文件位置k,初始为0。这个文件位置是从文件开头起始的字节领衔量。应用程序能够通过执行seek操作，显式地设置文件的当前位置为k. 读写文件 关闭文件 文件 每个Linux文件都有一个类型来表明它在系统中的角色：\n普通文件 目录 套接字 命名通道 符号链接 字符 块设备 打开和关闭文件 进程是通过调用open函数来打开一个已存在的文件或者创建一个新文件，open函数将文件转换为一个文件描述符，并且返回描述符数字。进程通过调用close函数关闭一个打开的文件。\n读和写文件 应用程序是通过分别调用read和write函数来执行输入和输出的。通过调用lseek函数，应用程序能够显示地修改当前文件的位置。\n用RIO包健壮地读写 RIO提供了两类不同的函数\n无缓冲的输入输出函数\n这些函数直接在内存和文件之间传送数据，没有应用级缓冲。它们对将二进制数据读写到网络和从网络读写二进制数据尤其有用。\n带缓冲的输入函数 读取文件元数据 应用程序能够通过调用stat和fstat函数，检索到关于文件的信息（有时也称为文件的元数据（metadata））。\n读取目录内容 应用程序可以用readdir系统函数来读取目录的内容。函数closedir关闭流并释放其所有的资源。\n共享文件 内核用三个相关的数据结构来表示打开的文件：\n描述符表每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表项指向文件表的一个表项。 文件表打开文件的集合是由一张文件表来表示的，所有的进程共享这张表。 v-mode表同文件表一样，所有的进程共享这张v-node表。每个表项包含stat结构中的大多数信息，包括st_mode和st_size成员。 I/O重定向 Linux shell提供了I/O重定向操作符，允许用户将磁盘文件和标准输入输出联系起来。\n标准I/O C语言定义了一组高级输入输出函数，称为标准I/O库，为程序员提供了UnixI/O的较高级别的替代。这个库（libc）提供了打开和关闭文件的函数（fopen和fclose）、读和写字节的函数（fread和fwrite）、读和写字符串的函数（fgets和fputs），以及复杂的格式化的IO函数（scanf和printf）。\n网络编程 客户端-服务器编程模型 每个应用都是基于客户端-服务器模型的。客户端-服务器模型中的基本操作是事务。一个客户端-服务器事务由以下四步组成：\n当一个客户端需要服务时，它向服务器发送一个请求，发起一个事务。 服务器收到请求后，解释它，并以适当的方式操作它的资源。 服务器给客户端发送一个响应，并等待下一个请求。 客户端收到响应并处理它。 网络 客户端和服务器通常运行在不同的主机上，并且通过计算机网络的硬件和软件资源来通信。对主机而言，网络只是又一种IO设备，是数据源和数据接收方。互联网至关重要的秀发是，它能由采用完全不同和不兼容技术的种种局域网和广域网组成。每台主机和其他每台主机都是物理相连的，但是如何能够让某台源主机跨过所有这些不兼容的同络发送数据位到另一台目的主机呢？解决办法是一层运行在每台主机和跌幅器上的协议软件，它消除了不同网络之间的差异。这个软件实现一种协议，这种协议控制主机和路由器如何协同工作来实现数据传输。这种协议必须提供两种基本能力：\n命名机制。不同的局域网技术有不同和不兼容的方式来为主机分配地址。 传送机制 全球IP因特网 IP 因特网域名 套接字接口 套接字接口（socket interface）是一组函数，它们和Unix IO函数结合起来，用以创建网络应用。\n套接字地址结构\n从Linux内核的角度来看，一个套接字就是通信的一个端点。从Linux程序的角度来看，套接字就是一个有相应描述符的打开文件。\nsocket函数\n客户端和服务器使用socket函数来创建一个套接字描述符(socket descriptor)。\nconnect函数\n客户端通过调用connect函数来建立和服务器的连接。\nbind函数 listen函数 accept函数 主机和服务的转换 Web服务器 并发编程 基于进程的并发编程 构造并发程序最简单的方法就是用进程，使用那些大家都很熟悉的函数，像fork, exec, waitpid.\n基于进程的并发服务器\n一些说明：\n首先，通常服务器会运行很长的时间，所以我们必须要包括一个SIGCHILD处理程序，来回收全歼子进程的资源。 项背，父子进程必须关闭它们各自的cnnfd副本。 最后，因为套接字的文件表表项中的引用计数，直到父子进程的connfd都关闭了，到客户端的连接才会终止。 进程的优劣\n对于在父子进程间共享状态信息，进程有一个非常清晰的模型：共享文件表，但是不共享用户地址空间。进程有独立的地址空间既是优点也是缺点。这样一来，一个进程不可能不小心覆盖另一个进程的虚拟内存， 这就消除了许多令人迷惑的错误。另一方面，独立的地址空间使得进程共享状态信息变得更加困难。\n基于IO多路利用的并发编程 IO多路利用技术的基本思路就是使用seelct函数，要求内核挂起进程，只有在一个或多个IO事件发生后，才将控制返回给应用程序。\n基于IO多路复用的并发事件驱动服务器 IO多路复用技术的优劣\n优点\n它比基于进程的设计给了程序员更多的对程序行为的控制。 一个基于IO多路复用的事件驱动服务器是运行在单一进程上下文中的，因此每个逻辑流都能访问该进程的全部地址空间。这使得在流之间共享数据变得很容易。 你可以使用熟悉的调试工具，例如GDB来调试你的并发程序，就像对顺序程序那样。 事件驱动设计常常比基于进程的设计要高效的多，因为它们不需要进程上下文切换来调度新的流。 缺点\n编码复杂，并且随着并发粒度的减小，复杂性还会上升。 它不能充分利用多核处理器。 基于线程的并发编程 线程就是运行在进程上下文中的逻辑流。线程由内核自动调度。每个线程都有它自己的线程上下文（thread context），包括一个唯一的整数线程ID、栈、栈指针、程序计数器、通用目的寄存器和条件码。所有的运行在一个进程里的线程共享该进程的整个虚拟地址空间。基于线程的逻辑流结合了基于进程和基于IO多路复用的流的我。同进程一样，线程由内核自动调度，并且内核通过一个整数ID来识别线程。同基于IO多路复用的流一样，多个线程运行在单一进程的上下文中，因此共享这个进程虚拟地址空间的所有内容，包括它的代码、数据、堆、共享库和打开的文件。\n线程执行模型\n每个进程开始生命周期时都是单一线程，这个线程称为主线程，在某一时刻，主线程创建一个对等线程，从这个时间开始，两个线程就并发地运行。最后因为主线程执行一个慢速系统调用，或者因为被系统的间隔计时器中断，控制就会通过上下文切换传递到对等线程。对等线程会执行一段时间，然后控制传递回主线程，依次类推。在一些重要的方面，线程执行是不同于进程的。因为一个线程的上下文要比一个进程的上下文小得多，线程的上下文切换要比进程的上下文切换快得多。另一个不同就是线程不像进程那样，不是按照严格的父子层次来组织的。主线程和其他线程的区别公在于它总是进程中第一个运行的线程。对等(线程)池概念的主要影响是，一个线程可以杀死它的任何对等线程，或者等待它的任意对等线程终止。另外，每个对等线程都能读写相同的共享数据。\nPosix线程 创建线程\n线程通过调用pthread_create函数来创建其他线程。\n终止线程\n一个线程以下列方式之一来终止的：\n当顶层的线程例程返回时，线程会隐式地终止。 通过调用pthread_exit函数，线程会显式地终止。 某个对等线程调用Linux的exit函数，该函数终止进程以及所有与该进程相关的线程。 另一个对等线程通过以当前线程ID作为参数调用pthread_cancel函数来终止当前线程。 回收已终止线程的资源\n线程通过调用pthread_join函数来等待线程终止。\n分离线程\n在任何一个时间点上，线程是可结合的或者是分享的。一个可结合的线程能够被其他线程收回或杀毒。在被其他线程回收之前，它的内存资源是不释放的。相反，一个分离的线程是不能被其他线程回收或杀死的。它的内存资源在它终止时由系统自动释放。\n初始化线程\npthread_once函数允许你初始化与线程例程相关的状态。\n基于线程的并发服务器 多线程程序中的共享变量 线程内存模型\n一组并发线程运行在一个进程的上下文中。每个线程都有它自己的线程上下文，包括线程ID、栈、栈指针、程序计数器、条件码和通用目的寄存器值。每个线程和其它线程一起共享进程上下文的剩余部分。这包括整个用户虚拟地址空间，它是由只读文本（代码）、读/写数据、堆以及所有的共享库代码和数据区域组成的。线程也共享相同的打开文件的集合。\n将变量映射到内存\n多线程的C程序中变量根据它们的存储类型被映射到虚拟内存：\n全局变量全局变量是定义在函数之外的变量。虚拟内存的读写区域只包含每个全局变量的一个实例，任何线程都可以引用。 本地自动变量本地自动变量就是定义在函数内部但是没有static属性的变量。在运行时，每个线程的栈都包含它自己的所有本地变量的实例。 本地静态变量本地静态变量是定义在函数内部并有static属性的变量。和全局变量一样，虚拟内存的读/写区域只包含在程序中声明的每个本地静态变量的一个实例。 共享变量\n我们说一个变量是共享的，当且仅当它的一个实例被一个以上的线程引用。\n用信号量同步线程 共享变量是十分方便，但是这们也引入了同步错误的可能性。\n进度图\n进度图将n个并发线程的执行模型化为一条n维笛卡儿空间中的轨迹线。进度图将指令执行模型化为从一种状态到另一种状态的转换。转换被表示为一条从一点到相信点的有向边。合法的转换是向右或者向上的。两条指令不能在同一时刻完成。一个程序的执行历史被模型化为状态空间中的一条轨迹线。在进度图中，两个临界区的交集形成的状态空间区域被称为不安全区。任何安全轨迹线都将正确地更新共享计数器。为了保证线程化程序示例的正确执行，我们必须以某种方式同步线程，使它们总有一条安全轨迹线。\n信号量\n信号量是具有非负整数值的全局变量，只能由两种特殊的操作来处理，这两种操作被称为P和V：\nP 如果信号量是非零的，那个P将信号量减1,并且立即返回。如果信号量是0,那么就挂起这个线程，直到信号量变为非0,而一个V操作会重启这个线程。在重启之后，P操作将信号量减1,并将控制返回给调用都。 V v操作将信号量加1.如果没有任何线程阻塞在P操作等待信号量变成非零，那么V操作就会重启这些线程中的一个，然后该线程将信号量减1,完成它的P操作。 P和V的定义确保了一个正在运行的程序绝不可能进入这样一种状态，也就是一个正确初始化了的信号量有一个负值。这个属性称为信号量不变性。\n使用信号量来实现互斥\n将每个共享变量与一个信号量联系起来，然后使用P和V操作将相应的临界区包围起来。以这种方式来保护共享变量的信号量叫做二元信号量，因为它的值总是0或者1.以提供互斥为目的的二元信号量常常也称为互斥锁（mutex）。\n利用信号量来调度共享资源\n除了提供互斥之外，信号量的咖一个重要作用是高度对共享资源的访问。\n生产者-消费者问题 使用线程提高并行性 其他并发问题 线程安全\n我们能够定义出四个线程不安全函数类\n不保护共享变量的函数 保持跨越多个调用的状态的函数 返回指向静态变量的指针的函数 调用线程不安全函数的函数 可重入性\n可重入函数是指安它们被多冷战线程调用时，不会引用任何共享数据。可重入函数集合是线程安全函数的一个真子集。\n在线程化的程序中使用已存在的库函数\n大多数Linux函数，包括定义在标准C库中的函数都是线程安全的，只有一小部分是例外。\n竞争\n当一个程序的正确性依赖于一个线程要在另一个线程到达Y点之前到达它的控制流中的X点时，就会发生竞争。\n死锁\n死锁是指一组线程被阻塞了，等待一个永远也不会为真的条件。使用互斥锁加锁顺序规则可以去死锁：给定所有互斥操作一个全序，如果每个线程都是以一种顺序获得互斥锁并以相反的顺序释放，那么这个程序就是无死锁的。\n","permalink":"https://stoneepigraph.github.io/posts/csapp/","title":"csapp"},{"content":" 如何设计程序 Base 基本程序设计步骤 六个基本的程序设计步骤\n问题分析和数据定义 合约,用途说明与结果的描述,函数头部 例子 函数模板 函数定义 测试 六个步骤产生定义明确的中间结果\n问题数据类型描述 程序行为的非形式描述 说明程序行为的例子 开发程序的模板或视图 把模板转换成完整的定义 通过测试发现错误 要正确的设计程序需要做到\n分析通常使用文字表述的问题 在抽象表达问题实质的同时使用例子进行说明 用精确的语言阐明所表述的语句和注释 通过检查,测试对上述活动进行评价和修改 关注细节 简单数据的处理 学生,教师和计算机 程序只是计算速度非常快的学生,不过程序并不能理解自然语言,所以我们需要学会一门计算机语言将自然语言翻译给计算机.但程序设计需要耐心和专心,保能关注每个微小的细节,并严格规划和对规划忠诚,才能避免错误.\n数,表达式和简单程序 数和算术运算\n讲述了数和Scheme的一些基本知识\n变量和程序 字处理问题 错误 设计程序\n设计程序至少需要如下4个步骤\n理解程序的目的程序设计的目标是创建一个接收输入并产生结果的机制.因此在开发程序时应该给每一个程序一个有意义的名字,并且说明输入数据和所产生的数据的类型,这称为程序的合约. 构造并标注例子构造一个例子,并将其写入注释 程序体写出程序 测试检查程序计算所得的结果与预期数值是否相符. 设计诀窍并不能解决程序设计过程中所遇到的所有问题,它提供的是完成程序设计过程中不可避免的步骤的指导.\n领域知识\n阐明程序体通常需要与问题相关的知识,这种形式的知识称为领域知识.它可能来自简单或复杂的数学,或来自非数学学科.\n程序就是函数加上变量定义 函数的复合\n辅助函数原则: 对问题表述中所提到的或在进行实例计算中所发现的每种依赖关系都使用一个辅助函数进行明确表达.\n变量定义\n如果一个数值在程序中多次出现,应该使用变量定义给它一个名字.变量定义将一个名字与一个值相关联.\n条件表达式和函数 布尔类型和关系\n复合条件: and or not\n函数和测试条件 条件和条件函数\ncond表达式\n条件函数的设计\n数据分析和定义了解问题表述所涉及的不同情况 主体-问题主体包含的cond表达式的数目应该与不同情况的数目一样. 主体-答案最后要确定对于每一个cond子句,函数应产生什么结果. 简化检查表达式是否可以被简化. 非数值信息 (symbol=? 'oneSymbol 'anotherSymbol)\r;; 这个函数会返回两个参数是否相等.\r关于字符串\n字符串是第2种形式的符号数据.和符号(symbol)一样,字符串是一个字符序列,但被包含在双引号中. 字符串是复合数据.可以使用\u0026quot;string=?\u0026ldquo;对两个字符串进行比较.\n(string=? \u0026quot;oneString\u0026quot; \u0026quot;anotherString\u0026quot;)\r关于图像\n图像(image)是第3种形式的符号数据.图像本身并没有固有的含义,但我们往往趋向于将其和相关的信息联系在一起.\n复合数据之一,结构体 scheme提供了多种不同的数据组合方法.本节讨论结构体,结构体将固定数目的值组合为单一数据.\n结构体定义\ndrScheme允许程序设计者定义自己的结构体,用以表示属性数目固定的任何类型的对象. 通常结构体包含构造器和选择器.而构造器的前缀通常为\u0026quot;make-\u0026quot;,选择器的后缀为字段名.\n\u0026gt; (define-struct entry (name zip phone))\r\u0026gt; (make-entry 'Stone 110101 '13366331320)\r(make-entry 'Stone 110101 13366331320)\r\u0026gt; (entry-name (make-entry 'Stone 110101 '13366331320))\r'Stone\r数据定义\n数据定义是程序设计者和用户间的界面.\n设计处理复合数据的函数\n数据分析和设计在开始函数设计之前,先必须了解如何在程序设计语言中表示问题的信息. 通常使用Scheme的原子数据(数,符号和图像等)来表示信息,如果发现一个对象有N个属性,可以引入一个有N个字段的结构 体,同时给出每个字段的数据定义. 合约为了阐述合约,可以使用诸如数和符号等原子类型的数据. 模板一个读入复合数据的函数在计算中一般会使用到输入数据的组成成分. 例子 主体 测试 阶段 目标 活动 数据分析和设计 阐明数据定义 确定在问题表述中所涉及的对象的数据种类, 对于每类数据增加结构定义和数据定义 合约,用途说明和函数头部 给函数命名,说明输入和输出数据的类型, 描述函数的用途说明,阐明函数头部 给函数命名,说明输入数据的类型,输出数据的类型,指出函数的目的 Examples 例子 使用例子刻划输入和输出间的关系 搜索问题表述中的例子: 计算例子,如果可能的话,验证结果, 构造例子 模板 阐明程序框架 若参数是复合数据,使用选择器表达式填写主体,如果函数是条件式的,写出所有合适的分支 主体 定义函数 使用scheme基本操作,其他函数,选择器表达式和变量设计Scheme表达式 测试 发现错误 应用函数于例子中的输入,检查程序输出是否与预期的值相符 数据的多样性 数据混合与区分\nscheme提供了辨别数据形式的谓词\nnumber? 判断是不是数 boolean? 判断是不是布尔值 symbol? 判断是不是符号 struct? 判断是不是结构体 对于每种结构体,scheme都将引入一个谓词,如(define-struct posn (x y))结构体会引入(posn? posn-obj) 设计处理混合数据的函数\n数据分析和设计分析问题表述的任务之一就是判断该问题有没有涉及不同类型的数据. 模板模板就是把输入数据翻译成Scheme表达式. 主体模板将任务分割成多个子任务,主体就需要单独处理每一个子任务了. 再论函数复合\n在分析问题时,比起设计一个大型的数据定义,先设计多个小型数据定义,再把它们组合起来要容易的多.\n输入错误\n如果要把函数提供给他人使用,为了防止意外输入错误类型,应当定义自带检查的函数.\n语法和语义 Scheme的词汇\n基本的Scheme词汇有五类.\n\u0026lt;var\u0026gt; = x | area-of-disk | perimeter | ...\r\u0026lt;con\u0026gt; = true | false\r'a | 'doll | ...\r1 | -1 | 3/5 | 1.22 | ...\r\u0026lt;prm\u0026gt; = + | - | ...\r变量,也就是函数和值和名字 常量, 包括布尔值,符号和数值常量. 基本操作, 也是不Scheme提供的基本函数. Scheme的文法\n\u0026lt;def\u0026gt; = (define (\u0026lt;var\u0026gt; \u0026lt;var\u0026gt; ... \u0026lt;var\u0026gt;) \u0026lt;exp\u0026gt;)\r\u0026lt;exp\u0026gt; = \u0026lt;var\u0026gt;\r| \u0026lt;con\u0026gt;\r| (\u0026lt;prm\u0026gt; \u0026lt;exp\u0026gt; ... \u0026lt;exp\u0026gt;)\r| (\u0026lt;var\u0026gt; \u0026lt;exp\u0026gt; ... \u0026lt;exp\u0026gt;)\r| (cond (\u0026lt;exp\u0026gt; \u0026lt;exp\u0026gt;) ... (\u0026lt;exp\u0026gt; \u0026lt;exp\u0026gt;))\r| (cond (\u0026lt;exp\u0026gt; \u0026lt;exp\u0026gt;) ... (else \u0026lt;exp\u0026gt;))\r上述的两条方法描述了简单句和复合句的结构.所谓复合句,就是由多个语句组成的语句. 表达式的类别有六种: 变量, 常量, 基本操作, 函数调用以及两种cond表达式.\n布尔表达式\nand表达式和or表达式和not表达式\n变量定义\n(define RAADIUS 5)\r结构体的定义\ndefine-struct 在定义结构体的时候,实际上定义了几个基本操作: 包括一个构造器,若干个选择器以及一个谓词.\n(define-struct struct-name (struct-attr struct-attr ...))\r任意数目数据的处理 复合数据类型之二: 表 使用cons 例如： (cons x (cons y (cons z empty)))\n处理任意长的表 表的进一步处理 自然数 三论函数复合 使用list构造表 （define var1 (list var2 var3 \u0026hellip; varn)）\n再论任意大数据的处理 再论自引用数据定义 抽象设计 定义的相似性 -\n生成递归 知识积累 改变变量的状态 复合值的改变 总结 TIPS 本书的两个创新 本书是给出一系列明确的程序设计指导, 由此引导学生一步一步地从问题的描述出发,通过明确定义的中间过程, 得出程序.在这个过程中,学生将会学会阅读,分析,组织,实验和系统思维能力. 使用了一个全新的程序设计环境. Scheme??? ","permalink":"https://stoneepigraph.github.io/posts/book/common/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A8%8B%E5%BA%8F/","title":"如何设计程序"},{"content":" AWK语言 变量 NF： awk计算当前行的字段数量\nNR： awk计算到目前为止，读取到的行的数量\n$0: 整行内容\n$1: 第一个字段\n$N: 第N个字段\n#: 注释\n逻辑\n\u0026amp;\u0026amp; || ! 模式\nBEGIN 在第一个输入文件的第一行之前被匹配 END 在最后一个输入文件的最后一行被处理之后匹配例： awk -F \u0026lsquo;:\u0026rsquo; \u0026lsquo;BEGIN {print \u0026ldquo;id name shell\u0026rdquo;; print \u0026ldquo;\u0026rdquo;} {emp = emp + 1; print NF, $1, $NF} END {print \u0026ldquo;total rows: \u0026ldquo;, emp}\u0026rsquo; /etc/passwd expression { statements} 每碰到一个使expression为真的输入行，statements就执行， expression为真指的是其值非零或非空 regular expression {statements} 当碰到这样一个输入行时， statements就执行： 输入行含有一段字符串，而该字符串可以被regular expression匹配 compound parttern {statements} 一个复合模式将表达式用 \u0026amp;\u0026amp;(AND), ||(OR), !(NOT), 以及括号组合起来；当compound parttern为真时， statements执行。 pattern1, pattern2 { statemtnts } 一个范围模式匹配多个输入行，这些输入行从匹配pattern1的行开始，到匹配pattern2的行结束（包括这两行）， 对这其中的每一行执行statements. 流程控制\nif if (condition) statement else other statement while while (condition) { statement } for for (i = 1; i \u0026lt;= x; i = i + 1) { statement } 数组\n函数 print print(\u0026ldquo;total pay %.2f for $s\u0026rdquo;\u0026rsquo;, $1, $3) length length($1) ","permalink":"https://stoneepigraph.github.io/posts/awk/","title":"Awk入门"},{"content":" 入门 什么是Docker docker是一个容器技术。\nDocker的优势 一致的运行环境， 更轻松的迁移。 对进程进行封装隔离，容器与容器之间互不影响，更高效的利用系统资源。 通过镜像复制多个环境一致的容器。 Docker与虚拟机的对比 Docker占用磁盘少 Docker的引擎比虚拟机系统占用CPU资源低 Docker启动速度快 Docker安装管理方便 Docker从第二次部署开始轻松简捷 Docker可以每个应用使用一个服务，服务隔离 Docker推荐使用Linux，不推荐使用Windows 安装及配置 下载安装 配置 启动Docker sudo systemctl enable docker sudo systemctl start docker 创建Docker用户组 sudo groupadd docker 将当前用户添加到docker组 sudo usermod -aG docker $USER 测试Docker是否安装正确 重启Docker sudo systemctl restart docker Docker核心概念 整体架构图 仓库 Repository 定义： 用来存储Docker中的镜像。 分类： 远程仓库 本地仓库： 当前自己机器中下载镜像存储位置。 镜像 Image 定义： 一个镜像代表一个软件安装包。 特点： 只读 容器 Container 定义： 基于某个镜像启动的实例，称之为一个服务。 特定： 可读可写 常用命令 引擎， 以及镜像相关的操作 docker info docker \u0026ndash;help || docker 查看docker所有帮助命令 docker version docker 执行命令格式： docker [options] command 操作镜像images的相关命令 查看本地的镜像 docker images 下载新的镜像 docker pull dockerImageName:dockerVersion docker pull dockerImageName:@digest(摘要) 搜索镜像 docker search dockerImageName 删除镜像 docker image rm dockerImageName:dockerVersion docker image rm dockerImageId docker rmi \u0026hellip; 容器相关 Container 运行容器 docker run dockerImageName:tag | 镜像ID 映射端口 docker run -p 宿主机端口:容器内服务端口 dockerImageName 后台运行 -d 给容器命名，唯一 \u0026ndash;name containerName -it 导入容器 docker load -i dockerTag.tar 查看当前运行的容器 docker ps 查看所有的容器，包括已停止的 docker ps -a 返回正在运行的容器ID docker ps -q 重启，停止容器 docker start dockerContainerId | dockerName docker restart dockerContainerid | dockerName docker stop dockerCOntainerid | dockerName 删除容器 docker rm dockerContainerId | dockerName 强制删除， 包括正在运行的容器 docker rm -f dockerContainerid | dockerName 查看容器内运行日志 docker log dockerContainerid | dockerName 实时查看日志 -f 加入时间戳实时展示日志 -t 显示指定行数的日志 \u0026ndash;tail Number 查看容器内的进程 docker top dockerContainerid | dockerName 与容器内部进行交互 docker exec -it dockerCOntainerid | dockerName Command [args] 宿主与容器的传输文件 从容器到操作系统 docker cp dockerContainerid | dockerName :/path/file ./file 从宿主到容器 docker cp 文件 | 目录 dockerContainerid | dockerName: 容器内目录 查看容器内部细节 docker inspect dockerContainerid | dockerName 数据卷 Volume 使用： 实现襥机系统与容器之间的文件共享 特点： 数据卷可以在容器之间共享和重用。 对数据卷的修改会立即影响到对应容器。 对数据卷的更新修改，不会影响镜像。 数据卷默认会一直存在， 即使容器被删除。 使用 自定义数据卷 docker run -v 宿主机目录:容器目录:ro dockerImageId 自动创建数据卷 docker run -v 卷名:容器内路径 dockerImageId 查看卷 docker volume inspect volumeName docker volume ls 将正在运行的容器打包成镜像 docker commit -m \u0026rsquo;\u0026rsquo; -a \u0026rsquo;\u0026rsquo; dockerContainerid dockerImageName:dockerTag 将镜像备份 docker save 镜像名称:tag -o dockerBak-tag.tar 网络配置 docker容器与操作系统通信机制默认使用网桥\ndocker网络使用注意: 一般在使用docker网桥实现容器与容器通信时，都是站在一个应用角度进行容器通信。\n查看默认网桥配置 docker network ls 创建自定义网桥 docker network create brightName 删除网桥 docker network rm brightName 查看网桥信息 docker inspect brightName 删除无用的网络 docker network prune\n给一个窗口添加一个网络 docker network connect bridge_name container_name\n给一个容器删除一个网络 docker network disconnect bridge_name container_name\n网络相关\n网络模式， 使用\u0026ndash;network指定\nbridge 默认配置，隔离的网络配置 host 与宿主机使用同一个网络环境， 不需要做网络转发，不过会占用宿主机的资源，比如端口。 \u0026ndash;network host none 无网络配置 container 与指定容器使用同一个网络环境，但是文件系统还是隔离的。不过目前docker文档里没有对应的配置，有可能会在以后的更新中取消。 \u0026ndash;network container:container_name Dockerfile 定义 用来帮助我们自己构建一个自定义镜像， Dockerfile成为镜像构建文件\n核心作用 用户可以将自己应用打包成镜像，这样就可以让我们应用进行容器运行。\n原理 Tips 第一行Dockerfile都会构建成一个镜像，可以使用\u0026ndash;no-cache禁用缓存。 dockerfile所在的目录为docker的上下文目录，可以添加.dockerignore文件忽略文件 Dockerfile的相关命令 官方文档： https://docs.docker.com/engine/reference/builder/\nFROME\n指当前镜像是基于的哪个镜像， 必须为Dockerfile的第行。\nRUN\n构建镜像时需要运行的指令\nRUN yum install -y vim RUN [\u0026quot;yum\u0026quot;, \u0026quot;install\u0026quot;, \u0026quot;-y\u0026quot;, \u0026quot;vim\u0026quot;] EXPOSE\n当前容器对外暴露的端口号只要暴露了端口才可能在运行时使用-p命令映射。\nWORKDIR\n指定在创建容器后， 终端默认登录进来的工作目录可以是绝对目录也可是相对目录，如果指定的目录不存在，那么会自动创建。\nENV\n用来在构建镜像过程中设置环境变量, 在容器构建了使用时都可以使用\nARG\n在构建镜像过程中设置环境变量，在容器构建完成后消失。\nADD\n将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包\nCOPY\n类似于ADD， 拷贝文件和目录到镜像中\nVOLUME\n容器数据卷， 用于数据保存和持久化工作\nCMD\n指定一个容器启动时要运行的命令， Dockerfile中可以有多个CMD命令，但只有最后一个生效，CMD会被docker run之后的参数替换\nENTRYPOINT\n指定一个容器启动时要运行的命令， ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及参数。如果想覆盖ENTRYPOINT，必须显示指定\u0026ndash;entrypoint=Command 如果使用ENTRYPOINT会将docker run -I后的命令变成参数传递给ENTRYPOINT\nDocker-Compose 常用命令 version 版本\nnetworks (top Level) eg.\nnetworks: bjvm2_nacos: driver: bridge ipam: driver: default config: - subnet: 172.25.0.0/16 参数说明\nbjvm2_nacos 网络名称 driver 连接方式 services 服务列表\nimage 使用哪个镜像的镜像名称, imageName:tag\ncontainer_name 容器名称，相当于docker run 的\u0026ndash;name\nports 用来完成host与容器的端口映射关系数组。\nvolumes 用来指定宿主机与容器的目录数据的共享， 只能使用绝对路径或者自定义卷。相当于docker run的 -v 自定义卷使用前必须定义.\nversion: services: serviceName: volumes: volumesName:/容器内路径 networks: -- networkName ... volumes: -- volumesName: newwork: - networkName networks 代表当前服务使用哪个网络桥。使用前必须定义\nversion: services: serviceName: networks: # 相当于 docker run --network networkName -- networkName ... newwork: - networkName cmd 用来覆盖容器的默认启动命令。\nenvironment 用来指定容器启动时环境参数数组。\nenv_file 用来将environment的环境变量放入文件中， 使用相对路径。文件中使用key=value的形式，支持#开头的注释内容。\ndepends_on 指定容器的启动依赖，为容器ID的数组。代表为指定容器启动后才会启动。\nbuild 用来指定Dockerfile所在目录，先根据build中的dockerfile自动构建镜像，自动运行容器。\n命令行命令 up docker-compose up [options] [service\u0026hellip;] 用来启动所有docker-compose服务。默认前台启动，通过Ctrl-c会停止容器，\n-d选项 down 用来关闭所有docker-compose服务\nexec 进入容器 docker-compose exec docker-compose.yml中声明服务的ID /bash(命令)\nps 用来展示当前docker-compose运行的所有容器\nrestart 用来重启项目服务中的某个容器 docker-compose restart [options] [service \u0026hellip;]\nrm 删除容器\nstart 启动服务 docker-compose start 服务ID\nstop 关闭服务\ntop 展示容器内部的进程\nunpause pause ","permalink":"https://stoneepigraph.github.io/posts/docker/","title":"Docker笔记"},{"content":" Flask Web开发实战 基础 初识 开发环境\npipenv工作流\npip install pipenv\npipenv install # 创建虚拟环境\npipenv shell # 进入虚拟环境 pipenv run command #使用虚拟环境执行命令\npipenv graph # 查看当前环境的依赖\nHello，Flask\n创建程序实例\n新建app.py(可以是除flask.py之外任意名字)\nfrom flask import Flask app = Flask(name)\n注册路由\n概括：\n用户在浏览器输入URL访问某个资源 Flask接收用户请求并分析请求的URL 为这个URL找到对应的处理函数 执行函数并生成响应，浏览器 浏览器接收并解析响应，将信息显示在页面中。 ?? (????)(\u0026rsquo;/\u0026rsquo;) def index(): ​return '\n\u0026lt;h1\u0026gt;\nhello, world\n\u0026lt;/h1\u0026gt;\n'\n可以为视图绑定多个URL\n?? ()(\u0026lsquo;hi\u0026rsquo;) ?? ()(\u0026rsquo;/hello\u0026rsquo;) def say_hello(): ​return '\n\u0026lt;h1\u0026gt;\nHello, Flask!\n\u0026lt;/h1\u0026gt;\n'\n动态URL\n?? ()(\u0026rsquo;greet\u0026rsquo;, defaults={\u0026rsquo;name\u0026rsquo;: \u0026lsquo;Programmer\u0026rsquo;}) # 给name默认值 ?? ()(\u0026rsquo;/greet\u0026rsquo;) def greet(name = \u0026lsquo;Programmer\u0026rsquo;): ​return '\n\u0026lt;h1\u0026gt;\nHello, $s!\n\u0026lt;/h1\u0026gt;\n\u0026rsquo; % name\n启动开发器\n$ flask run $ flask run \u0026ndash;host=127.0.0.1 \u0026ndash;port=8888\n会从当前目录寻找app.py和wsgi.py,并从中寻找名为app或application的程序实例从环境变量FLASK_APP对应的值寻找名为app或application的程序实例\n管理环境变量\npython-dotenv 安装python-dotenv后，使用 flask run会自动从.flaskenv文件和.env文件中加载环境变量\nPython shell\n$ flask shell 进入Python shell\nFlask扩展\ne.g. from flask import Flask from flask_foo import Foo app = Flask(name) foo = Foo(app)\n项目配置\n配置方式\n像字典一样添加 app.config[\u0026lsquo;ADMIN_NAME\u0026rsquo;] = \u0026lsquo;Peter\u0026rsquo;\n使用update()方法则可以一次加载多个值 app.config.update( ​TESTING=True, ​SECRET_KEY=\u0026lsquo;ASDFXCVAEQWER\u0026rsquo; )\n读取值\nvalue = app.config[\u0026lsquo;ADMIN_NAME\u0026rsquo;]\nURL与端点\nurl_for(\u0026rsquo;endpoint\u0026rsquo;)\n默认会生成相对于项目的URL 如果将_external参数设置为True，将会生成完整的URL\nFlask命令\n自定义命令 ?? (a)(\u0026lsquo;hello\u0026rsquo;) def hello(): ​click.echo(\u0026lsquo;Hello, Human!\u0026rsquo;) $ flask hello #+begin_quote Hello, Human!\n#+end_quote\n模板与静态文件 Flask与MVC架构 Flask 与 HTTP Http请求\nRequest对象\nfrom flask import Flask request\n在Flask中处理请求\n路由匹配\nflask routes # 显示所有可匹配路由\n设置监听的HTTP方法\n?? ()(\u0026rsquo;/hello\u0026rsquo;, methods=[\u0026lsquo;GET\u0026rsquo;, \u0026lsquo;POST\u0026rsquo;]) def hello(): ​return \u0026lsquo;Hello, World!!!\u0026rsquo;\nURL处理\n内置的URL变量转换器\nstring int float path any uuid e.g. ?? ()(\u0026lsquo;goback/\u0026lt;\u0026gt;\u0026rsquo;) def go_back(year): ​return \u0026lsquo;Welcome to %d\u0026rsquo; % (2018 - year)\ne.g. ?? ()(\u0026rsquo;/colors/\u0026lt;any(blue, white, red):color\u0026rsquo;) # 只接收blue, white red def three_colors(color): ​return \u0026lsquo;Love is patient and kind, Love is not jealous or boastful or proud or rude.\u0026rsquo;\n请求钩子\n默认的请求钩子\nbefore_first_request: 在处理第一个请求前运行 before_request: 在处理每个请求前运行 after_request: 如果没有未处理的异常，会在每个请求结束后运行 teardown_request: 即使有异常抛出，也会在每个请求结束后运行。如果发生异常，会传入异常对象作为参数到注册的函数中 after_this_request: 会在这个请求结束后运行 e.g. ?? (a) def do_something_before_request(): ​pass #这个函数会在每个请求之前执行\nHTTP响应\n响应报文 在Flask中生成响应\n普通的响应可以只包含主体内容，默认状态码为200，如有需要可以修改\ne.g. ?? ()(\u0026rsquo;/hello\u0026rsquo;) def hello(): ​\u0026hellip; ​return \u0026lsquo;返回体\u0026rsquo;, 201 # 返回体, 返回码\ne.g. ?? ()(\u0026rsquo;/hello\u0026rsquo;) def hello(): ​\u0026hellip; ​return \u0026lsquo;\u0026rsquo;, 302, {\u0026lsquo;Location\u0026rsquo;, \u0026lsquo;Http://www.baidu.com\u0026rsquo;}\n重定向\ne.g. from flask import Flask, redirect ?? ()(\u0026rsquo;/hello\u0026rsquo;) def hello(): ​return redirect(\u0026lsquo;http://www.baidu.com\u0026rsquo;)\nfrom flask import Flask, redirect, url_for ?? ()(\u0026rsquo;/hi\u0026rsquo;) def hi(): ​return redirect(url_for(\u0026lsquo;hello\u0026rsquo;)) ?? ()(\u0026rsquo;/hello\u0026rsquo;): ​return \u0026ldquo;Hello\u0026rdquo;\n错误响应\nFlask提供abort()函数\ne.g. from flask import Flask, abort ?? ()(\u0026rsquo;/404\u0026rsquo;) def not_found(): ​abort(404)\n响应格式\n默认的响应格式为HTML 修改返回格式\ne.g. from flask import make_response ?? ()(\u0026rsquo;/foo\u0026rsquo;) def foo(): ​response = make_response(\u0026lsquo;Hello, World\u0026rsquo;) ​response.mimetype = \u0026rsquo;text/plain\u0026rsquo; ​return response\n格式例子 text/plain text/html application/xml application/json Cookie\n设置Cookie\nresponse.set_cookie(\u0026rsquo;name\u0026rsquo;, name)\n获取Cookie\nrequest.cookies.get(\u0026rsquo;name\u0026rsquo;, \u0026lsquo;Human\u0026rsquo;)\nsession： 安全的cookie\n设置程序密钥\napp.secret_key = \u0026lsquo;secret string\u0026rsquo;\napp.secret_key = os.getenv(\u0026lsquo;SECRET_KEY\u0026rsquo;, \u0026lsquo;secret string\u0026rsquo;)\ne.g. from flask import redirect, session, url_for ?? ()(\u0026rsquo;/login\u0026rsquo;) def login(): ​session[\u0026rsquo;logged_in\u0026rsquo;] = True # 写入session ​return redirect（url_for(\u0026lsquo;hello\u0026rsquo;))\n删除session\ne.g. from flask import session ?? ()(\u0026rsquo;/logout\u0026rsquo;) def logout(): ​if \u0026rsquo;logged_in\u0026rsquo; in session: ​session.pop(\u0026rsquo;logged_in\u0026rsquo;) ​return redirect(url_for(\u0026lsquo;hello\u0026rsquo;))\n默认情况下，session cookie会在用户关闭浏览器时删除，通过将session.permanent属性设为True可以将session的有效期延长为Flask.permanent_session_lifetime属性值对应的datetime.timedelta对象，也可以通过PERMEANENT_SESSION_LIFETIME设置，默认为31天。\nFlask上下文\n分为程序上下文和请求上下文\n上下文全局变量\nFlask提供了四个上下文全局变量\ncurrent_app： 请求上下文，指向处理请求的当前程序实例 g: 程序上下文，替代Python的全局变量用法，确保仅在当前请求中可用。用于存储全局数据，每次请求都会重设 request: 请求上下文，封装客户端发出的请求报文数据 session: 请求上下文，用于记住请求之间的数据，通过签名的Cookie实现 激活上下文\n当我们使用flask run 命令启动程序时 使用旧的app.run()方法启动程序时 执行使用@app.cli.command()装饰器注册的flask命令时 使用flask shell命令启动Python shell时 上下文钩子\nteardown_appcontext钩子，它注册的函数会在程序上下文和请求上下文被销毁时调用\ne.g. ?? (a) def deardown_db(exception): ​\u0026hellip; ​db.close()\nHTTP进阶实战\n重定向回上一个页面\n获取上一个页面的URL\n有两种方式可以获取\nHTTP referer return redirect(request.referrer)\nreturn redirect(request.referrer or url_for(\u0026lsquo;hello\u0026rsquo;))\n查询参数 \u0026lsquo;do something\u0026rsquo; % url_for(\u0026lsquo;do_something\u0026rsquo;, next=request.full_path)\nreturn redirect(request.args.get(\u0026rsquo;next\u0026rsquo;))\ne.g. def redirect_bak(default=\u0026lsquo;dello\u0026rsquo;, **kwargs): ​for target in request.args.get(\u0026rsquo;next\u0026rsquo;), request.referrer: ​if target: ​return redirect(target) ​return redirect(url_for(default, **kwargs))\n对URL进行安全验证\nfrom urllib import urlparse, urljoin from flask import Flask def is_safe_url(target): ​ref_url = urlparse(request.host_url) ​test_url=urlparse(urljoin(request.host_url, target)) ​return test_url.scheme in (\u0026lsquo;http\u0026rsquo;, \u0026lsquo;https\u0026rsquo;) and ref_url.netloc == test_url.netloc\n使用AJAx技术发送异步请求\n返回“局部数据”\n纯文本或都HTML e.g. ?? ()(\u0026ldquo;comments/\u0026lt;int: post_id\u0026gt;\u0026rdquo;) def get_comments(post_id): ​return render_template(\u0026lsquo;comments.html\u0026rsquo;)\n返回JSON数据 ?? ()(\u0026lsquo;profile/\u0026lt;int: user_id\u0026gt;\u0026rsquo;) def get_profile(user_id): ​return jsonify(username=username, bio=bio)\n空值 ?? ()(\u0026rsquo;/post/delete/\u0026lt;int: post_id\u0026gt;\u0026rsquo;, methods=[\u0026lsquo;delete\u0026rsquo;]) def delete_post(post_id): ​return \u0026lsquo;\u0026rsquo;, 204\n异步加载长文章 HTTP 服务器端推送\n常用的推送技术\n传统轮询 长轮询 Server-Sent Events(SSE): 通过HTML5中的EventSource API实现。SSE会在客户端和服务器建立 一个单向的通道。客户端监听来自服务器端的数据。 WebSocket Web安全规范\n注入攻击\nXSS攻击防范：\nHTML转义 response = '\n\u0026lt;h1\u0026gt;\nHello, %s\n\u0026lt;/h1\u0026gt;\n\u0026rsquo; % escape(name)\n验证用户输入 CSRF攻击\n模板 模板基本用法\n创建模板\n在templates目录下创建HTML文件\nJinJa2常见的有三种定界符\n语句 比如if判断、for循环等：\n{%\u0026hellip;%}\n表达式 比如字符串、变量、函数调用等\n{{\u0026hellip;}}\n注释 {#\u0026hellip;#}\n模板语法\nfor {% for movie in moveies%}\n\u0026lt;li\u0026gt;\n{{ movie.name}} - {{ movie.year }}\n\u0026lt;/li\u0026gt;\n{% endfor %}\nfor循环的完整变量列表： http://jinja.pcoo.org/docs/2.10/templates/#for\n渲染模板\ne.g. from flask import Flask, render_template ?? ()(\u0026rsquo;/watchlist\u0026rsquo;) def watchlist(): ​return render_template(\u0026lsquo;watchlist.html\u0026rsquo;, user=user, movies=movies)\nFlask会在程序要目录下的templates文件夹里寻找模板文件。\n模板辅助工具\n上下文\n可以模板中定义变量，使用set标签\ne.g. {% set navigation = [(\u0026rsquo;/\u0026rsquo;, \u0026lsquo;Home\u0026rsquo;), (\u0026rsquo;/about\u0026rsquo;, \u0026lsquo;About\u0026rsquo;)]%}\ne.g. {% set navigation%}\n\u0026lt;li\u0026gt;\nHome\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\nAbout\n\u0026lt;/li\u0026gt;\n{% endset %}\n内置上下文变量\nconfig: 当前的配置对象 request: 当前的请求对象，在已激活的请求环境下可用 session: 当前的会话对象，在已激活的请求环境下可用 g: 与请求绑定的全局变量，在已激活的请求环境下可用 自定义上下文\n模板全局变量 Flask提供了一个app.context_processor装饰器，可以用来注册模板上下文处理函数\n?? (a) def inject_foo(): ​ foo = \u0026ldquo;I am foo.\u0026rdquo; ​ return dict(foo = foo) # 等同于return {\u0026lsquo;foo\u0026rsquo;: foo}\ndef inject_foo(): ​ foo = \u0026ldquo;I am foo.\u0026rdquo; ​ return dict(foo = foo) app.context_processor(inject_foo)\napp.context_processor(lambda: dict(foo = \u0026lsquo;I am foo.\u0026rsquo;))\n全局对象\n内置全局函数\nJinjia2内置模板全局函数\nrange([start, ] stop [, step]): 和Python中range()的用法相同 lipsum(n=5, html=True, min=20, max=100)： 生成随机的文本（ lorem ipsum）, 可以在测试时用来填充页面。默认生成5段HTML文本，每段包含20-100个单词。 dict(**items): 和Python中的dict()用法相同 完整的访问： http://jinja.pocoo.org/docs/2.10/templates/#list-of-global-functinos\nFlask内置模板全局函数\nurl_for(): 用于生成URL的函数 get_finished_messages(): 用于获取flash消息的函数 e.g. ← Return\n自定义全局函数\n使用app.template_global装饰器直接将函数注册为模板全局函数\n?? (a)() def bar(): ​return \u0026ldquo;I am bar.\u0026rdquo;\n过滤器\n{{ obj | filterFunc }}\n内置过滤器\ndefault(value, default_value=\u0026rsquo;\u0026rsquo;, boolean=False): 设置默认值，默认值做为参数传入，别名为d escape(s): 转义HTML文本，别名为e first(seq): 返回序列的第一个元素 last(seq)：返回序列的最后一个元素 length(object): 返回变量的长度 random(seq): 返回序列中的随机元素 safe(value): 将变量值标记为安全，避免转义 trim(value): 清除变量值前后的空格 max(value, case_sensitive=False, attribute=None): 返回序列中的最大值 min(value, case_sensitive=False, attribute=None): 返回序列中的最小值 unique(value, case_sensitive=False,attribute=None):返回序列中的不重复的值 striptags(value): 清除变量值内的HTML标签 urlize(value, trim_url_limit=None, nofollow=False, target=None, rel=None): 将URL文本转换为可单击的HTML链接 wordcount(s): 计算单词数量 tojson(value, indent=None): 将变量值转换为JSON格式 truncate(s, length=255, killwords=False, end=\u0026rsquo;\u0026hellip;\u0026rsquo;, leeway=None): 截断字符串，常用于显示文章摘要，length参数设置截断长度，killwords参数设置是否截断单词，end参数设置结尾的符号 完整列表： http://jinja.pocoo.org/docs/2.10/templates/#builtin-filters\n自定义过滤器\napp.template_filter()装饰器\nfrom flask import Markup ?? (a)() def musical(s): ​return s + Markup(\u0026rsquo;♫\u0026rsquo;)\n或\napp.add_template_filter(you_filter_function)\n{{ name | musical }}\n#####　测试器\n{% if age is number %} {% else%} {% endif %}\n常用内置测试器\ncallable(object): 判断对象是否可被调用 defined(value): 判断变量是否已定义 undefined(value)：判断变量是否未定义 none(value): 断送变量是否为None number(value): 判断变量是否为数字 string(value): 判断变量是否是字符串 sequence(value): 判断变量是否是序列，比如字符串，列表，无组 iterable(value): 判断变量是否要迭代 mapping(value): 判断变量是否是匹配对象，比如字典 sames(value, other): 判断变量与other是否指向相同内存地址 完整列表： http://jinja.pocoo.org/docs/2.10/templates/#list-of-builtin-tests\n自定义过滤器\napp.template_test()\n?? (a)() def baz(n): ​if n == \u0026lsquo;baz\u0026rsquo;: ​return True ​return False\n模板环境对象\n在jinja2中，渲染行为由jinja2.Enviroment类控制，所有的配置选项、上下文变量、全局函数、过滤器和测试器都存储在Environment实例上。而与Flask结合后，使用Flask创建的Environment，它存储在app.jinja_env属性上\n添加自定义全局对象\ndef bar(): ​return \u0026ldquo;I am bar.\u0026rdquo; foo = \u0026ldquo;I am foo\u0026rdquo; app.jinia_env.globals[\u0026lsquo;bar\u0026rsquo;] = bar app.jinja_env.globals[\u0026lsquo;foo\u0026rsquo;] = foo\n添加自定义过滤器\ndef smiling(s): ​return s + \u0026rsquo; :)\u0026rsquo; app.jinja_env.filters[\u0026lsquo;smiling\u0026rsquo;] = smiling\n添加自定义过滤器\ndef baz(n): ​if n == \u0026lsquo;baz\u0026rsquo;: ​return True ​return False app.jinja_env.tests[\u0026lsquo;baz\u0026rsquo;] = baz\n模板结构组织\n局部模板\n使用include可以把局部模板插入标签位置, 使用当前文件的上下文\n{% include \u0026lsquo;_banner.html\u0026rsquo; %}\n宏\n可以把一部分代码封装到宏里，使用传递的参数来构建内容，最后返回构建后的内容。这个文件通常命名为macros.html或_macros.html. 创建时使用macro和endmacro标签声明宏的开始和结束。\ne.g. #声明 {% macro qux(amount = 1) %} ​{% if amount == 1 %} ​I am qux ​{% elif amoutn \u0026gt; 1 %} ​We are quxs. ​{% endif %} {% endmacro %}\ne.g. #使用 {% from \u0026lsquo;macros.html\u0026rsquo; import qux %} 或 {% from \u0026lsquo;macros.html\u0026rsquo; import qux with context %} \u0026hellip; {{ qux(amount = 5) }}\n模板继承\n编写基本模板\n通过在基模板上添加页头和页脚当子模板继承基模板后，子模板会自动 包含基模板 的内容的结构。为了能够让子模板方便地覆盖基模板或插入内容到基模板中，我们需要在基模板中定义块（block）, 在子模板中可以通过定义同名的块来执行继承操作。 e.g. 我们可以创建六个块： head, title, styles, content, footer, scripts\n{% block body %} {% endblock body %}\n编写子模板\ne.g. {% extends \u0026lsquo;base.html\u0026rsquo;%} {% from \u0026lsquo;macros.html\u0026rsquo; import qux %} {% block content %} ​内容 {% endblock content %}\n注意： extends必须是子模板的第一个标签 我们在子模板中可以对你模板中的块执行两种操作：\n覆盖内容 创建同名的块时，会使用子块的内容覆盖父块的内容\n追加内容 需要使用super()进行声明\ne.g. {% block styles %} {{ super() }} \u0026hellip; {% endblock styles %}\n模板进阶实践\n空白控制\n空白行是为了增加可读必，可以在定界符内侧添加减号移除空白\ne.g. {%- endfor %}\n也可以使用模板环境的属性删除窄\napp.jinja_env.trim_blocks = True: 删除jinja2语句后的第一个窄 app.jinja_env.lstrip_blocks = True: 删除Jinja2语句所在行之前的空格和制表符\n注意宏内的空白不受trim_blocks 和 lstrip_blocks控制\n加载静态文件\n静态文件默认存放在static文件夹中。\ne.g. url_for(\u0026lsquo;static\u0026rsquo;, filename=\u0026lsquo;fileanme.jpg\u0026rsquo;) #filename为static文件夹下的路径\n消息闪现\ne.g. ?? ()(\u0026rsquo;/flash\u0026rsquo;) def just_flash(): ​flash(\u0026lsquo;闪现消息\u0026rsquo;) ​return redirector(url_for(\u0026lsquo;index\u0026rsquo;)) #渲染flash消息\n{% for message in get_flashed_messages() %} \u0026lt;div class=\u0026quot;alert\u0026quot;\u0026gt; {{message}} \u0026lt;/div\u0026gt; {% endfor %} {% block content %} {% endblock %} 自定义错误页面\ne.g. 404.html {% extends \u0026lsquo;base.html\u0026rsquo; %} {% block title %} 404 - Page Not Found {% endblock%} {% block content %} ​Page Not Found {% endblock %} #错误处理函数 ?? (a)(404) def page_not_found(e): ​return render_template(\u0026rsquo;errors/404.html\u0026rsquo;), 404\nJavaScript 和 CSS 中的jinja2\n使用行内、嵌入式Javascript和CSS 定义为JavaScript、CSS变量 e.g. {{ user.username}}\n表单 HTML表单 使用Flask-WTF处理表单\nFlask-WTF默认会认为每个表彰启用CSRF保护，它会为我们生成和验证CSRF令牌，默认Flask-WTF使用程序的密钥来对CSRF令牌进行签名，所以我们需要为程序设置密钥：\napp.secret_key = \u0026lsquo;secret string xxxx\u0026rsquo;\n定义WTForms表单类\ne.g. from wtforms import Form, StringField, PasswordField, BooleanField, SubmitField from wtforms.validators import dataRequired,Length class LoginForm(Form): ​username = StringField(\u0026lsquo;username\u0026rsquo;, validators=[DataRequired()]) ​password = PasswordField(\u0026lsquo;Password\u0026rsquo;, validators=[DataRequired(), Length(8, 128)]) ​remember = BooleanField(\u0026lsquo;Remember Me\u0026rsquo;) ​submit = SubmitField(\u0026lsquo;Login\u0026rsquo;)\n实例化常用参数\nlabel: 字段标签的值，也是渲染后显示在输入字段前的文字 render_kw: 一个字典，用来应的HTML标签的属性，比如传入{\u0026lsquo;placeholder\u0026rsquo;: \u0026lsquo;Your name\u0026rsquo;}, 渲染后的HTML代码会将标签的placeholder属性设置为Your name validators: 一个列表，包含一系列验证器，会在表单提交后逐一调用验证表彰数据 default: 字符串或可调用 对象，用来为表单字段设置默认值 验证器\n验证器（validator）是一系列用于验证字段数据的类，从wtforms.validators模板导入常用的验证器\nDataRequired(message=None): 验证数据是否有效 Email(message=None) EqualTo(fieldname, message=None): 验证两个字段是否相同 InputRequired(message=None): 验证是否有数据 Length(min=-1, max=-1, message=None): 验证输入值否在给定范围内 NumberRange(min=None, max=None, message=None): 验证输入数字是否在给定范围内 Optional(strip_whitespace=True): 允许输入值为空，并路过其他验证 Regexp(regex, flags=0, message=None): 使用正则表达式验证输入值 URL(require_tld=True, message=None)：验证URL AnyOf(values, message=None, values_formatter=None):确保输入值在可选值列表中 NoneOf(values, message=None, values_formatter=None): 确保输入值不在可选值列表中 输出HTML代码 在模板中渲染表单\ne.g. from forms import LoginForm ?? ()(\u0026rsquo;/basic\u0026rsquo;) def basic(): ​form = LoginForm() ​return render_template(\u0026rsquo;login.html\u0026rsquo;, form=form)\n在模板中只需要调用表单类的属性即可获取字段HTML代码，如果需要传入参数，也可以添加括号\ne.g.\n\u0026lt;form method=\u0026ldquo;post\u0026rdquo;\u0026gt;\n{{ form.csrf_token }} #渲染CSRF令牌隐藏字段 {{ form.username.label }}{{ form.username }} {{ form.password.label }}{{ form.password }} {{ form.remember }}{{ form.remember.label}} {{ form.submit }}\n\u0026lt;/form\u0026gt;\n处理表单数据\n提交表单 验证表单数据\n客户端验证和服务端验证\n客户端验证 服务端验证 WTForms验证机制\nform = XXXForm() form.validate() False/True\n在视图函数中验证表单\n?? ()(\u0026rsquo;/basic\u0026rsquo;, methods=[\u0026lsquo;GET\u0026rsquo;, \u0026lsquo;POST\u0026rsquo;]) def basic(): ​form = LoginForm() ​form.validate_on_submit(): #返回True，表示用户提交了表单，且表单通过了验证​\u0026hellip; ​return render_template(\u0026lsquo;basic.html\u0026rsquo;, form=form)\n获取表单字段 form.字段名.data\n在模板中渲染错误消息\n如果form.validate_on_submit()返回False，就说明验证没有通过。对于未验证通过的字段，WTForms会把错误消息添加到表单类的errors属性中，我们一般会通过字段名来获取对应字段的错误消息列表，即：\nform.字段名.errors\n表单进阶实践\n设置错误消息语言\ne.g. 设置错误消息语言为中文 from flask_wtf import FlaskForm app = Flask(name) app.config[\u0026lsquo;WTF_I18N_ENABLED\u0026rsquo;] = False class MyBaseForm(FlaskForm): ​class Meta: ​locales = [\u0026lsquo;zh\u0026rsquo;] class HelloForm(MyBaseForm): ​pass\n使用宏渲染表单\n在模板中渲染表单时，我们需要做：\n调用字段属性，获取定义 调用对应的label属性，获取定义 渲染错误消息。 我们可以创建一个宏来渲染表单字段。\n{% macro form_field(field) %} {{ field.label }}\u0026lt;br\u0026gt; {{ field(**kwargs) }}\u0026lt;br\u0026gt; {% if field.errors %} {% for error in field.errors %} \u0026lt;small class=\u0026quot;error\u0026quot;\u0026gt;{{ error }}\u0026lt;/small\u0026gt;\u0026lt;br\u0026gt; {% endfor %} {% endif %} {% endmacro %} 使用\n{% form 'macros.html' import form_field %} ... \u0026lt;form methods=\u0026quot;post\u0026quot;\u0026gt; {{ form.csrf_token }} {{ form_field(form.username) }}\u0026lt;br\u0026gt; {{ form_field(form.password) }}\u0026lt;br\u0026gt; ... \u0026lt;/form\u0026gt; 自定义验证器\n行内验证器\ne.g. from wtforms import IntegerField, SubmitField from wtforms.validators import ValidationError class FortyTwoForm(FlaskForm): ​answer = IntegerField(\u0026lsquo;The Number\u0026rsquo;) ​submit = SubmitField() def validate_answer(form, field): ​if field.data != 42: ​raise ValidationError(\u0026lsquo;Must be 42.\u0026rsquo;)\n全局验证器\nfrom wtforms.validators import ValidationError def is_42(form, field): if field.data != 42: raise ValidationError('Must be 42) class FortyTwoForm(FlaskForm): answer = IntegerField('Thie Number', validators=[is_42]) submit = SubmitField() 文件上传\n我们需要\n验证文件类型 验证文件大小 过滤文件名 定义上传表单\n创建上传表单\nfrom flask wtf.file import FileField, FileRequired, FileAllowed class UploadForm(FlaskForm): photo = FileField('Upload Image', validators=[FileRequired(), FileAllowed(['jpg', 'jpeg', 'png', 'gif'])]) submit = SubmitField() 限制文件上传大小\napp.config[\u0026lsquo;MAX_CONTENT_LENGTH\u0026rsquo;] = 3* 1024 * 1024\n超过这个限制会返回413错误\n渲染上传表单\n@app.route('/upload), methods=['GET‘， ’POST‘]） def upload(): form = UploadForm() ... return render_template('upload.html', form=form) \u0026lt;form method=\u0026quot;post\u0026quot; enctype=\u0026quot;multipart/form-data\u0026quot;\u0026gt; {{ form.csrf_token }} {{ form_field(form.photo) }} {{ form.submit }} \u0026lt;/form\u0026gt; 处理上传文件\nimport os app.config['UPLOAD_PATH'] = os.path.join(app.root_path, 'uploads') @app.route('/upload', methods=['GET'， 'POST']) def upload(): form = UploadForm() if form.validate_on_submit(): f = form.photo.data filename = random_filename(f.filename) f.save(os.path.join(app.config['UPLOAD_PATH'], filename)) flash('Upload success') session['filenames'] = [filename] return redirect(url_for('show_images')) return render_template('upload.html', form=form) 文件名处理定义上传路径\napp.config[\u0026lsquo;UPLOAD_PATH\u0026rsquo;] = os.path.join(app.root_path, \u0026lsquo;uploads\u0026rsquo;)\nos.root_path相当于os.path.abspath(os.path.dirname(file)), 为了保存文件，你需要手动创建这个文件夹对FileStorage对象调用save()方法即可保存，传入包含目标文件夹绝对路径和文件名在内的完整保存路径\nf.save(os.path.join(app.config[\u0026lsquo;UPLOAD_PATH\u0026rsquo;], filename))\n文件保存后，如果希望能够显示上传后的图片，我们需要创建一个视图来返回上传后的文件\n@app.route('/uploads/\u0026lt;path:filename\u0026gt;') def get_file(filename): return send_from_directory(app.config['UPLOAD_PATH], filename) \u0026lt;img src=\u0026quot;{{ url_for('get_file', filename=filename) }}\u0026quot; 多文件上传 使用Flask-CKEditor集成富文本编辑器\n$ pipenv install flask-ckeditor\nfrom flask-ckeditor import CKEditor ckeditor = CKEditor(app)\n配置富文本编辑器\n查看完整配置： https://flask-ckeditor.readthedocs.io/en/latest/configuration.html\n渲染富文本编辑器\nfrom flask_wtf import FlaskForm from wtforms import StringField, SubmitField from wtforms.validators import DatRequired, Length from flask_ckeditor import CKEditorField class RichTextForm(FlaskForm): title = StringField('Title', validators=[DataRequired(), Length(1, 50)]) body = CKEditorField(\u0026quot;Body\u0026quot;, validators=[DataRequired()]) submit = SubmitField('Publish') html渲染包含CKEditor编辑器的表单需要使用{{ ckeditor.load() }}方法加载资源（相应的js,css）,默认会从CDN加载，可以修改CKEDITOR_SERVE_LOCAL设置为True，会使用扩展内置的本地资源。如果你使用配置变量设置了编辑器的调试，宽度和语言或是其他插件配置，需要使用ckeditor.config()方法加载配置，传入对应表彰字段的name属性值，即对应表单类属性名。这个方法需要在加载CKEditor资源后调用：\n{{ ckeditor.config(name=\u0026lsquo;body\u0026rsquo;) }}\n单个表单多个提交按钮\ne.g. form/forms.py\nclass NewPostForm(FlaskForm): title = StringField('Title', validators=[DataRequired(), Length(1, 50)]) body = TextAreaField('Body', validators=[DataRequired()]) save = SubmitField('Save') publish = SubmitField('Publish') WTForms会对数据做进一眇处理。对于提交字段的值，它会将其转换成布尔值：被单击的提交字段的值将是True，未被单击的值则是False e.g. form/app.py\n@app.route('two-submits', methods=['GET', 'POST']) def two_submits(): form = NewPostForm() if form.validate_on_submit(): if form.save.data: # save it... flash('you click the \u0026quot;Save\u0026quot; button.') elif form.publish.data: # publish it... flash('you click the \u0026quot;Publish\u0026quot; button') return redirect(url_for('index')) return render_template('2submit.html', form=form) 单页面多个表单\n单视图处理\n通过为两个表单的提交字段设置不同的名称，通过提交字段的值来区分被提交的表单\n多视图处理\ne.g. 渲染视图\n@app.route('/multi-form-multi-view') def multi_form_multi_view(): signin_form = SignForm2() register_form = RegisterForm2() return render_template('2form2view.html', signin_form = signin_form, register_form = register_form) e.g. 处理表单提交\n@app.route('/handle-signin', methods=['POST']) def handle_signin(): signin_form = SigninForm2() register_form = RegisterForm2() if signin_form.validate_on_submit(): username = signin_form.username.data flash('%s, you just submit the Signin Form.' % username) return redirect(url_for('index')) return render_template('2form2view.html', signin_form=signin_form, register_form=register_form) @app.route('/handle-register', methods=['POST']) def handle_register(): signin_form = SigninForm2() register_form = RegisterForm2() if register_form.validate_on_submit(): username = register_form.username.data flash('%s, you just submit the Register form.' % username) return redirect(url_for('index')) return render_template('2form2view.html', signin_form = signin_form, register_form = register_form) e.g. 表单页面\n... \u0026lt;h2\u0026gt; Login Form \u0026lt;/h2\u0026gt; \u0026lt;form method=\u0026quot;post\u0026quot; action=\u0026quot;{{ url_for('handle_signin) }}\u0026quot;\u0026gt; ... \u0026lt;/form\u0026gt; \u0026lt;h2\u0026gt; Register Form \u0026lt;/h2\u0026gt; \u0026lt;form method=\u0026quot;post\u0026quot; action=\u0026quot;{{ url_for('handle_register) }}\u0026quot;\u0026gt; ... \u0026lt;/form\u0026gt; ... 这样处理可以正常工作，但是有一个显著缺点。如果验证未通过，你需要将错误消息的form.errors字典传入模板中。解决方法是通过其他方式传递错误消息，然后统一定向到渲染表单页面的视图。比如：使用flash()函数迭代form.errors字典发送错误消息，然后重定向到用来渲染表单的multi_form_multi_view视图。\ndef flash_errors(form): for field, errors in form.errors.items(): for error in errors: flash('ERROR in the %s field = %s)% ( getattr(form, field).label.text, error ) 数据库 数据库分类\nSQL NoSQL\n文档存储\ne.g. ​MongoDB ​CouchDB\n键值对存储\ne.g. ​Redis ​Riak\nORM魔法\n优点：\n灵活性好 提升效率 可移植性好 使用Flask-SQLAlchemy管理数据库\n$ pipenv install flask-sqlalchemy\n完成扩展初始化\nfrom flask import Flask from flask_sqlalchemy import SQLAlchemy app = Flask(___name___) db = SQLAlchemy(app) 连接数据库服务器\n常用 的DBMS及其数据库URI格式\nDBMS URI PostgreSQL postgresql://username:password@host/databasename MySQL mysql://username:password@host/databasename Oracle oracle://username:password@host:port/sidname SQLite(UNIX) sqlite:////absolute/path/to/foo.db SQLite(Windows) sqlite:///absolute\\path→\\foo.db SQLite(内存型) sqlite:///或sqlite:///:memory: app.py:配置数据库URI\nimport os ... app.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('DATABASE_URL', 'sqlite:///' + os.path.join(app.root_path, 'data.db)) 定义数据库模型\n一个数据库模型类对应数据库中的一个表。定义模型即使用Python类定义表模式，并声明映射关系。所有的模型类都需要继承Flask-SQLAlchemy提供的db.Model类。 e.g. Note类\nclass Note(db.Model): id = db.Column(db.Integer, primary_key=True) body = db.Column(db.Text) SQLAlchemy常用的字段类型\n字段 说明 Integer 整数 String 字符串，可选参数Length可以用来设置最大长度 Text 较长的Unicode文本 Date 日期，存储Python的datetime.date对象 Time 时间，存储Python的datetime.time对象 DateTime 时间和日期，存储Python的datetime对象 Interval 时间间隔，存储Python的datetime.timedelta对象 Float 浮点数 Boolean 布尔值 pickleType 存储Pickle列化的Python对象 LargeBinary 存储任意二进制数据 默认Flask-SQLAlchemy会根据模型类名生成一个表名称; ​Message \u0026ndash;\u0026gt; message ​FooBar \u0026ndash;\u0026gt; foo_bar 如果想自己指定，可以通过定义_*/tablename/*_属性. 字段名默认为类属性名，你可以通过构造方法的第一个参数指定，或使用关键字name。\n实例化字段类常用的字段参数 参数名 说明 primary_key 如果设置为True，该字段为主键 unique 如果设置为True, 该字段不允许出现重复值 index 如果设为True，为该字段创建索引，以提高查询效率 nullable 确定字段值可否为空，值为True或False, 默认为True default 为字段设置默认值 创建数据库和表\n$ flask shell \u0026gt;\u0026gt;\u0026gt; from app import db \u0026gt;\u0026gt;\u0026gt; db.create_all() 如果是将模型类定义在单独的模块中，那么必须在调用db.create_all()方法前导入相应模块，以便让SQLAlchemy获取模型类被创建时生成的表信息，进而正确生成数据表。\n查看模型对应的SQL模式\n\u0026gt;\u0026gt;\u0026gt; from sqlalchemy.schema import CreateTable \u0026gt;\u0026gt;\u0026gt; print(CreateTable(Note.__table__)) 创建表后再对模型做的修改不会自动映射到数据库，最简单的方式是调用db.drop_all()删除数据库和表，再次调用db.create_all()重新生成。\n数据库操作\nSQLAlchemy使用数据库会话来管理数据库操作，这里的数据库会话也称为事务（Transaction）。Flask-SQLAlchemy自动帮我们创建会话，可以通过db.session属性获取。只有执行了commit()方法时，改动才被提交到数据库，执行rollback()方法会撤消操作。\nCRUD\nCreate\n步骤\n创建Python对象（实例化模型类）作为一条记录。 添加新创建的记录到数据库会话。 提交数据库会话。 from app import db, Note note = Note(body='Body') db.session.add(note) db.session.commit() Read\n常用的SQLALchemy查询方法\n查询方法 说明 all() 返回包含所有查询记录的列表 first() 返回查询的第一条记录，如果未找到，则返回None one() 返回第一条记录，且仅允许有一条记录。如果记录大于1或小于1，抛出异常 get(ident) 传入键值作为参数，返回指定主键值的记录，如果未找到，则返回None count() 返回查询结果的数量 one_or_none() 类似one(), 如果结果数量不为1，返回None first_or_404() 返回查询的第一条记录，如果未找到，则返回404响应错误 get_or_404(ident) 传入主键值作为参数，返回指定主键值的记录，如果未找到，则返回404错误响应 paginate() 返回一个Pagination对象，可以对记录进行分页处理 with_parent(instance) 传入模型类实例作为参数，返回和这个实例相关联的对象 常用的过滤方法\n查询过滤器名称 说明 filter() 使用指定的规则过滤记录，返回新产生的查询对象 filter_by() 使用指定规则过滤记录（以关键字表达式的形式），返回新产生的查询对象 order_by() 根据指定条件对记录进行排序，返回新产生的查询对象 limit(limit) 使用指定的值限制原查询返回的记录数量，返回新产生的查询对象 group_by() 根据指定条件对记录进行分组，返回新产生的查询对象 offset(offset) 使用指定的值偏移原查询的结果，返回新产生的查询对象 打印查询对象对应的SQL\nprint(Model.query.filter_by(column='columnValue')) filter()方法的详解\nLike filter(Model.column.like(\u0026rsquo;%Content%\u0026rsquo;))\nIn filter(Model.column.in_([\u0026lsquo;content\u0026rsquo;, \u0026lsquo;content2\u0026rsquo;]))\nNot In filter(~Model.column.in_([\u0026lsquo;content\u0026rsquo;, \u0026lsquo;content2\u0026rsquo;]))\nAnd\n使用and_() filter(and_(Model.column1 = 'content', Model.column2 = \u0026lsquo;content2\u0026rsquo;))\n在filter中加入多个表达式，用逗号分隔 filter(Model.column = 'content', Model.column2 = \u0026lsquo;content2\u0026rsquo;)\n叠加调用多个filter或filter_by方法 filter(Model.column = 'content').filter(Model.column2 = \u0026lsquo;content2\u0026rsquo;)\nOr\nfrom sqlalchemy import or_ filter(or_(Model.column = 'content', Model.column2 = \u0026lsquo;content2\u0026rsquo;))\nfilter_by() 在filter_by()中，可以使用关键字表达式来指定过滤规则。更方便的是，你可以在这个过滤器中直接使用字段名称。\nModel.query.filter_by(column = \u0026lsquo;content\u0026rsquo;).all()\nUpdate\n更新一条记录只需要赋值给模型类的字段属性就可以改变字段值，然后调用 commit()方法提交会话即可。\nmodel = Model.query.get(idValue) model.column = 'new Content' db.session.commit() Delete\ndelete()\nmodel = Model.query.get() db.session.delete(model) db.session.commit() 在视图函数里操作数据库 定义关系\n配置Python Shell上下文\n使用app.shell_context_processor装饰器注册一个shell上下文处理器\n@app.shell_context_processor def make_shell_context(): return dict(db=db) 当再次使用flask shell命令启动Python Shell时，所有使用app.shell_context_processor装饰器注册的shell上下文处理函数都会自动被执行。\n一对多\n定义外键\ne.g. class Article(db.Model): ... author_id = db.Column(db.Integer, db.ForeignKey('author.id')) # 表名.字段名 定义关系属性\nclass Author(db.Model): ... articles = db.relationship('Article') # 为关系另一侧的模型名称 建立关系\n建立关系有两种方式第一种是*为外键字段赋值*\ne.g. spam.author_id = 1 db.session.commit() 另一种是通过*操作关系属性*\nfoo.articles.append(spam) foo.articles.append(ham) db.session.commit() 和append方法相对，可以使用remove()方法解除关系 常用的SQLAlchemy关系函数参数\n参数名 说明 back_populates 定义反向引用，用于建立双向关系，在关系的另一侧也必须显示定义关系属性 backref 添加反向引用，自动在另一侧建立关系属性，是back_populates的简化版 lazy 指定如何加载相关记录，具体见下表 uselist 指定是否使用列表的形式加载记录，设为False则使用标量 cascade 设置级联操作 order_by 指定加载相关记录时的排序方式 secondary 在多对多关系中指定关联表 primaryjoin 指定多对多关系中的一级联结条件 secondaryjoin 指定多对多关系中的二级联结条件 **常用的SQLAlchemy关系记录加载方式（lazy参数可选值）\n关系加载方式 说明 select 在必要时一次性加载记录，返回包含记录的列表（默认值）， 等同于lazy = True joined 和父查询一样加载记录，但使用联结，等同于lazy = False immediate 一旦父查询加载就加载 subquery 类似于joined, 不过将使用子查询 dynamic 不直接加载记录，而是返回一个包含相关记录的query对象，发便再继续附加查询函数对结果进行过滤 建立双向关系\n关系双方都使用relationship()函数建立关系。\ne.g. class Writer(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) books = db.relationship('Book', back_populates='writer') class Book(db.Model): id = db.Column(db.Integer, primary_key=True) title = db.Column(db.String(50), index=True) writer_id = db.Column(db.Integer, db.ForeignKey('writer.id')) writer = db.relationship('Writer', back_populates='books') 使用backref简化关系定义\nbackref可以简化双向关系的定义。\n多对一\nclass Citizen(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) city_id = db.Column(db.Integer, db.ForeignKey('city.id')) city = db.relationship('City') class City(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) 一对一\nclass Country(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) capital = db.relationship('Capital', uselist=False) class Capital(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) country_id = db.Column(db.Integer, db.Foreign('country.id')) country = db.relationship('Country') 多对多\n使用关联表\nassociation_table = db.Table('association', db.Column('student_id', db.Integer, db.ForeignKey('student.id')), db.Column('teacher_id', db.Integer, db.ForeignKey('teacher.id'))) class Student(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) grade = db.Column(db.String(20)) teachers = db.relationship('Teacher', secondary=association_table, back_populates='students') class Teacher(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) offic = db.Column(db.String(20)) 更新数据库表 使用Flask-Migrate迁移数据库\n安装Flask-Migrate\npipenv install flask-migrate\n实例化\nfrom flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_migrate import Migrate app = Flask(____name____) ... db = SQLAlchemy(app) migrate = Migrate(app, db) # 在db对象创建后调用 创建迁移环境\n在开始迁移数据之前，需要先使用正面的命令创建一个迁移环境：\n$ flask db init\n迁移环境只需要创建一次。这会在你的项目根目录下创建一个migrations文件夹，其中包含了自动生成的配置文件和迁移版本文件夹。\n生成迁移脚本\n使用migrate子命令可以自动生成迁移脚本 e.g. ​向表note新添加一个timestamp列，并且相应生成一个迁移脚本xxxx_add_note_timestamp.py\n$ flask db migrate -m \u0026ldquo;add note timestamp\u0026rdquo;\n更新数据库\ne.g. 如果还没有创建数据库和表，这个命令会自动创建，如果已经创建，则会在不损坏数据的前提下执行更新。\n$ flask db upgrade\n如果想回滚迁移，那么可以使用downgrade命令降级，它会撤消最后一次迁移在数据库中的改动。\n开发时是否需要迁移？ 数据库进阶实践\n级联操作\ncomments = relationship(\u0026lsquo;Comment\u0026rsquo;, cascade=\u0026lsquo;save-update, merge, delete\u0026rsquo;)\n常用的配置组合：\nsave-update, merge(默认值) save-update, merge, delete all all, delete-orphan save-update\n是默认的级联行为，当cascade参数设置为save-update时，如果使用db.session.add()方法将Post对象添加到数据库会话时，那么与Post相关联的Comment对象也将被添加到数据库会话。\ndelete\n如果Post类的关系函数中cascade参数设为delete时，这些相关的Comment会在关联的Post对象删除时被一并删除。\ndelete-orphan\n这个模式是基于delete级联的，必须和delete级联一起使用，通常会设为all, delete-orphan,因为all包含delete.\n事件监听\nFlask提供了多个装饰器注册请求的回调函数，它们会在特定的请求处理环节被执行。类似的SQLAlchemy也提供了一个listen_for()装饰器，可以用来注册事件回调函数。 e.g.\nclass Draft(db.Model): id = db.Column(db.Integer, primary_key=True) body = db.Column(db.Text) edit_time = db.Column(db.Integer, default=0) # 通过注册事件监听函数，我们可以实现在body列被修改时，自动叠加表示被修改次数的edit_time字段。 @db.event.listens_for(Draft.body, 'set') def increment_edit_time(target, value, oldvalue, initiator): if target.edit_time is not None: target.edit_time += 1 # 或者 @db.event.listens_for(Draft.body, 'set', named=True) def increment_edit_time(**kwargs): if kwargs['target'].edit_time is not None: kwargs['target'].edit_time += 1 SQLAlchemy作为SQL工具集本身包含两大主要组件： SQLAlchemy ORM 和SQLAlchemy Core。前者提供了我们前面介绍的ORM功能，后者实现了数据库核心功能，这两类组件都提供了大量的监听事件，几科覆盖整个SQLAlchemy使用的生命周期。 Core事件： http://docs.sqlalchemy.org/en/latest/core/events.html ORM事件：http://docs.sqlalchemy.org/en/latest/orm/events.html SQLAlchemy tutorial: http://docs.sqlalchemy.org/en/latest/orm/tutorial.html\n电子邮件 使用Flask-Mail发送电子邮件\n安装\npipenv install flask-mail\n实例化\nfrom flask_mail import Mail app = Flask(name) \u0026hellip; mail = Mail(app)\n配置Flask-Mail\n常用配置\n配置键 说明 默认值 MAIL_SERVER 用于发送邮件的SMTP服务器 localhost MAIL_PORT 发信端口 25 MAIL_USE_TLS 是否使用STARTTLS False MAIL_USE_SSL 是否使用SSL/TLS False MAIL_USERNAME 发信服务器的用户名 None MAIL_PASSWORD 发信服务器的密码 None MAIL_DEFAULT_SENDER 默认的发信人 None e.g.\nimport os from flask import Flask from flask_mail import Mail app = Flask(__name__) app.config.update( ... MAIL_SERVER = os.getenv('MAIL_SERVER') MAIL_PORT = 587 MAIL_USE_TLS = True MAIL_USERNAME = os.getenv('MAIL_USERNAME') MAIL_PASSWORD = os.getenv('MAIL_PASSWD') MAIL_DEFAULT_SENDER = ('Stone X', os.getenv('MAIL_USERNAME')) ) mail = Mail(app) 构建邮件数据\ne.g.\nfrom flask_mail import Message from app import mail ... message = Message(subject=\u0026quot;Hello, world!!!\u0026quot;, recipients=['Zorn \u0026lt;zorn@example.com\u0026gt;'], body='Across the Great Wall we can reach every corner in the world.') mail.send(message) e.g. 通用方法\nfrom flask_mail import Mail, Message ... # 配置Flash-Mail配置，省略 # 实例化 mail = Mail(app) ... def send_mail(subject, to, body, html='') message = Message(subject, recipients=[to], body=body, html=html) # 使用jinja2渲染内容模板 message.body = render_template('emails/subscribe.txt', **kwargs) message.html = render_template('emails/subscribe.html', **kwargs) mail.send(message) e.g. 异步发送邮件\nfrom threading import Thread ... def _send_async_mail(app, message): with app.app_context(): mail.send(message) def send_mail(subject, to, body, html=''): message = Message(subject, recipients=[to], body=body, html=html) thr = Thread(target=_send_async_mail, args=[app, message]) thr.start() return thr 实战 留言版 使用包组织代码\n每一个包含_*/init/*_.py文件的文件夹都被视作包，包可以让你使用文件夹来组织模块。程序组织结构 sayhello\ninit.py # 构造文件，包含程序实例 templates # 模板文件夹 static # 静态文件，其中又包含js和css文件夹 vies.py # 视图 forms.py 表单 errors.py #错误处理 models.py 数据库模型 commands.py 自定义Flask命令 settings.py 配置文件 配置文件\n#！/usr/bin/env python # coding: utf-8 import os from sayhello import app dev_db = 'mysql://sayhello:Admin!123@39.104.124.226:11306/sayhello' SECREY_KEY = os.getenv('SECREY_KEY', 'secret this ') SQLALCHEMY_TRACK_MODIFICATIONS = False SQLALCHEMY_DATABASE_URI = os.getenv('DATABASE_URI', dev_db) init.py\n#! /usr/bin/env python3 # coding: utf-8 from flask import Flask from flask_bootstrap import Bootstrap from flask_moment import Moment from flask_sqlalchemy import SQLAlchemy app = Flask('sayhello') app.config.from_pyfile('settings.py') app.jinja_env.trim_blocks = True app.jinja_env.lstrip_block = True db= SQLAlchemy(app) bootstrap = Bootstrap(app) moment = Moment(app) # 避免循环依赖，在文件结尾导入 from sayhello import views, errors, commands .flaskenv\nFLASK_APP=sayhello Web程序开发流程\n*开发流程 *\n分析需求，列出功能清单或写需求说明书。 设计程序功能，写功能规格书和技术规格书。 进入开发与测试的迭代 调试和性能等专项测试 部署上线 运行维修与营销等。 前端主要流程\n根据功能规格书画页面草图(sketching) 根据草图做交互式原型图(prototyping) 根据原型图开发前端页面（HTML, CSS, JS） 后端主要流程\n数据库建模 编写表单类 编写视图函数和相关的处理函数 在页面中使用Jinja2替换虚拟数据。 使用Bootstrap-Flask简化页面编写\n安装\npipenv install bootstrap-flask\n实例化\nfrom flask import Flask from flask_bootstrap import Bootstrap app = Flask(name) bootstrap = Bootstrap(app)\n使用Flask-Moment本地化日期和时间\n安装及实例化相似。想要本地化日期，必须使源日期为不包含时区信息的纯正时间。例UTC时间。\n使用Flask-Moment集成Moment.js\nFlask-Moment在模板中提供了moment对象，这个对象提供两个方法来加载资源：moment.include_moment()方法用来加载Moment.js的Javascript资源。moment.include_jquery()用来加载jQuery.这两个方法默认从CDN加载资源。传入local_js参数可以指定本地资源URL。\n... {{ moment.include_moment(local_js=url_for('static), filename='js/moment-with-locales.min.js') }} Flask-Moment默认以英文显示时间，我们可以传入区域字符串“zh-cn”设置为中文。\n... {{ moment.locale('zh-cn') }} 也可以根据用户浏览器或计算机的语言来设置语言。\n... {{ moment.locale(auto_detect=True) }} 渲染时间日期\n{{ moment(timestamp).format('格式字符串) }} Moment.js还支持相对时间，比如三分钟前，一个月前，等\n{{ moment(message.timestamp).fromNow(refresh=True) }} 使用Faker生成虚拟数据\n@app.cli.command() @click.option('--count', default=20, help='Quantity of messages, default is 20.') def forge(count): '''Generate fake messages.''' from faker import Faker db.drop_all() db.create_all() fake = Faker() click.echo('Working....') for i in range(count): message = Message( name=fake.name(), body=fake.sentence(), timestamp=fake.date_time_this_year() ) db.session.add(message) db.session.commit() click.echo('Created %d fake messages.' % count) 使用Flask-DebugToolbar调试程序 个人博客 大型项目结构\nblueblog/ blueprints/ __init__.py blog.py auth.py admin.py templates/ admin/ auth/ blog/ base.html macros.html static/ forms.py models.py emails.py utils.py fakes.py extensions.py 使用蓝本模块化程序\n实例化Flask提供的Blueprint类就创建 一个蓝本实例。就像程序 实例 一样，我们可以为蓝本实例注册路由、错误处理函数、上下文处理函数，请求处理函数，甚至是单独的静态文件文件夹和模板文件夹。在使用上，它和程序实例也很相似。比如，蓝本实例同样拥有一个route()装饰器，可以用来注册路由，但实际上蓝本对象和程序对象却有很大的不同. ###### 创建蓝本使用蓝本不仅仅是对视图函数分类，而是将程序某一部分的所有操作组织在一起。这个蓝本实例以及一系列注册在蓝本实例上的操作的集合被称为一个蓝本。你可以把蓝本想像成模子，它描述了程序某一部分的细节，定义了相应的路由、错误处理器、上下文处理器、请求处理器等一系列操作。但是它本身却不能发挥作用，因为它只是一个模子。只有当你把它注册到程序上时，它才会把物体相应的部分印刻出来\u0026ndash;把蓝本中的操作附加到程序上。 e.g.\nfrom flask import Blueprint auth_bp = Blueprint('auth', __name__) 装配蓝本\n视图函数 蓝本中的视图函数通过蓝本实例提供的route()装饰器注册，即auth_bp.route()。我们把和认证相关的视图函数移动到这个模块，然后注册到auth蓝本上。\n#! /usr/bin/env python3 # coding: utf-8 from flask import Blueprint auth_bp = Blueprint('auth', __name__) @auth_bp.route('/login') def login(): pass @auth_bp.route('/logout') def logout(): pass 错误处理 使用蓝本实例的errorhandler()装饰器可以把错误处理吕注册到蓝本上，这些错误处理器只会捕捉蓝本中的路由发生的错误；使用蓝本实例的app_errorhandler()装饰器则可以注册一个全局的错误处理器。 请求处理函数 在蓝本中，使用before_request, after_request, teardown_request等装饰器注册的请求处理函数是蓝本独有的。也可以使用before_app_request, after_app_reuest, teardown_app_request, before_app_first_request方法，这些方法是全局的。 模板上下文处理函数 和请求钩子类似，蓝本实例可以使用context_processor装饰器注册蓝本特有的模板上下文处理吕在，使用app_context_processor则会注册全局的模板的上下文处理器。另外蓝本对象 也可以使用app_template_global(), app_template_filter()和app_template_test()装饰器，分别用来注册全局的模板全局函数，模板过滤器和模板测试器。\n注册蓝本\n#! /usr/bin/env python3 # coding: utf-8 from flask import Flask from blog.blueprints.auth import auth_bp app = Flask(\u0026quot;StoneBlog\u0026quot;) app.register_blueprint(auth_bp) 我们使用url_prefix参数为auth蓝本下的所有视图URL附加一个URL前缀\napp.register_blueprint(auth_bp, url_prefix='/auth') 使用subdomain参数可以为蓝本下的路由设置子域名。\napp.register_blueprint(auth_bp, subdomain='auth) 蓝本的路由端点\n两种方式\n使用app.route()装饰器将视图函数注册为路由 @app.route('/hello') def hello(): return 'hello' 使用app.add_url_rule()方法注册路由 app.add_url_rule('/hello', 'say_hello', say_hello) 格式\napp.add_url_rule(rule, endpoint, view_func)\n可以使用flask routes 命令查看当前程序注册的所有路由。\n蓝本资源\n如果程序的不同蓝本的页面需要截然不同的样式，可以为蓝本定义独有的静态文件和模板。这时我们需要把蓝本模块升级为包，在构造文件中创建蓝本实例，并在蓝本包中创建静态文件夹static和模板文件夹templates，和程序实例一样，实例化时传入的_*/name/*_变量会被用来判断蓝本的根目录，并以此作为基础寻找模板文件文件夹。要使用蓝本独有的静态文件，你需要在定义蓝本时使用static_folder关键字指定蓝本的静态文件文件夹的路径\nauth_bp = Blueprint(\u0026lsquo;auth\u0026rsquo;, name, static_folder=\u0026lsquo;static\u0026rsquo;, static_url_path=\u0026lsquo;auth/static\u0026rsquo;)\n如果你在注册蓝本时为蓝本定义了URL前缀，即设置了url_prefix参数，那么最终的蓝本静态文件路径会自动设为“/蓝本前缀/static”，这时可以省略static_url_path的定义。在生成用来获取蓝本静态文件的URL时需要写出包含蓝本名称的完整端点，即“蓝本名称.static”\nurl_for('admin.static', filename='style.css) 当蓝本包含独有的模板文件夹时，我们可以在实例化蓝本类时使用template_folder关键字指定模板文件夹的位置\nadmin = Blueprint('admin', __name__, template_folder='templates') 使用类组织配置\n#! /usr/bin/env python3 # coding: utf-8 import os import sys basedir = os.path.abspath(os.path.dirname(os.path.dirname(__file__))) WIN = sys.platform.startswith('win') if WIN: prefix = 'sqlite:///' else: prefix = 'sqlite:////' class BaseConfig(object): SECRET_KEY = os.getenv('SECRET_KEY', 'DEV KEY') SQLALCHEMY_TRACK_MODIFICATIONS = False MAIL_SERVER = os.getenv('MAIL_SERVER') MAIL_PORT = 465 MAILUSER_SSL = True MAIL_USERNAME = os.getenv('MAIL_USERNAME') MAIL_PASSORD = os.getenv('MAIL_PASSWORD') MAIL_DEFAULT_SENDER = os.getenv('StoneBlog Admin', MAIL_USERNAME) BLOG_EMAIL = os.getenv('BLOG_EMAIL') BLOG_POST_PER_PAGE = 10 BLOG_MANAGE_POST_PER_PAGE = 15 BLOG_COMMIT_PER_PAGE = 15 class DevelopmentConfig(BaseConfig): SQLALCHEMY_DATABASE_URI = prefix + os.path.join(basedir, 'data-dev.db') class TestingConfig(BaseConfig): TESTING = True WTF_CSRF_ENABLE = False SQLALCHEMY_DATABASE_URI = 'sqlite:///:memory:' class ProductionConfig(BaseConfig): SQLALCHEMY_DATABASE_URI = os.getenv('DATABASE_URL', prefix + os.path.join(basedir, 'data.db')) config = { \u0026quot;development\u0026quot;: DevelopmentConfig, 'testing': TestingConfig, 'production': ProductionConfig } 现在我们在创建程序实例后使用app.config.from_object()方法加载配置，传入配置类：\n#! /usr/bin/env python3 # coding: utf-8 import os import click from flask import Flask, render_template from flask_bootstrap import Bootstrap from flask_ckeditor import CKEditor from flask_mail import Mail from flask_moment import Moment from flask_sqlalchemy import SQLAlchemy from blog.blueprints.auth import auth_bp from blog.blueprints.admin import admin_bp from blog.blueprints.blog import blog_bp from blog.settings import config app = Flask(\u0026quot;StoneBlog\u0026quot;) config_name = os.getenv('FLASK_CONFIG', 'development') app.config.form_object(config[config_name]) bootstrap = Bootstrap(app) db = SQLAlchemy(app) ckeditor = CKEditor(app) mail = Mail(app) moment = Moment(app) app.register_blueprint(auth_bp, url_prefix='/auth') app.register_blueprint(admin_bp, url_prefix='/admin') app.register_blueprint(blog_bp) @app.shell_context_processor def make_shell_context(): return dir(db=db) @app.errorhandler(400) def bad_request(e): return render_template('errors/400.html'), 400 @app.errorhandler def page_not_found(e): return render_template('errors/404.html'), 404 @app.errorhandler def internal_server_error(e): return render_template('errors/500.html'), 500 @app.cli.command() @click.option('--drop', is_flag=True, help='Create after drop.') def initdb(drop): '''Initialize the database.''' if drop: click.confirm('This operation will delete the database, do you want to continue?', abort=True) db.drop_all() click.echo('Drop database.') db.create_all() click.echo('Initialized database.') 使用工厂函数创建程序实例\n#! /usr/bin/env python3 # coding: utf-8 import os import click from flask import Flask, render_template from blog.extensions import db, mail, ckeditor, moment, bootstrap from blog.blueprints.auth import auth_bp from blog.blueprints.admin import admin_bp from blog.blueprints.blog import blog_bp from blog.settings import config app = Flask(\u0026quot;StoneBlog\u0026quot;) config_name = os.getenv('FLASK_CONFIG', 'development') app.config.form_object(config[config_name]) def create_app(config_name=None): if config_name is None: config_name = os.getenv('FLASK_CONFIG', 'development') app = Flask('blog') app.config.from_object(config[config_name]) register_logging(app) register_extensions(app) register_blueprints(app) register_shell_context(app) register_template_context(app) register_commands(app) register_erros(app) return app def register_logging(app): pass def register_extensions(app): bootstrap.init_app(app) db.init_app(app) ckeditor.init_app(app) mail.init_app(app) moment.init_app(app) def register_blueprints(app): app.register_blueprint(auth_bp, url_prefix='/auth') app.register_blueprint(admin_bp, url_prefix='/admin') app.register_blueprint(blog_bp) def register_shell_context(app): @app.shell_context_processor def make_shell_context(): return dict(db=db) def register_template_context(app): pass def register_erros(app) @app.errorhandler(400) def bad_request(e): return render_template('errors/400.html'), 400 @app.errorhandler def page_not_found(e): return render_template('errors/404.html'), 404 @app.errorhandler def internal_server_error(e): return render_template('errors/500.html'), 500 def register_commands(app): @app.cli.command() @click.option('--drop', is_flag=True, help='Create after drop.') def initdb(drop): '''Initialize the database.''' if drop: click.confirm('This operation will delete the database, do you want to continue?', abort=True) db.drop_all() click.echo('Drop database.') db.create_all() click.echo('Initialized database.') extensions.py\n#! /usr/bin/env python3 # coding: utf-8 from flask_bootstrap import Bootstrap from flask_sqlalchemy import SQLAlchemy from flask_ckeditor import CKEditor from flask_mail import Mail from flask_moment import Moment bootstrap = Bootstrap() db = SQLAlchemy() ckeditor = CKEditor() mail = Mail() moment = Moment() 加载配置 工厂函数接收配置名称作为参数，这们在程序的不同位置传入不同的配置来创建程序实例。\n初始化配置 将扩展类实例化的工作转移到extensions.py脚本中。当我们需要在程序中使用扩展对象时，直接从这个extensions模块导入即可。在工厂函数中，我们导入所有的扩展对象，并对其调用init_app()方法\n组织工厂函数 除了扩展初始化操作，还有许多处理函数需要注册到程序上，比如错误处理函数，上下文处理函数等。\n启动程序 $ flask run\ncurrent_app对象 数据库\n创建数据库模型 邻接列表关系 生成虚拟数据 模板 进阶 ","permalink":"https://stoneepigraph.github.io/posts/flask-web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/","title":"Flask Web开发实战"},{"content":" 函数式编程 函数式编程中没有赋值语句,因此变量一旦有了值,就不会再改变了.更通俗地说,函数式编程完全没有副作用.\nLambda表达式 格式 () -\u0026gt; {} 参数： (): 表式没有参数 单个参数可不加括号 参数可以不加类型，由编译器去推断类型，也可以加上类型。加类型的话需要使用小括号包起来。 参数引用的值而不是变量。但不必须写final变量。 主体： 可以是一个表达式，也可以是一段代码块，如果是一段代码块需要使用大括号包起来。 函数式接口 Java里函数式接口的主要类型 接口 参数 返回类型 示例 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; \u0026mdash;- \u0026mdash;\u0026mdash;\u0026ndash; \u0026mdash;- Predicate\u0026lt;T\u0026gt; T boolean Consumer\u0026lt;T\u0026gt; T void Function\u0026lt;T, R\u0026gt; T R Supplier\u0026lt;T\u0026gt; None T UnaryOperator\u0026lt;T\u0026gt; T T BinaryOperator\u0026lt;T\u0026gt; T, T T 流（Stream） Stream是用函数式编程方式 在集合类上进行复杂操作的工具。\n特点： 惰性求值。看返回值是Stream就是惰性求值。如果返回值是另一个值 或空，那么就是及早求值。 可链式操作。 和Iterator类似，Stream是一种内部迭代试。内部迭代将更多的控制权交给了集合类。 常用流操作 collect(toList()) 生成一个列表，及早求值操作。 map 将一个流中的值转换成一个新的流。参数是一个只接受一个String类型参数并返回一个新的String的Lambda（Function）。 filter 过滤流中的数据。参数是一个Predicate式的Lambda表达式。 flatMap 可用Stream替换值，然后并多个Stream连接成一个Stream。参数 是一个Function接口的Lambda表达式。 multiList.stream() .flatmap(item -\u0026gt; item.getSubList()) .filter(obj -\u0026gt; obj.getLength() \u0026gt; 100) .map(obj -\u0026gt; obj.getName()) .collect(Collections.toList()); max和min 参数是一个Comparator对象。 reduce 实现从一组值中生成一个值。参数是BinaryOperator式的Lambda表达式。 类库 基本类型 Stream类的某些方法对基本类型和装箱类型做了区分。 \u0026gt; e.g. ToLongFunction(), LongFunction()\n重载解析 Lambda表达式作为参数时，其类型由它的目标类型推导得出，推导过程遵循如下规则：\n如果只有一个可能的目标类型，由相应函数接口里的参数类型推导得出。 如果有多个可能的目标类型，由最具体的类型推导得出。 如果有多个可能的目标类型且最具体的类型不明确，则需人为指定类型。 @FunctionInterface 用作函数接口的接口都应该添加这个注解。\n接口默认方法， 多重继承 新增default关键字，修饰默认方法。默认方法工作原理：\n类胜于接口。 子类胜于父类。 如果上面两条规则不适用，子类要么需要实现该方法，要么将该方法声明为抽象方法。 接口多重继承 接口多重量继承时，有可能碰到两个接口包含签名相同的默认方法的情况。Javac并不明确应该继承哪个接口中的方法，因为如果子类没有实现这个默认方法，编译器会报错。\nsuper\n在Java8以前可以使用super指向父类，现在使用类似InterfaceName.super这样的语法指定具体的父类。\n接口的静态方法 Optional Optinal是为核心类库新设计 的一个数据类型，用来替换null值。使用Optional对象的方式之一是在调用get()方法前， 先使用isPresent检查Optional对象是否有值。\n高级集合类和收集器 方法引用： ClassName::MethodName; 注意：\n在方法名后边不加括号。 凡是使用Lambda表达式的地方，就可以使用方法引用。 集合顺序问题。 使用收集器 转换成其他集合使用toList()或者toSet()时，Stream会自动为你指定一种类型的集合。如果不想使用自动指定的类型，可以使用toCollection(),它接受一个函数做参数。 e.g. ```java Stream.collect(toCollection(HashSet::new)) ``` 转换成值 数据分块 partitioningBy，它接受一个流，使用Predicate对象判断一个元素应该属于哪个部分，并根据布尔值将原流分为两个部分。 数据分组 groupingBy，接受一个分类函数，用来对数据分组。 字符串使用Collectors.joining。 组合收集器 mapping允许在收集器的窗口上执行类似的map的操作。但是需要指明使用什么样的集合类存储结果， 比如toList. 重构和定制收集器 先实现Collector接口， 由于Collector接口支持泛型， 因为先得确定一些具体的类型 第一个是待收集元素的类型 第二个是累加器的类型 第三个是最终结果的类型 实现Collector 第一个是实现Supplier工厂方法。有来创建容器 accumulator： 它结合之前操作的结果和当前值。 combine： 如果有两个窗口，我们需要将其合并。 finisher: 将容器转变成最终我们想要的结果。 数据并行化 并行和并发 并发是两个任务共享时间段,并行则是两个任务在同一时间发生,比如运行在多核CPU上. 并行化操作只需改变一个方法的调用 。如果已经有一个Stream对象，调用 它的parallel方法。如果想从一个集合 类创建一个流调用 parallelStream就能获得拥有并行能力的流。还可以使用sequential方法使用并行流转变成串行流。\n性能 影响性能的因素：\n数据大小 源数据结构 性能好：ArrayList，数组，IntStream.range等 性能一般：HashSet，TreeSet等 性能差： LinkedList等对半分解难的结构。 装箱 核的数量 单元处理开销 并行化数组操作 方法名 操作 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; parallelPrefix 任意给定一个函数，计算数组的和 parallelSetAll 使用Lambda表达式更新数组元素 parallelSort 并行化对数组元素进行排序 测试、调试和重构 流中的peek方法\n设计和架构的原则 Lambda表达式改变了设计模式 设计模式是人们熟悉的一种设计思想, 它是软件架构中解决通用问题的模板.如果碰到一个问题,并且恰好熟悉一个与之适应的模式,就能直接应用该模式来解决问题.从某种程度上说,设计模式将解决特定问题的最佳实践途径固定了下来.\n命令模式 策略模式 观察者模式 使用Lambda表达式的领域专用语言 领域专用语言（DSL）是针对软件系统中某特定部分的编程语言。\n内部：类库，提供API方便用例。 外部：CSS，正则等 使用Lambda表达式的SOLID原则 单一功能原则 Single responsibility 程序中的类或方法只能有一个改变的理由。这是强内聚性设计的一部分.说一个类是内聚的,是批它的方法和属性需要统一对待,因为它们紧密相关. 开闭原则 Open/Closed 软件应该对扩展开放，对修改闭合。 依赖反转原则 Liskov substitution 抽象不应依赖细节，细节应该依赖抽象。信赖反转原则的目的是让程序员脱离底层粘合代码, 编写上层业务逻辑代码.这就让上层代码信赖于底层细节的抽象,从而可以重用上层代码.这种模块化和重用方式是双向的:既可以替换不同的细节重用上层代码,也可以替换不同的业务逻辑重用细节的实现. Interface segregation dependency inversion 使用Lambda表达式编写并发程序 ","permalink":"https://stoneepigraph.github.io/posts/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","title":"Java8函数式编程"},{"content":" Linux命令行 初识Linux Shell 什么是Linux Linux可划分为以下四部分：\nLinux内核 GNU工具 图形化桌面环境 应用软件 深入探究Linux内核\n内核主要负责以下四种功能：\n系统内存管理 软件程序管理 硬件设备管理 文件系统管理 系统内存管理\n不公管理服务器上的可用物理内存，还可以创建和不容易理虚拟内存。内核通过硬盘上的存储空间来实现虚拟内存，这块区域称为交换空间（swap space）。内丰存储单元按组划分成很多块，这些块称作页面（page）。内核将每个存在 页面放在物理内存或交换空间。然后， 内核 会维护一个内存页面表。指明哪些页面位于物理内存内，哪些页面被换到硬盘上。内核会记录哪些内存页面正在使用中，并自动把一段时间未访问的内存页面复制 到交换空间区域（称为换出，swapping out_）即使不宜可用内存。当程序要访问一个已被换出的内存页面时，内核必需从物理内存换出另外一个内存页面给它让出空间，然后从交换空间换入请求的内存页面。显然，这个过程 要花时间，拖慢运行的进程。只要Linux系统在运行，为运行中的程序换出内存面对面的的过程 就不会停歇。\n软件程序管理\nLinux操作系统将运行中的程序称为进程。可分为前台运行和后台运行。内核控制着Linux系统管理运行在系统上的所有进程。内核创建了第一个进程（称为init进程）来启动系统上所有的其他进程。当内核启动时，它会将init进程加载到虚拟 内存中。内核 在启动任何其他进程时，都 会在虚拟 内存中给新进程分配 一块发你的区域 来存储该 进程用到的数据和代码。一些Linux发行版使用一个表来管理在系统开机时要自动 启动的进程。在Linux系统上，这个表通常位于专门文件/etc/inittab中。有的系统（如Ubuntu）则采用/etc/init.d目录将开机时启动或停止某个应用的脚本 放在之个目录 下。这些脚本通过/etc/rcX.d目录下的入口 启动。X代表运行级别。运行级别：​\t1.单用户​\t3.标准启动​\t5.X Windows ​\t6.重启\n硬件设备管理\n内核的另一职责 是管理硬件设备。任何Linux系统需要 与之通信的设备，都需要在内核 代码 中加入其驱动程序 代码。程序 代码相当 于应用程序 和硬件设备的中间人，允许内核 与设备之间交换数据。在Linux内核 中有两种方法用于插入设备驱动代码：\n编译进内核 的设备驱动 代码 可插入内核 的设备驱动 模块 Linxu系统将硬件设备当成特殊 的文件，称为设备文件，设备文件有3种分类：\n字符型 设备谁的指处理数据时每次只能处理一个字符 的设备。大多数类型的调制解调器和终端都是作为字符型设备文件创建 的。 块设备文件块设备是指处理数据时每次能处理大块数据 的设备，比如硬盘。 网络设备文件是指采用数据包发送和接收数据 的设备，包括各种网卡和一个特殊 的回环设备。 Linux为系统上的每个设备都创建 一种称为节点的特殊文件。与设备的所有通信都 通过设备节点完成。每个节点都 有唯一 的数值 对供Linux内核 标识 它。数值 对包括一个主设备号和一个次设备号。类似的设备被划分到同样的主设备号下。次设备号用于标识 主设备组下的某个特定设备。\n文件系统管理\n不同于其他一些操作系统，Linux内核 支持通过不同类型的文件系统从硬盘中读写数据。如下列出了Linux系统用来读写数据的标准的文件系统。\n文件系统 描述 \u0026mdash;\u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; ext Linux扩展文件系统，最早的Linux文件系统 ext2 第二扩展文件系统，在ext的基础上提供了更多 的功能 ext3 第三扩展文件系统，支持日志功能 ext4 第四扩展文件系统，支持高级日志功能 hgfs OS/2高性能文件系统 ISO9660 ISO 9660文件系统（CD-ROM） minix minix文件系统 msdos 微软的FAT16 ncp Netware文件系统 nfs 网络文件系统 ntfs 支持Microsoft NT文件系统 proc 访问系统信息 ReiserFS 高级Linux文件系统，能提供性能和硬盘恢复功能 smb 支持网络访问的Samba SMB文件系统 sysv 软早期的Unix文件系统 ufs BSD文件系统 umsdos 建立在msdos上的类Unix文件系统 vfat Windows95文件系统（FAT32） XFS 高性能 64位日志文件系统 GNU工具\nGNU是GNU\u0026rsquo;s Not Unix的缩写。 GNU组织开发了一套完整的Unix工具。\n核心GNU工具\n被称为coreutils软件包，它由三部分构成：\n用以处理文件的工具 用以操作文本的工具 用以管理进程的工具 shell\nGNU/Linux shell 是一种特殊的交互式工具。它为用户提供了启动程序，管理文件系统中的谇反及运行在Linux系统上的进程的途径。shell的核心是命令行提示符。命令行提示符是shell负责交互 的部分。它允许你输入 文本命令，然后解释 命令，并在内核中执行。你也可以将多个shell命令放入文件中作为程序执行。这些文件被称作shell脚本。在Linux，通常有好几中Linux shell可用。不同的shell有不同的特性，有些更利于创建脚本，有些则更利于管理进程。所有Linux发行版默认的shell都是bash shell。\nshell 描述 \u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; ash 一种运行在内存受限环境中简单轻量的shell，但与bash shell完全兼容。 korn 一种与Bourne shell兼容的编程shell,但关联数组和浮点运算待一些高级的编程特性。 tcsh 一种将C语言中的一些元素引入 到shell脚本 中的shell zsh 一种结合 了bash,tcsh和korn的特性，同时提供高级编程特性，共享 历史 文件和主题化提示符的高级shell Linux桌面环境\nX Window系统 KDE桌面\n**　GNOME桌面\nUnity桌面 其他桌面\nFluxbox Xfce JWM Fvwm fvwm95 Linux发行版 不同的Linux发行版通常归类为3种：\n完整的核心Linux发行版 特定用途的Linux发行版 LiveCD测试发行版 核心Linux发行版 发行版 描述 \u0026mdash;\u0026mdash;\u0026mdash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; Slackware 最早的LInux发行版中的一员，在Linux极客中比较流行 Red Hat 主要用于Internet服务器商业发行版 Fedora 从Red Hat分享出的家用发行版 Gentoo 为高级Linux用户设计 的发行版，公包含linux源代码 openSUSE 用于商用和家用的发行版 Debian 在Linux专家和商用 linux产品中流行的发行版 特定用途的Linux发行版\nCentOD Ubuntu PCLinuxOS Mint dyne:bolic Puppy Linux \u0026hellip; Linux LiveCD 走进Shell 进入命令行 控制台终端 图形化终端 通过Linux控制台终端访问CLI 在大多数Linux发行版中，你可以使用简单按键组合访问某个Linux虚拟控制台。通常必须按下Ctrl + Alt组合键，然后按功能键F1 - F7进入要使用的虚拟控制台。可以将终端的背景色设置成白色，其中一种方法是 \u0026gt; setterm -inversescreen on 或 \u0026gt; setterm -background white \u0026gt; \u0026gt; setterm -foreground black 共有八种颜色可供选择，分别是black, red, green, yeallow, blue, magenta, cyan, white\n选项 参数 描述 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- -background black, red, green, yellow, blue, magenta, cyan, white 将终端的背景色改为指定颜色 -foreground black, red, green, yellow, blue, magenta, cyan, white 将终端的前景色改为指定颜色 -inversescreen on或off 交换背景色和前景色 -reset 无 将终端外观恢复成默认设置并清屏 -store 无 将终端当前的前景色和背景色设置成-reset选项的值 通过图形化终端仿真访问CLI 使用GNOME Terminal仿真器 使用Konsole Terminal仿真器 使用Xterm 基本Bash shell命令 启动Shell shell提示符 默认bash shell提示符是美元符号（$），这个符号表明shell在等待用户输入。\nbash手册 大多数Linux发行版自带用以查找shell命令及其他GNU工具信息的在线手册 。 man命令用来访问存储在Linux系统上的手册的页面。 Linux手册页惯用的节名\n节 描述 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; Name 显示命令名和一段简短的描述 Synopsis 命令的语法 Configuration 命令配置信息 Description 命令的一般性描述 Options 命令选项描述 Exit Status 命令的退出状态指示 Return Value 命令的返回值 Errors 命令的错误的消息 Environment 描述所使用的环境变量 Files 命令用到的文件 Versions 命令的版本信息 Conforming To 命名所遵从的标准 Notes 其他有帮助的资料 Bugs 提供提交Bug的途径 Example 展示命令的用法 Authors 命令开以人员的信息 Copyright 命令源代码 的版权状况 See Also 与该 命令类型的其他命令 Linux手册页的内容区域\n区域号 所涵盖的内容 \u0026mdash;\u0026mdash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; 1 可执行程序或shell命令 2 系统调用 3 库调用 4 特殊文件 5 文件格式与约定 6 游戏 7 概览，约定及杂项 8 超级用户和系统管理员命令 9 内核例程 手册页不是唯一 的资料。还有另一种叫作info页面的信息。另外大多数命令都可以接受-help或\u0026ndash;help选项。\n浏览文件系统 Linux文件系统\nLinux路径本身并没有提供任何有关文件空间存放在哪个物理磁盘上的信息。在Linux PC上安装的第一块硬盘称为根驱动器。根驱动器包含了虚拟目录的核心，其他目录都是从那里开始构建的。 常见Linux目录名称\n目录 用途 /bin 二进制目录，存放许多用户级的GNU工具 /boot 启动目录，存放启动文件 /etc 系统配置文件目录 /home 主目录，Linux在这里创建用户的目录 /lib 库目录，存放系统和应用程序的库文件 /media 媒体目录，可移动媒体设备的常用挂载点 /mnt 挂载目录，另一个可移动 媒体设备的常用挂载点 /opt 可选目录，常用于存放第三方软件包和数据文件 /proc 进程目录，存放现有硬件及当前相关信息 /root root用户的主目录 /sbin 系统二进程目录，存放许多GNU管理员级工具 /run 运行目录，存放系统动作时的运行时数据 /srv 服务目录，存放本地服务的相关文件 /sys 系统目录，存放系统硬件信息的相关文件 /tmp 临时目录，可以在该目录中创建和删除临时工作文件 /usr 用户二进制目录，大量用户级的GNU工具和数据文件都存储在这里 /var 可变目录，用以存放经常变化的文件，比如日志文件 遍历目录\n\u0026gt; cd destination\n绝对文件路径 绝对文件路径总是以正斜线作为起始，指明虚拟文件系统的根目录。\n显示shell会话的当前目录 \u0026gt; pwd\n相对文件路径 相对文件路径允许用户指定一个基于当前位置的目录文件路径。单点（.）: 表示当前目录双点（..）:表示当前目录的父目录\n文件和目录列表 基本列表功能\n*ls**命令最基本的形式会显示当前目录下的文件和目录参数： *-F**： 可以轻松区分文件和目录，它会在目录后边加/,还会在可执行文件后边星号。 -a: 可以把隐藏文件和普通文件及目录一起显示出来。 *-R**： 递归选项 *-l**： 长列表格式输出 **-i**： 显示inode 会显示如下内容：\n文件类型，比如目录（d），文件（-）， 字符型文件（c）或块设备（b）； 文件的权限 文件的硬链接总数 文件属主的用户名 文件属组的组名 文件的大小（以字节为单位） 文件的上次修改时间 文件名或目录名 **-h**： 以容易识别的文件大小显示\n过滤输出列表\nls xxx\n?: 代表一个字符 *：代表零个或多个字符 处理文件 创建文件\n\u0026gt; touch filename 会创建一个空文件如果只想改变文件的访问时间可以使用-a参数 \u0026gt; touch -a filename\n复制文件\n\u0026gt; cp source destination 参数： -i: 重名需要确认 -R: 递归\n制表键自动补全 链接文件\nLinux中有两种不同类型的文件链接\n符号链接 \u0026gt; ls -s source lnFile lnFile是指向source的一个新文件，可以通过inode编号查看\n硬链接 硬链接会创建独立的虚拟文件，其中包含了原始文件的信息及位置。但是它们从根本上而言是同一个文件。引用硬链接文件等同于引用了源文件。要创建硬链接，原始文件也必须事先存在，只不过这次使用ln命令时不再需要加入额外的参数了。\n重命名文件\nmv命令，可以将目录移动到另一个位置或重新命名 \u0026gt; mv source destination 或 \u0026gt; mv oldfilename newfilename\n删除文件\n\u0026gt; rm -i file -i: 删除文件时需要确认一次才会删除 *-f**：强制删除文件 *-r**：级联删除文件夹\n处理目录 创建目录\n\u0026gt; mkdir newDir 参数： **-p**：创建多级目录\n删除目录\n\u0026gt; rm -ri\n查看文件内容 查看文件类型\n\u0026gt; file my_file \u0026gt; \u0026gt; \u0026gt; my_file: ASCII text\n查看整个文件\ncat -n： 显示行号 -b： 只给有文本的行加上行号 -T： 用^I替换制表符 more 以分页的形式显示文件内容 less 查看部分文件\ntail tail命令默认会显示文件最后10行内容 -n 2： 显示最后两行内容 -f： 使tail保持活动状态，并不断显示添加到文件中的内容 head 默认显示文件的前10行 head -num： 显示前num行内容 更多的Bash shell 监测程序 探查进程\n默认ps只会显示运行在当前控制台下的属于当前用记的进程。 Linux系统中使用的GNU ps命令支持3种不同类型的命令行参数：\nUnix风格的参数，前面加单破折线 BSD风格的参数，前面不加破折线 GNU风格的长参数，前面加双破折线 Unix风格的ps命令参数\n参数 描述 \u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- -A 显示所有进程 -N 显示与指定参数不符的所有进程 -a 显示除控制进程和无终端进程外的所有进程 -d 显示除控制进程外的所有进程 -e 显示所有进程 -C cmdlist 显示包含在cmdlist列表中的进程 -G grplist 显示组ID在grplist列表中的进程 -U userlist 显示属主的用户ID在userlist列表中的进程 -g grplist 显示会话或组ID在grplist列表 -p pidlist 显示PID在pidlist列表中的进程 -s sesslist 显示会话ID在sesslist列表中的进程 -t ttylist 显示终端ID在ttylist列表中的进程 -u userlist 显示有效用户iD在userlist列表中的进程 -F 显示更多额外输出（相对于-f参数而言） -O format 显示默认的输出列以及format列表指定的特定列 -M 显示进程的安全信息 -c 显示进程额外调试器信息 -f 显示完整格式的输出 -j 显示任务信息 -l 显示长列表 -o format 公显示由format指定的列 -y 不要显示进程标记（process flag, 表明进程状态的标记） -Z 显示安全标签（security context)信息 -H 用层级格式来显示进程（树状，用来显示父进程） -n namelist 定义了WCHAN列显示的值 -w 采用宽输出模式，不限宽度显示 -L 显示进程中的线程 -V 显示ps命令的版本号 e.g. \u0026gt; ps -ef 显示内容：\nUID： 启动这些进程的用户 PID： 进程的进程ID PPID： 父进程的进程号（如果该 进程是由另一个进程启动的） C： 进程生命周期中的CPU利用率 STIME： 进程启动时的系统时间 TTY： 进程启动时的终端设备 TIME: 运行进程需要的累计CPU时间 CMD： 启动的程序名称 -l参数：多出的列：\nF： 内核分配给进程的系统标记 S： 进程的状态（O代表正在运行；S代表在休眠；R代表可运行，正等待运行；Z代表僵化，进程已结束但父进程已不存在；T代表停止） PRI： 进程的优先级（越大的数字低的优先级） NI： 谦让度值 用来参与决定优先级 ADDR： 进程的内存地址 SZ： 假如进程被换出， 所需要交换空间的大致大小 WCHAN： 进程休眠的内核函数的地址 BSD风格 主要命令参数：\n参数 描述 \u0026mdash;\u0026mdash;\u0026mdash;- \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- T 显示跟当前终端关联的所有进程 a 显示跟任意终端关联的所有进程 g 显示所有的进程，包括控制进程 r 仅显示运行中的进程 x 显示所有的进程，甚至包括未分配任何终端的进程 U userlist 显示归userlist列表中的某用户ID所有的进程 p pidlist 显示PID在pidlist列表中的进程 t ttylist 显示所关联的终端在ttylist列表中的进程 O format 除了默认输出的列之外，还输出由format指定的列 X 按过去的Linux i386寄存器格式显示 Z 将安全信息添加到输出中 j 显示任务信息 l 采用长模式 o format 公显示由format指定的列 s 采用信号格式显示 u 采用基于用户的格式显示 v 采用虚拟内存格式显示 N namelist 定义在WCHAN列中使用的值 O order 定义显示信息列的顺序 S 将数值信息从子进程加到父进程上，比如CPU和内存的使用情况 c 显示真实的命令名称 （用以启动进程的程序名称） e 显示命令使用的环境变量 f 用分层格式来显示进程，表明哪些进程启动了哪些进程 h 不显示头信息 k sort 指定用以将输出排序的列 n 和WCHAN信息一起显示出来，用数值来表示用户ID和组ID w 为较宽屏幕显示宽输出 H 将线程按进程来显示 m 在进程后显示线程 L 列出所有格式指定符 V 显示ps命令的版本号 输出结果中的大部分的输出列跟使用Unix风格参数时的输出是一样的，只有一小部分如下：\nVSZ： 进程在内存中的大小以KB为单位 RSS： 进程在未换出时占用的物理内存 STAT： 代表当前进程状态 的双字符状态码 第一个字符采用了和Unix风格S列相同的值，表明进程是在休眠，运行还是等待。 第二个参数进一步说明进程的状态 \u0026lt;: 该进程运行在高优先级上 N：该进程运行在低优先级上 L： 该进程有页面锁定在内存中 s： 该 进程是控制进程 l： 该进程是多线程的 +： 该进程运行在前台 GNU长参数 常用参数\n参数 描述 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; \u0026ndash;deselect 显示所有进程，命令行中列出的进程 \u0026ndash;Group grplist 显示组ID在grplist列表中的进程 \u0026ndash;User userlist 显示用户ID在userlist列表中的进程 \u0026ndash;group grplist 显示有效组ID在grplist列表中的进程 \u0026ndash;pid pidlist 显示PID在pidlist列表中的进程 \u0026ndash;ppid pidlist 显示父PID在pidlist列表中的进程 \u0026ndash;sid sidlist 显示会话ID在sidlist列表中的进程 \u0026ndash;tty ttylist 显示终端设备号在ttylist列表中的进程 \u0026ndash;user userlist 显示有效用户ID的userlist列表中的进程 \u0026ndash;format format 仅显示由format指定的列 \u0026ndash;context 显示额外的安全信息 \u0026ndash;cols n 将屏幕宽度设置为n列 \u0026ndash;columns n 将屏幕宽度设置为n列 \u0026ndash;cumulative 包含已停止的子进程的信息 \u0026ndash;forest 用层级结构显示出进程和父进程之间的关系 \u0026ndash;headers 在每页输出中都显示列的头 \u0026ndash;no-headers 不显示列的头 \u0026ndash;lines n 将屏幕高度设为n行 \u0026ndash;rows n 将屏幕高度设为n排 \u0026ndash;sort order 指定将输出按哪列排序 \u0026ndash;width n 将屏幕宽度设为N列 \u0026ndash;help 显示帮助信息 \u0026ndash;info 显示调试信息 \u0026ndash;version 显示ps命令的版本号 实时监测进程\n\u0026gt; top 输出的第一部分显示的是系统的概况：第一行显示了当前时间，系统的运行时间，登录的用户数以及系统的平均负载。​\t平均负载有3个值，最近1分钟的，最近5分钟的和最近15分钟的平均负载。值越大说明系统的负载越高。​\t通常，如果系统的负载值超过2，就说明系统比较繁忙了。第二行显示了进程概要信息\u0026ndash;top命令的输出中将进程叫作任务（task）：​\t有多少进程处在运行，休眠，停止或僵化状态第三行显示了Cpu的概要信息。紧跟其后的两行说明了系统内存的状态。​\t第一行是系统的物理内存： 总共有多少内存，当前使用了多少，还有多少空闲。后一行说的是同样的信息，不过是针对系统交换空间。最后一部分显示了当前运行中的进程的详细列表。有些跟ps命令的输出类似。\nPID：进程的ID USER： 进程属主的名字 PR： 进程的优先级 NI： 进程的谦让度值 VIRT： 进程占用的虚拟内存总量 RES： 进程占用的物理内存总量 SHR： 进程和其他进程共享 的内存总量 S： 进程的状态（D代表可中断的休眠状态，R代表在运行状态，S代表休眠状态，T代表跟踪状态或停止状态，Z代表僵化状态） %CPU： 进程使用的CPU时间比例 %MEM： 进程使用的内存占可用内存的比例 TIME+： 自进程启动到目前为止的CPU时间总量 COMMAND： 进程所对应的命令行名称，也就是启动的程序名。 默认top命令会对按昭%cpu值对进程排序。可以在top运行时使用多种交互命令重新排序。每个交互式命令都 是单字符，在top命令运行时键入可改变top的行为。键入f允许你选择对输出进行排序的字段，键入d允许你修改轮询间隔。键入q可以退出top。用户在top命令的输出上有很大的控制权。\n结束进程\n在Linux中进程之间通过信号来通信。 Linux进程信号：\n信号 名称 描述 \u0026mdash;- \u0026mdash;- \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- 1 HUP 挂起 2 INT 中断 3 QUIT 结束运行 9 KILL 无条件终止 11 SEGV 段错误 15 TERM 尽可能终止 17 STOP 无条件停止运行，但不终止 18 TSTP 停止或暂停，但继续在后台运行 19 CONT 在STOP或TSTP之后恢复执行 在Linux中有两个命令可以向运行中的进程发出进程信号\nkill\n\u0026gt; kill -option pid pid pid\u0026hellip;\nkillall\nkillall命令支持通过进程名而不是PID来结束进程。 killall也支持通配符。 e.g. \u0026gt; killall http* * 结束所有以http开头的进程\n监测磁盘空间 挂载存储媒体\nmount\n默认情况下,mount命令会输出当前系统上挂载的设备列表默认提供如下四部分信息：\n媒体的设备文件名 媒体挂载到虚拟目录的挂载点 文件系统类型 已挂载媒体的访问状态 需要手动在虚拟目录中挂载设备，需要以root用户身价登录，或是以root用户身份运行sudo命令。 \u0026gt; mount -t type device directory 如果Type是VindowsPC共用的存储设备，通常类型如下：\nvfat: Windows长文件系统 ntfs: windows NT, XP, Vistra和Windows7中广泛使用的高级文件系统 iso9660： 标准Cd-ROM文件系统 mount命令的参数\n参数 描述 \u0026mdash;\u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; -a 挂载/etc/fstab文件中指定的所有文件系统 -f 使用mount命令模拟挂载设备，但并不真的挂载 -F 和-a参数一起使用时，会同时挂载所有文件系统 -v 详细模式，将会说明挂载设备的每一步 -I 不启用任何/sbin/mount.filesystem下的文件系统帮助文件 -l 给ext2,ext3或XFS文件系统自动 添加文件系统标签 -n 挂载设备，但不注册到/etc/mtab已挂载设备文件中 -p num 进行加密挂载时，从文件描述符num中获得密码短语 -s 忽略该文件系统不支持的挂载选项 -r 将设备挂载为只读的 -w 将设备挂载为可读写的（默认参数） -L label 将设备按指定 的label挂载 -U uuid 将设备按指定的uuid挂载 -O 和-a参数一起使用，限制命令只作用到特定的一组文件系统上 -o 给文件系统添加特定的选项 以下为-o常用参数\nro： 以只读形式挂载 rw： 以读写形式挂载 user： 允许普通用户挂载文件系统 check=none： 挂载文件系统时不进行完整校验 loop： 挂载一个文件 umount\n从Linux系统上移除一个可移动设备时，不能直接从系统上移除，而应该先卸载。 \u0026gt; umount [directory | device]\ndf\n用来查看所有已挂载磁盘的使用情况命令输出格式：\n设备的设备文件位置 能容纳多少个1024字节大小的块 已用了多少个1024字节大小的块 还有多少个1024字节大小的块可用 已用空间所占比例 设备挂载到了哪个挂载点上 常用参数：\n-h： 以可读的方式显示容量 du\n此命令可以显示某个特定目录（默认情况下是当前目录）的磁盘使用情况常用参数\n-c : 显示所有已列出文件总的大小 -h： 按用户易读的格式输出大小 -s： 显示每个输出参数的总计 \u0026ndash;max-depth=num: 只统计num深度的目录 处理数据文件 排序数据\nsort\n常用参数：\n单破折线 双破折线 描述 \u0026mdash;\u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; -b \u0026ndash;ignore-leading-blanks 排序时忽略起始的空白 -C \u0026ndash;check-quiet 不排序，如果数据无序也不要报告 -c \u0026ndash;check 不排序，但检查输入数据是不是已排序；未排序的话，报告 -d \u0026ndash;dictionary-order 仅考虑空白和字母，不考虑特殊字符 -f \u0026ndash;ignore-case 默认情况下，会将大写字母排在前面；这个参数会忽略大小写 -g \u0026ndash;general-number-sort 按通用数值来排序（跟-n不同，把值当浮点数来排序，支持科学计数法表示的值） -i \u0026ndash;ignore-nonprinting 在排序时忽略不可打印字符 -k \u0026ndash;key=POST1 [, POS2] 排序从POS1位置开始，如果指定了POS2的话，到POS2位置结束 -M \u0026ndash;month-sort 用三个字符月份名按月份排序 -m \u0026ndash;mrege 将两个已排序数据文件合并 -n \u0026ndash;numeric-sort 按字符串数值来排序（并不转换为浮点数） -o \u0026ndash;output=file 将排序结果写出到指定的文件中 -R \u0026ndash;random-sort \u0026ndash;random-source=FILE 按随机生成的散列表的键值排序。 指定 -R参数用到的随机字节的源文件 -r \u0026ndash;reverse 反序排序 -S \u0026ndash;buffer-size=SIZE 指定使用的内存大小 -s \u0026ndash;stable 禁用最后重排序比较 -T \u0026ndash;temporary-directory=DIR 指定一个位置来存储临时工作文件 -t \u0026ndash;field-separator=SEP 指定一个用来区分键位置的字符 -u \u0026ndash;unique 和-c参数一起使用时， 检查严格排序；不和-c参数一起使用时，公输出第一例相似的两行 -z \u0026ndash;zero-terminated 用NULL字符作为行尾，而不是用换行符 搜索数据\ngrep\n\u0026gt; grep [option] pattern [file] 常用参数：\n-v： 输入不匹配该模式的行 -n： 显示行号 -c： 统计符合匹配的行数 -e：多模式匹配，每个参数使用-e来标识 parttern支持正则表达式 fgrep 压缩数据\nLinux文件压缩工具\n工具 文件扩展名 描述 \u0026mdash;\u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;\u0026mdash;- \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- bzip2 .bz2 采用Burrows-Wheeler块排序文本压缩算法和霍夫曼编码 compress .Z 最初的Unix文件压缩工具，已经快没人用了 gzip .gz GNU压缩工具，用Lempel-Ziv编码 zip .zip Windows上PKZIP工具的Unix实现 gzip\n这个软件意在编写一个能够替代原先Unix中compress工具的免费版。它包含以下工具\ngzip: 用来压缩文件 gzcat: 用来查看压缩过的文本文件的内容 gunzip: 用来解压缩 归档数据\ntar\n\u0026gt; tar function [options] object1 object2 \u0026hellip;. function参数定义了tar命令应该做什么，如下：\n功能 长名称 描述 \u0026mdash;- \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; -A \u0026ndash;concatenate 将一个已有的tar归档文件追加到另一个已有tar归档文件 -d \u0026ndash;create 创建一个新的tar归档文件 -d \u0026ndash;diff 检查归档文件和文件系统的不同之年 \u0026ndash;delete 从已有tar归档文件中删除 -r \u0026ndash;append 追加文件到已有tar归档文件末尾 -t \u0026ndash;list 列出已有tar归档文件中的内容 -u \u0026ndash;update 将比tar归档文件中已有的同名文件新的文件追加到该 tar归档文件中 -x \u0026ndash;extract 从已有tar归档文件中提取文件 tar命令选项\n选项 描述 \u0026mdash;\u0026mdash;- \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; -C dir 切换到指定目录 -f file 输出结果到时文件或设备file -j 将输出重定向给bzip2命令来压缩内容 -p 保留所有文件权限 -v 在处理文件时显示文件 -z 将输出重定向给gzip命令来压缩内容 理解 Shell shell的类型 系统启动什么样的shell程序取决于你个人的用户配置。在/etc/passwd文件中，在用记ID记录的第7个字段中列出了默认的shell程序。\nshell的父子关系 bash shell程序可使用命令行参数修改shell启动方式。常用参数：\n参数 描述 \u0026mdash;\u0026mdash;\u0026mdash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- -c string 从string中读取命令并进行处理 -i 启动一个能够接收用户输入 的交互式shell -l 以登录shell的形式启动 -r 启动一个受限shell，用户会被限制在默认目录中 -s 从标准输入中读取命令 进程列表\n将所有命令写在一行并以分号分隔，最后使用圆括号括起所有命令。 \u0026gt; (pwd; cd; ls; echo $BASH_SUBSHELL) 加入括号使命令列表变成了进程列表，生成了一个子shell来执行对应的命令。进程列表是一种命令分组（command grouping）。另一种命令分组是将命令放入花括号中，并在命令列表尾部加上分号（；）。语法为{command; }。使用花括号进行命令分组并不会像进程列表那样创建出子shell.\n别出心裁的子shell用法\n探索后台模式\nsleep\n在后台模式中运行命令可以在处理命令的同时让出CLI，以供使用。演示后台模式的一个经典命令就是sleep。 sleep接受一个cdvo,yynw参数是你希望进程等待的秒数。 \u0026gt; sleep 10 \u0026amp; 想要将命令置入后台模式，可以在命令末尾加上字符\u0026amp;。\njobs\n可以显示出当前运行在后台模式中的所有用户的进程。参数：\n-l： 显示后台进程的PID 将进程列表置入后台\n\u0026amp;\n协程\n协程可以同时做两件事。它在后台生成一个子shell，并在这个子shell中执行命令。要进程协程处理，得使用coproc命令，还有要在子shell中执行的命令。 e.g. #+end_src coproc My_job { sleep 10; } [1] 2570 jobs [1]+ Running coproc My_job { sleep 10; } \u0026amp; #+end_src\n理解shell的内建命令 外部命令\n外部命令，有时候也被称为文件系统命令，是存在于bash shell之外的程序。它们并不是sheel程序的一部分。外部命令程序通常位于/bin,/usr/bin,/sbin或者/usr/bin中。我们可以使用which和type命令找到它们。当外部命令执行时，会创建一个子进程。这种操作被称为衍生（forking)。\n内建命令\n内建命令与外部命令的区别在于前都不需要使用子进程来执行。它们已经和shell编译成了一体，作为shell工具的组成部分存在。不需要借助外部程序文件来运行。因为不既不需要通过衍生出子进程来执行，也不需要打开程序文件，内建命令的执行速度要更快，效率也高。\nhistory\n可以查看最近用过的命令列表，通常历史记录中会保存最近的1000条命令。你也可以修改这个数字，你需要修改名为HISTSIZE的环境变量。\nhistory -a: 可以将命令历史强制写入.bash_history文件。 命令别名\nalias命令是另一个shell的内建命令。它允许你为常用的命令及其参数创建另一个名称，从而将输入量减少到最低。很多Linux发行版很有可能已经为你设置好了一些常用命令的别名。可以使用alias -p查看。\n使用Linux环境变量 Linux环境变量能帮你提升Linux shell体验。很多程序和脚本都通过环境变量来获取系统信息、存储临时数据和配置信息。\n什么是环境变量 在bash shell中，环境变量分为两类：\n全局变量 局部变量 全局环境变量\n全局环境变量对于shell会话和所有生成的子shell都是可见的。局部变量则只对创建他们的shell可见。查看全局变量，可以使用env或printenv命令。要显示个别环境变量的值，可以使用printenv命令。 \u0026gt; printenv HOME 也可以使用echo $环境变量名 \u0026gt; echo $HOME\n局部环境变量\n局部变量只能在定义它们的进程中可见。在Linux系统中没有一个只显示局部环境变量的命令。 set命令会显示为某个特定进程设置的所有环境变量，包括局部变量，全局变量以及用户定义变量。 \u0026lt;!\u0026ndash;命令env,printenv和set之间的差异很细微，set命令会显示出全局变量，局部变量以及用户定义变量。它还会按照字母顺序对结果进行排序。env和printenv命令同set命令的区别在于前两个命令不会对变量排序。也不会输出局部变量和用户定义变量。在这种情况下，env和printenv的输出是重复的。\u0026ndash;\u0026gt;\n设置用户定义变量 可以在bash shell中直接设置自己的变量。\n设置局部用户定义变量\n我们可以通过等号给环境变量赋值，值可以是数值或字符串。 \u0026gt; my_variable=Hello \u0026gt; \u0026gt; echo $my_variable 如果要给变量赋一个含有空格的字符串值，必须用单引号来界定字符串的首和尾。 变量名，等号和值之间不能有空格。\n设置全局环境变量\n方法是：先创建一个局部环境变量，然后再把它导出到全局环境中。使用export命令完成命令导出到全局环境，变量名前不需要加$.\n删除环境变量 unset 注意： 在涉及环境变量名时，如果要用到变量，使用\\(；如果要操作变量，不加\\)。这条规则的一个例外就是使用printenv显示某个变量的值。\n默认的shell环境变量 bash shell支持的Bourne变量\n变量 描述 \u0026mdash;\u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- CDPATH 冒号分隔的目录列表， 作为cd命令的搜索路径 HOME 当前用户的主目录 IFS shell用来将文本字符串分割成字段的一系列字符 MAIL 当前用户收件箱的文件名 MAILPATH 冒号分隔当前用户收件箱的文件名列表 OPTARG getopts命令处理的最后一个选项参数值 OPTIND getopts命令处理的最后一个参数的索引号 PATH shell查找命令的目录列表，由冒号分隔 PS1 shell命令行界面的主提示符 PS2 shell命令行界面的次提示 bash shell环境变量\n变量 描述 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; BASH 当前shell实例的全路径名 BASH_ALIASES 含有当前已设置别名的关联数组 BASH_ARGC 含有传入子函数或shell脚本 的参数总数的数组变量 BASH_ARCV 含有传入子函数或shell脚本的参数的数组变量 BASH_CMDS 关联数组，包含shell执行过的命令的所有位置 BASH_COMMAND shell正在执行的命令或马上就执行的命令 BASH_ENV 设置了的话，每个bash脚本会在运行前先尝试运行该 变量定义的启动文件 BASH_EXECUTION_STRING 使用bash -c选项传递过来的命令 BASH_LINENO 含有当前执行的shell函数的源代码秸的数组变量 BASH_REMATCH 只读数组，在使用正则表达式的比较运算符=~进行肯定匹配（positive math）时，包含了匹配到的模式和子模式 BASH_SOURCE 含有当前正在 执行的shell函数所在源文件名的数组变量 BASH_SUBSHELL 当前子shell环境的嵌套级别（初始是0） BASH_VERSINFO 含有当前运行的bash shell的主版本号和次版本号和数组变量 BASH_VERSION 当前运行的bash shell的版本号 BASH_XTRACEFD 若设置成了有效的文件描述符（0，1，2），则\u0026rsquo;set -x\u0026rsquo;调试选项生成的跟踪输出可被重定向。通常用来将跟踪输出到一个文件中 BASHOPTS 当前启动的bash shell选项的列表 BASHPID 当前bash进程的PID COLUMNS 当前bash shell实例所有终端的宽度 COMP_CWORD COMP_WORDS变量的索引值，后者含有当前光标的位置 COMP_LINE 当前命令行 COMP_POINT 当前光标位置相对于当前命令起始索引 COMP_KEY 用来调用shell函数补全功能 的最后一个键 COMP_TYPE 一个整数值，表示所尝试的补全类型，用以完成shell函数补全。 COMP_WORDBREAKS Readline库中用于单词补全的词分隔字符 COMP_WORDS 含有当前命令行所有单词的数组变量 COMPREPLY 含有由shell函数生成的可能填充代码的数组变量 COPROC 占用未命名的协进程的I/O文件描述 符的数组变量 DIRSTACK 含有目录栈当前内容的数组变量 EMACS 设置为‘t\u0026rsquo;时，表明emacs shell缓冲区正在工作，而行编辑功能被禁止 ENV 如果设置了该 环境变量，在bash shell脚本 运行之前会先执行已定义的启动文件（仅用于当bash shell以POSIX模式被调用时） EUID 当前用户的有效用户ID（数字形式） FCEDIT 供fc命令使用的默认编辑器 FIGNORE 在进行文件名补全时可以忽略后缀名列表，由冒号分隔 FUNCANME 当前执行的shell函数名称 FUNCNEST 当设置成非零时，表示所允许的最大函数嵌套级数（一旦超出，当前命令即被终止） GLOBIGNORE 冒号分隔的模式列表，定义了在进行文件名扩展时可以忽略的一组文件名 GOUPS 含有当前用户属组列表的数组变量 HISTCHARS 控制历史记录扩展，最多可有3个字符 HISTCMD 当前命令在历史记录中的编号 HISTCONTROL 控制哪些命令留在历史记录列表中 HISTFILE 保存shell历史记录列表 的文件名（默认是.bash_hisotry) HISTFILESIZE 最多在历史文件中存多少行 HISTTIMEFORMAT 如果设置了且非空，就用作格式化字符串，以显示bash历史中每条命令的时间戳 HISTIGNORE 同冒号分隔的模式列表，同用来决定 历史文件中哪些命令会被忽略 HISTSIZE 最多在历史文件中存多少条命令 HISTFILE shell在补全主机名时读取的文件名 HOSTNAME 当前主机的名称 HOSTTYPE 当前运行bash shell的机器 IGNOREEOF shell在退出前必须收到连续的EOF字符的数量（如果这个值不存在，默认是1） INPUTRC Readline初始化文件名（默认是.inputrc) LANG shell的语言环境类别 LC_ALL 定义了一个语言环境类别，能够覆盖LANG变量 LC_COLLATE 设置对字符串排序时用的排序规则 LC_CTYPE 决定如何解释出现在文件名扩展和模式匹配中的字符 LC_MESSAGES 在解释前面带有$的双引号字符串时，该环境变量决定了所采用的语言环境设置 LC_NUMERIC 决定着格式化数字时采用的语言环境设置 LINENO 当前执行的脚本 的行号 LINES 定义了终端上可见的行数 MACHTYPE 用“CPU-公司-系统”（Cpu-company-system）格式定义的系统类型 MAPFILE 一个数组变量，当mapfile命令未指定数组变量作为参数时， 它存储了mapfile所讲稿的文本 MAILCHECK shell查看新邮件的频率 （以秒为单位，默认是60） OLDPWD shell之前的工作目录 OPTERR 设置为1时，bash shell会显示getopts命令产生的错误 OSTYPE 定义了shell所在的操作系统 PIPESTATUS 含有前台进程的能出状态列表 的数组变量 POSIXLY_CORRECT 设置了的话，bash会以POSIX模式启动 PPID bash shell父进程的PID PROMPT_COMMAND 设置了的话，在命令行主提示符显示之前会执行这条命令 PROMPT_DIRTRIM 用来定义当启用了\\w或\\W提示符字符串转义时显示的尾部目录名的数量。被删除的目录名会用一组英文句点替换 PS3 select命令的提示符 PS4 如果使用了bash的-x选项，在命令行之前显示的提示信息 PWD 当前工作目录 RANDOM 返回一个0~32767的随机数（对其的赋值可作为随机数生成器的种子） READLINE_LINE 当使用bind -x命令时，存储Readline缓冲区的内容 READLINE_POINT 当使用bind -x命令时，表示 Readline缓冲区内容插入点的当前位置 REPLY read命令的默认变量 SECONDS 自从shell启动到现在的秒数（对其赋值将重置计数器） SHELL bash shell的全路径名 SHELLOPTS 已启用bash shell选项列表，列表荐这间以冒号分隔 SHLVL shell的层级；每次启动一个新bash shell，该值增加1 TIMEFORMAT 指定了shell的时间显示格式 TMOUT select和read命令在没输入的情况下等待多久（以秒为单位），默认值 为0，表示无限长 TMPDIR 目录名，保存bash shell创建 的临时文件 UID 当前用户的真实用记ID（数字形式） 设置PATH环境变量 PATH环境变量定义了用于进行命令和程序查找的目录。如果命令或者程序的位置没有包括 在PATH变量中，那么如果使用的不是绝对路径 的话，shell是没法找到的。所以把新的搜索目录添加到现有的PATH环境变量中。 PATH中各个目录之间是用冒号分隔的。你只需要引用原来的PATH值，然后再给这个字符串添加新目录就行了。\n定位系统环境变量 登录shell\n当你登录Linux系统时，bash shell会作为登录shell启动。登录shell会从5个不同的启动文件时读取命令：\n/etc/profile $HOME/.bash_profile $HOME/.bashrc $HOME/.bash_login $HOME/.profile /etc/profile文件是系统上默认的bash shell的主启动文件。系统上的每个用户登录时都会执行启动这个文件。另外4个启动文件是针对 用户的，可根据个人需求定制。\n/etc/profile\n每个发行版的/etc/profile文件都有不同的设置和命令\n$HOME目录下的启动文件 交互式shell进程 非交互式shell 环境变量持久化\n最好不要修改/etc/profile文件，如果你升级了所用的发行版，这个文件也会跟着更新，你所定制的变量就没有了。最好是在/etc/profile.d目录中创建一个以.sh结尾的文件。把所有新的或修改过的全局环境变量设置放在这个文件中。\n数组变量 数组是能够存储多个值的变量。这些值可以单独引用，也可以作为整个数组来引用。要给某个环境变量设置多个值，可以把值 放在括号里，值 与值之间用空格分隔 \u0026gt; mytest=(one two three foru five) \u0026gt; \u0026gt; echo $mytest \u0026gt; \u0026gt; \u0026gt; one \u0026gt; \u0026gt; echo ${myest[2]} \u0026gt; \u0026gt; \u0026gt; three \u0026gt; \u0026gt; echo ${mytest[*]} \u0026gt; \u0026gt; \u0026gt; one two three four five \u0026gt; \u0026gt; myest[2] =seven \u0026gt; \u0026gt; echo ${mytest[*]} \u0026gt; \u0026gt; \u0026gt; one two seven four five \u0026gt; \u0026gt; unset mytest[2] \u0026gt; \u0026gt; echo ${mytest[*]} \u0026gt; \u0026gt; \u0026gt; one two four five \u0026gt; \u0026gt; echo ${mytest[2]} \u0026gt; \u0026gt; \u0026gt; \u0026gt; \u0026gt; echo ${mytest[3]} \u0026gt; \u0026gt; \u0026gt; four\n理解Linux文件权限 Linux的安全性 /etc/passwd文件\n此文件包含如下信息：\n登录用户名 用户密码（X） 用户账户的UID（数字形式） 用户账户的组ID（GID）（数字形式） 用户账户的文本描述（称为备注字段） 用户HOME目录的位置 用户的默认shell /etc/shadow文件\n此文件对Linux系统密码管理提供了更多的控制。只有root用户才能访问/etc/shadow文件它包含如下信息：\n与/etc/passwd文件中的登录名字段对应的登录名 加密后的密码 自上次修改密码后过去的天数密码（自1970年1月1日开始计算） 多少天后才能更改密码 多少天后必须更改密码 密码过期前提前多少天提醒用户更改密码 密码过期后多少天禁用用户账户 用户账户被禁用的日期（自1970年1月1日到当天的天数表示） 预留字段给将来使用 添加新用户\n用来向系统添加新用户的主要工具是useradd。这个命令可一次性创建新用户账户及设置用户HOME目录结构。 useradd命令使用系统的默认值 以及命令行参数来设置用户账户。系统默认值 被设置在/etc/default/useradd文件中。可以使用加入了-D选项的useradd命令查看所用Linux系统中的这些默认值 。在创建新用户时，如果你不在命令行中指定具体的值 ，useradd命令就会使用-D选项所显示的那些默认值。\n新用户会被添加 到GID为100的公共组 新用户的HOME目录将会位于/home/loginname 新用户账户密码在过期后不会被禁用 新用户账户未被设置过期日期 新用户账户将bash shell作为默认shell 系统会将/etc/skel目录下的内容复制到新用户的HOME目录下 系统为该 用户账户在mail目录下创建 一个用于接收邮件的文件 要想在创建用户时改变默认值或默认行为，可以使用命令行参数，常用的如下：\n参数 描述 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; -c comment 给新用户添加备注 -d home_dir 为主目录指定一个名字（如果不想用登录名作为主目录名的话） -e expire_date 用YYYY-MM-dd格式指定一个账户过期的日期 -f inactive_days 指定这个用户密码过期 后多少天这个账户被禁用；0表示密码一过期就立即禁用，1表示禁用这个功能 -g initial_group 指定用户登录组的GID或组名 -G goup \u0026hellip; 指定用户除登录组之外所属的一个或多个附加组 -k 必须和-m一起使用，将/etc/skel目录的内容复制到用户的HOME目录 -m 创建用户的HOME目录 -M 不创建用户的HOME目录（当默认设置里要求创建时才使用这个选项） -n 创建一个与用户登录名同名的新组 -r 创建系统账户 -p passwd 为用户账户指定默认密码 -s shell 指定默认的登录shell -u uid 为账户指定唯一 的UID 删除用户\nuserdel 默认userdel只会删除/etc/passwd文件中的用户信息，而不会删除系统中属于该 账户的任何文件。 -r： 会删除用户的HOME目录以及邮件目录。\n修改用户\n用户账户修改工具：\n命令 描述 \u0026mdash;\u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; usermod 修改用户账户的字段，还可以指定主要组以及附加组的所属关系 passwd 修改已有用户的密码 chpasswd 从文件中读取登录名密码对，并更新密码 chage 修改密码的过期日期 chfn 修改用户账户的备注信息 chsh 修改用户账户的默认登录shell usermod\n它能用来修改/etc/passwd文件中的大部分字段，参数大部分跟useradd命令的参数一样（比如，-c修改备注字段，-e修改过期日期，-g修改默认登录组）。另外还有一些\n-l修改用户账户的登录名 -L锁定账户，使用户无法登录 -p修改账户的密码 -U解除锁定，使用户能够登录 passwd和chpasswd\n如果只用passwd命令，它会改你自己的密码，系统上的任何用户都能修改自己的密码，但只有root用户才有权限修改别人的密码。 -e选项能强制用户下次登录时修改密码。如果需要为系统中大量用户修改密码，chpasswd命令可以事半功倍。chpasswd命令能从标准输入自动密码对（由冒号分割）列表，给密码加密，然后为用户账户设置。\nchsh、chfn和chage\n此三个工具专门用来修改特定的账户信息。 chsh用来修改默认的用户登录shell。使用时必须用shell的全路径名作为参数。 \u0026gt; chsh -s /bin/zsh username chfn命令提供了在/etc/passwd文件的备注字段中存储信息的标准方法。 chage命令用来帮助管理用户账户的有效期。你需要对每个值设置多个参数\n参数 描述 \u0026mdash;- \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; -d 设置上次修改密码到现在的天数 -E 设置密码过期的日期 -I 设置密码过期到锁定账户的天数 -m 设置悠 密码之间最少要多少天 -W 设置密码过期前多久天开始出现提醒信息 chage命令的日期值 可以用下面两咱方式的任意一种：\nYYYY-MM-DD格式的日期 代表从1970年1月1日到该 日期天数的数值 使用Linux组 /etc/group文件\n和UID一样，GID在分配 时也采用了特定的格式。系统账户用的组通常会分配低于500的GID值。而用户组的GID则会从500开始分配。 /etc/group文件有4个字段：\n组名 组密码 GID 属于该 组的用户列表 组密码允许非组内成功通过它临时成为该 组成员。\n创建新组\ngroupadd命令可以在系统上创建新组\n修改组\n组需要修改的信息不多。groupmod命令可以修改已有组的GID（加-g选项）或组名（加-n选项）\n理解文件权限 使用文件权限符\nls可以用来查看Linux系统上的文件，目录和设备的权限输出的第一个字段就是描述文件和目录权限的编码。\n-代表文件 d代表目录 l代表链接 c代表字符型设备 b代表块设备 n代表网络设备 之后有3组三字符的编码。每一组定义了3种访问权限：\nr代表对象是可读的 w代表对象是可写的 x代表对象是可执行的 若没有某种权限，在该权限位会出现单破折线。这三组权限分别对应3个安全级别\n对象的属主的权限 对象的属组的权限 系统其它用户的权限 默认文件权限\n**umask**命令用来设置所创建文件和目录的默认权限。 umask是一个掩码。它会屏幕掉不想授予该 安全级别的权限。要把umask值从对象的全权限值 中减掉。对文件来说，全权限的值是777；而对目录来说，则是666。所以要看明白默认权限需要使用全权限减去umask的值 。\n改变安全性设置 改变权限\n\u0026gt; chmod options mode file chmod参数可以使用八进制模式或符号 模式进行安全性设置。 e.g. \u0026gt; chmod 760 newfile 另一种方式：符号模式 \u0026gt; ugoa +-= rwxXstugo\u0026hellip; 第一组字符定义了权限的作用对象：\nu代表用户 g代表组 o代表其它 a代表所有 第二组：\n+代表增加权限 -代表移除权限 =将权限设置成后面的值 第三组代表做得到设置对象上的权限。除rwx之外的意思\nX：如果对象是目录或者它已有执行权限，赋予执行权限 s： 运行时重新设置UID或GID t： 保留文件或目录 u： 将权限设置为跟属主一样 g： 将权限设置为跟属组一样 o：将权限设置为跟其他用户一样 改变所属关系\nchown \u0026gt; chown options owner [ .group] file\n共享文件 Linux每户上共享文件的方法是创建组。 Linux为每个文件和目录存储了3个额外的信息位\n设置用户ID(SUID): 当文件被用户使用时，程序会以文件属主的权限运行 设置组ID（SGID）：对文件来说，程序会以文件属组的权限运行；对目录来说，目录中创建的新文件会以目录的默认属组作为默认属组 粘着位：进程结束后文件还驻留（粘着）在内存中 要创建一个共享目录，使目录里的新文件都能沿用目录的属组，只需要将该目录的SGID位置位打开 \u0026gt; chmod g+s dirname\n管理文件系统 探索Linux文件系统 基本的Linux文件系统\next文件系统\nLinux最初采用的是一种简单的文件系统，它模仿了Unix的文件系统的功能。使用虚拟目录来操作硬件设备，在物理设备上按定长的块来存储数据。 ext文件系统采用名为索引节点的系统来丰放虚拟 目录中所存储文件的信息。索引 节点系统在每个物理设备中创建 一个单独的表来存储这些文件的信息。ext文件系统名称中的extended部分来自其跟踪的每个文件的额外数据，包括：\n文件名 文件大小 文件的属主 文件的属组 文件的访问权限 指向丰有文件数据的每个硬盘块的指针 Linux通过唯一数据（称作索引节点号）来引用索引节点表中的每个索引节点，这个值是创建文件时由文件系统分配 的。文件系统通过索引节点为号而不是文件全名及路径 来标识 文件。\next2文件系统\next2的索引节点表为文件添加了创建时间值，修改时间值 和最后访问时间值 来帮助系统管理员追踪文件的访问情况。ext2文件系统还将允许最大文件大小增加到了2TB（在ext2后期的版本中增加到了32TB）除了扩展索引节点表外，ext2文件系统还改变了文件在数据块中存储的方式。保存文件时，ext2文件系统通过按 组分配磁盘块来减轻碎片化。通过将数据块组组，文件系统在读取文件时不需要为数据块查找整个物理设备。\n日志文件系统\n日志文件系统为Linux系统增加了一层安全性。它不再使用之前先将数据写入存储设备再更新索引节点表的做法，而是先将文件的更改写入到临时文件（称作日志，journal)中。在数据成功写到存储设备和索引节点表之后，再删除对应的日志条目。 Linux中有3种广泛使用的日志方法：\n方法 描述 \u0026mdash;\u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; 数据模式 索引节点和文件都会被写入日志；丢失数据风险低，但性能差 有序模式 只有索引节点数据会被写入日志，但只有数据成功写入后才删除；在性能和安全性之间取得了良好的折中 回写模式 只有索引节点数据会被写入日志，但不控制文件数据何时写入；丢失数据风险高，但仍比不用日志好。 ext3文件系统\n默认情况下ext3采用了有充模式的日志功能。\next4文件系统\next3的基础上支持了数据加密，还支持区段的特性（区段在存储设备上按块分配空间，但在索引节点表中只保存块起始位置。） ext4还引入了块预分配技术。\nReiser文件系统 JFS文件系统 XFS文件系统 写时复制文件系统\ncopy-on-write\nZFS文件系统\nZFS是一个稳定 的文件系统，与Resier4，Btrfs和ext4势均力敌。它最大的弱项就是没有使用GPL许可。自2013年发起的OpenZFS项目有可能改变这种书面。但是，在获得GPL许可之前，ZFS有可能终无法成为Linux默认的文件系统。\nBtrf文件系统\n也被称为B树文件系统。特点：稳定性，易用性以及能够动态调整已挂载文件系统的大小。\n操作文件系统 创建分区\nfdisk工具来帮助管理安装在系统上的任何存储设备，但得具有Root权限。 fdisk主要命令\n命令 描述 \u0026mdash;- \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- a 设置活动分区标志 b 编辑BSD Unix系统用的磁盘标签 c 设置DOS兼容标志 d 删除分区 l 显示可用的分区类型 m 显示命令选项 n 添加一个新分区 o 创建DOS分区表 p 显示当前分区表 q 退出，不保存更改 s 为Sun Unix系统创建 t 修改分区的系统ID u 改变使用的存储单位 v 验证分区表 w 将分区表写入磁盘 x 高级功能 创建文件系统\n在将数据存储到分区之前，你必须用某种文件系统对其进行格式化，这样Linux才能使用它。每种文件系统类型都有自己的命令行程序来格式化分区。\n工具 用途 \u0026mdash;\u0026mdash;\u0026mdash;- \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; mkefs 创建一个ext文件系统 mke2fs 创建一个ext2文件系统 mkfs.ext3 创建一个ext3文件系统 mkfs.ext4 创建一个ext4文件系统 mkreiserfs 创建一个ReiserFS文件系统 jfs_mkfs 创建一个JFS文件系统 mkfs.xfs 创建一个XFS文件系统 mkfs.zfs 创建一个ZFS文件系统 mkfs.btrfs 创建一个Btrfs文件系统 文件系统的检查与修复\n\u0026gt; fsck options filesystem fsck能检查和修复大部分类型的Linux文件系统。文件系统可以通过设备名，在虚拟目录中的挂载点以及分配给文件系统的唯一UUID值来引用。 fsck的命令行选项：\n选项 描述 \u0026mdash;- \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- -a 如果检测到错误，自动复文件系统 -A 检查/etc/fstab文件中列出的所有文件系统 -C 给支持进度条功能的文件系统显示一个进度条 -N 不进行检查，只显示哪些检查会执行 -r 出现错误时提示 -R 使用-A选项时路过根文件系统 -s 检查多个文件系统时，依次进行检查 -t 指定要检查的文件系统类型 -T 启动时不显示头部信息 -V 在检查时产生详细输出 -y 检测到错误 时自动 修改文件系统 fsck只能在未挂载的文件系统上运行。对大多数文件系统来说，你只需要卸载文件系统来进行检查，检查完成 之后重新挂载就好了。但是因为根文件系统含有所有核心的Linux命令和日志文件，所以你无法在处理于运行状态的系统上卸载它。这时你可以使用Linux LiveCD。\n逻辑卷管理 如果用标准分区在硬盘 上创建了文件系统，为已有文件系统添加额外的空间多少是一种痛苦的体验。你只能在同一个物理硬盘的可用空间范围内调整分区大小。如果 硬盘上没有地方了，你就必须弄一个更大的硬盘，然后手动将已有的文件系统移动到新的硬盘上。这时候可以通过将另外一个硬盘 上的分区加入已有文件系统，动态地添加存储空间。Linux逻辑卷管理器（logical volumn manage LVM）软件下好可以用来做这个。\n逻辑卷管理布局\n逻辑卷管理的核心在于如何处理安装在系统上的硬盘 分区。在逻辑卷管理的世界里，硬盘 称作物理卷（physical volumn， PV）。每个物理卷都会映射到硬盘 上特定的物理分区。多个物理卷集中在一起可以形成一个卷组（volume group， VG)。逻辑卷管理系统将卷组视为一个物理硬盘，但事实 上卷组可能是由分布在多个物理硬盘 上的多个物理分区组成的。卷组提供了一个创建逻辑分区的平台，而这些逻辑分区则包含了文件系统整个结构中的最后一层是逻辑卷（logical volume，LV）逻辑卷为Linux提供了创建文件系统的分区环境，作用类似于到目前为止我们一直在探讨 的Linux中的物理硬盘分区。Linux系统将逻辑卷视为物理分区。\nLinux中的LVM\nLinux LVM有两个可用的版本： LVM1， LVM2\n快照\n最初的Linux LVM允许你在逻辑卷在线的状态 下将其复制到另一个设备。\n条带化\nLVM2提供，条带化，可跨多个物理硬盘创建逻辑卷。当LinuxLVM将文件写入逻辑卷时，文件中的数据块会被分散到多个硬盘上。每个后继数据块会被写到下一个硬盘上。条带化有助于提高硬盘性能。因为Linux可以将一个文件的多个数据块同时写入多个硬盘而无需等待单个硬盘移动读写磁头到多个不同位置。\n镜像\nLVM镜像是一个实时更新的逻辑卷的完整副本。\n使用Linux LVM\n定义物理卷创建过程的第一步就是将硬盘上的物理分区转换成Linux LVM使用的物理卷区段。在创建了基本的Linux分区后，你需要通过t命令改变分区的类型。 \u0026gt; fdisk /dev/sdX \u0026gt; \u0026gt; t \u0026gt; \u0026gt; 8e \u0026gt; \u0026gt; p \u0026gt; \u0026gt; w \u0026gt; \u0026gt; q 下一步是用分区来创建实际的物理卷。可以通过pvcreate命令 \u0026gt; sudo pvcreate /dev/sda1 如果你想查看创建进度的话，你可以使用pvdisplay命令来显示已创建的物理卷列表 \u0026gt; sudo pvdisplay /dev/sda1 创建卷组 vgcreate命令 \u0026gt; sudo vgcreate Vol1 /dev/sdb1 \u0026gt; \u0026gt; vgdisplay Vol1 创建逻辑卷 Linux系统使用逻辑卷来模拟物理分区，并在其中保存文件系统。Linux系统会像处理物理分区一个处理逻辑卷，允许你定义逻辑卷中的文件系统，然后将文件系统挂载到虚拟目录上。要创建逻辑卷，使用lvcreate命令，lvcreate命令的选项如下： 选项 长选项名 描述 \u0026mdash;- \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- -c \u0026ndash;chunksize 指定快照逻辑卷的单位大小 -C \u0026ndash;contiguous 设置或重置连续分配策略 -i \u0026ndash;stripes 指定条带数 -I \u0026ndash;stripesize 指定每个条带的大小 -l \u0026ndash;extents 指定分配给新逻辑卷的逻辑区段数，或者要用的逻辑区段的百分比 -L \u0026ndash;size 指定分配给新逻辑卷的硬盘大小 \u0026ndash;mirror 指定的次设备号 -m \u0026ndash;mirrors 创建逻辑卷镜像 -M \u0026ndash;persistent 让次设备号一直有效 -n \u0026ndash;name 指定新逻辑卷的名称 -p \u0026ndash;permission 为逻辑卷设置读/写权限 -r \u0026ndash;readahead 设置预读扇区数 -R \u0026ndash;regionsize 指定将镜像分成多大的区 -s snapshot 创建快照逻辑卷 -Z \u0026ndash;zero 将新逻辑卷的前1KB数据设置为零 e.g. \u0026gt; sudo lvcreate -l 100%FREE -n lvtest Vol1\n创建文件系统 \u0026gt; sudo mkfs.ext4 /dev/Vol1/lvtest 修改LVM Linux LVM常用命令 命令 功能 \u0026mdash;\u0026mdash;\u0026ndash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; vgchange 激活和禁用卷组 vgremove 删除卷组 vgextend 将物理卷加到卷组中 vgreduce 从卷组中删除物理卷 lvextend 增加逻辑卷的大小 lvreduce 减小逻辑卷的大小 安装软件程序 包管理基础 PMS（package Management System, PMS）会利用一个数据库来记录各种相关内容：\nLinux系统上已安装了什么软件包 每个包安装了什么文件 每个已安装软件包的版本 基于debian的系统 dpkg命令是Debian每户PMS的工具的核心。包含在这个PMS中的其他工具有：\napt-get apt-cache aptitude 使用apt管理软件包 基于Red Hat的系统 yum 从源码安装 使用编辑器 vim编辑器 nano编辑器 emacs编辑器 KDE系统编辑器 KWrite编辑器 Kate编辑器 GNOME编辑器 gedit Shell脚本编程基础 构建基本脚本 使用多个命令 shell脚本的关键在于输入多个命令并处理每个命令的结果，甚至需要将一个命令的传给另一个命令。shell可以让你将多个命令串起来，一次执行完成。如果两个命令一起运行，可以把它们放在同一行中，彼此间用分号隔开。\n创建shell脚本 在创建shell脚本文件时， 必须在文件的第一行指定要使用的shell，格式为： \u0026gt; #!/bin/bash shell除第一行外不会解释*开头的行\n显示消息 大多数shell命令都会产生自己的输出。这些输出会显示在脚本所运行的控制台显示器上。你可能想要添加自己的文本消息来告诉用户脚本 正在做什么。可以通过echo命令来实现这一点 \u0026gt; echo this is a message 默认情况下，不需要使用引号将要显示的文本字符串划定出来。但有时在字符串中出现引号的话就比较麻烦了。你需要使用另一种引号把字符串划定起来。如果想把文本字符和命令输出显示在同一行中，可以使用echo语句的-n参数。\n使用变量 环境变量\n在脚本中，你可以在环境变量前加上（\\(）来使用这些系统环境变量。但你如果想显示\\)，那么则需要在$前加一个\\\n用户变量\n除了环境变量，shell脚本还允许在脚本中定义和使用自己的变量。用户变量可以是任何由字母，数字，下划线组成的文本字符串，长度不超过20个。使用等号将值赋给用户变量。在变量，等号和值之间不能出现空格。 shel脚本会自动决定变量值的数据类型。在脚本 的整个生命周期里，shell脚本中定义的变量会一直保持着它们的值，但在shell脚本结束时会被删除掉。与系统变量类似，用户变量可通过美元符号引用。\n命令替换\nshell脚本中最有用的特性之一就是可以从命令输出中提取信息，并将其赋值给变量。把输出赋给变量后，就可以随意在脚本中使用了。这个特性在处理脚本数据时尤为方便。有两种方法可以将命令输出赋值给变量：\n反引号字符（`） $()格式 e.g. \u0026gt; testing=`date` \u0026gt; \u0026gt; testing-$(date)\n重定向输入和输出 输出重定向\n最基本的重定向将命令的输出发送到一个文件中。bash shell 用大于号（\u0026gt;）来完成这项功能。 \u0026gt; command \u0026gt; outputfile\n输入重定向\n输入重定向将谇折内容重定向到命令，而非将命令的输出重定向到文件。使用（\u0026lt;）符号： \u0026gt; command \u0026lt; inputfile e.g.\n$ wc \u0026lt; testfile 2\t11\t60 wc命令可以对数据文本进行计数。默认它会给出3个值：\n文本的行数 文本的词数 文本的字节数 内联输入重定向\n这种方法无需使用文件进行重定向，只需要在命令行中指定用于输入 重定向的数据就可以了。内联输入重定向符号是远于小号（\u0026lt;\u0026lt;）。除了这个符号，你必须指定一个文本标记来划分输入数据的开始和结尾。任何字符串都可以作为文本标记，但在数据的开始和结尾文本必须一致。 e.g.\n$ wc \u0026lt;\u0026lt; EOF \u0026gt; test one \u0026gt; test two \u0026gt; test three \u0026gt; EOF 管道 有时需要将一个命令的输出作为另一个命令的输入。可以使用重定向来实现，只是有些笨拙。可以使用管道操作符（|） \u0026gt; command1 | command2 管道操作符两边的命令会同时运行。在系统内部将它们连接起来。在第一个命令产生输出的同时，输出会被立即送给第二个命令。数据传输不会用到任何中间文件或缓冲。\n执行数学运算 在shell中执行数据运算比较麻烦，可以使用两种途径来进行\nexpr命令\ne.g. \u0026gt; $ expr 1 + 5 \u0026gt; \u0026gt; 6 expr命令的操作符\n操作符 描述 ARG1 单竖线 ARG2 如果ARG1妈不是null也不是零值，返回ARG1,否则返回ARG2 ARG1 \u0026amp; ARG2 如果没有参数是null或零值，返回ARG1， 否则返回0 ARG1 \u0026lt; ARG2 如果ARG1小于ARG2，返回1，否则 返回0 ARG1 \u0026lt;= ARG2 如果 ARG1小于或等于ARG2返回1，否则返回0 ARG1 = ARG2 如果ARG1等于ARG2 返回1，否则返回0 ARG1 != ARG2 如果ARG1不等于ARG2返回1，否则返回0 ARG1 \u0026gt;= ARG2 如果ARG1大于等于ARG2返回1，否则返回0 ARG1 \u0026gt; ARG2 如果ARG1大于ARG2返回1，否则返回0 ARG1 + ARG2 返回ARG1和ARG2的合 ARG1 - ARG2 返回ARG1各ARG2的算术运算差 ARG1 * ARG2 返回ARG1和ARG2的算术乘积 ARG1 /ARG2 返回ARG1和ARG2的算术商 ARG1 % ARG2 返回ARG1被ARG2除的算术余数 ARG1 : ARG2 如果REGEXP匹配到了STRING中的某个模式，返回该 模式匹配 match STRING REGEXP 如果REGEXP匹配到了STRING中的某个模式，返回该模式匹配 substr STRING POS LENGTH 返回起始位置为POS（从1开始计数），长度为THLENGH个字符的子字符串 index STRING CHARS 返回在STRING中找到CHARS字符串的位置；否则返回0 length STRING 返回字符串STRING的数值长度 + TOKEN 将TOKEN解释成字符串，即使是个关键字 (EXPRESSION) 返回EXPRESSION的值 尽管标准操作符在expr命令中工作得很好，但在脚本 或命令行上使用它们时仍有问题出现。许多expr命令的操作符在shell中另有含义（比如星号）。当它们出现在expr命令中时，会得到一些诡异的结果。要解决这样的问题，需要对那些容易被shell错误解释的字符，在它们传入expr命令之前进行转义。但是在shell中使用expr命令也同样复杂。\n使用方括号\n在bash中，在将一个数学运算结果赋给某个变量时，可以用美元符和方括号（$[ operation ]）将数学表达式围起来。\n浮点解决方案\n有几种解决方案能够克服bash中数学运算的整数限制。最常见的方案是用内建的bash计算器， 叫做bc.\nbc的基本用法\nbash计算器能够识别：\n数字（整数和浮点数） 变量（简单变量和数组） 注释（以*或c语言中的/* */开始的行） 表达式 编程语句（例如 if -then语句） 函数 在脚本中使用bc\n\u0026gt; variable=$(echo \u0026ldquo;options; expression\u0026rdquo; | bc) e.g.\n*！/bin/bash var1=$(echo \u0026quot;scale=4; 3.44 / 5\u0026quot; | bc) echo The answer is $var1 退出脚本 shell中运行的每个命令都使用退出状态码(exit status)告诉shell它已经运行完毕。退出状态码是一个0~255的整数值，在命令结束运行时由命令传给shell。可以捕获这个值 并在脚本中使用\n查看退出状态码\nLinux提供了一个专门的变量$?来保存上个已执行命令的退出状态码。按照惯例，一个成功结束的命令的退出状态码是0.如果一个命令结束时有错误，退出状态码就是一个正数值。有一些参考：\n状态码 描述 0 命令成功结束 1 一般性未知错误 2 不适合的shell命令 126 命令不可执行 127 没找到命令 128 无效的退出参数 128+x 与Linux信号x相关的严重错误 130 通过Ctrl + C终止的命令 255 正常范围之个的退出状态码 exit命令\n默认情况下，shell脚本会以脚本中最后一个命令的退出状态码退出。你可以改变这种默认行为，返回自己的退出状态码。exit命令允许你在脚本结束时指定一个退出状态码 e.g. \u0026gt; $ exit 5\n使用结构化命令 使用if-then语句 if command then commands fi if后面的那个命令执行成功，位于then部分的命令就会被执行。如果该命令的退出状态码是苊值。then部分的命令就不会被执行。\nif-then-else语句\nif command then commands else commands fi 嵌套if if command1 then commands elif command2 then more commands fi test命令 \u0026gt; test condition\n数值比较\ntest命令的数值比较功能\n比较 描述 n1 -eq n2 检查n1是否与n2相等 n1 -ge n2 检查n1是否大于或等于n2 n1 -gt n2 检查n1是否大于n2 n1 -le n2 检查n1是否小于或等于n2 n1 -lt n2 检查n1是否小于n2 n1 -ne n2 检查n1是否不等于n2 e.g.\nvalue = 6 if [ $value -gt 5 ] then echo \u0026quot;The test value $value is greater than five\u0026quot; fi 字符串比较\n条件测试还允许比较字符串值。比较字符串比较烦琐，常用测试：\n比较 描述 str1 = str2 检查str1是否和str2相同 str1 != str2 检查str1是否和str2不同 str1 \u0026lt; str2 检查str1是否比str2小 str1 \u0026gt; str2 检查str1是否比str2大 -n str1 检查str1的长度是否非0 -z str1 检查str1的长度是否为0 字符串相等性\n在比较字符串的相等性时，比较测试会将所有的标点和大小写情况都考虑在内。\n字符串顺序\n问题：\n大于号和小于号必须转义，否则shell会把它们当作重定向符号，把字符串值当作文件名； 大于和小于顺序和sort命令所采用的不同：在比较测试中，大写字母被认为是小于小写字母的。但sort命令却恰好相反。原因是比较测试中使用的是标准的ASCII顺序，根据每个字符的ASCII数值来决定排序结果，sort命令使用的是系统本地化语言设置中定义的排序顺序。 字符串大小\n-n 和 -z可以检查一个变量是否含有数据\n文件比较\ntest命令的文件比较功能：\n比较 描述 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; -d file 检查目标是否存在并是一个目录 -e file 检查目标是否存在 -f file 检查是否存在并是一个文件 -r file 检查目标是否存在并可读 -s file 检查目标是否存在并非空 -w file 检查目标是否存在并可写 -x file 检查目标是否存在并可执行 -O file 检查目标是否存在 并属于当前用户 -G file 检查目标是否存在并默认组与当前用户相同 file1 -nt file2 检查file1是否比file2更新 file1 -ot file2 检查file1是否比file2旧 复合条件测试 if-then语句允许你使用布尔值逻辑来组合测试。有两种布尔值值运算符可用：\n[ condition1 ] \u0026amp;\u0026amp; [ condition2 ] 两种条件必须完全满足 [ condition1 ] || [ condition2 ] 两种条件只需满足一种 if-then的高级特性 用于数学表达式的双括号 用于高级字符串处理功能的双方括号 使用双括号\n双括号命令允许你在比较过程中使用高级数学表达式。test命令只能大比较中使用简单的算术操作。双括号命令提供了更多 多的数学符号，这些符号对于用过其他编程语言的程序员而言并不陌生，格式如下： \u0026gt; (( expression )) 双括号命令符号：\n符号 描述 val++ 后增 val\u0026ndash; 后减 ++val 先增 \u0026ndash;val 先减 感叹号 c逻辑求反 ~ 位求反 ** 幂运算 \u0026lt;\u0026lt; 左位移 \u0026gt;\u0026gt; 右位移 \u0026amp; 位布尔和 单竖线 位布尔或 \u0026amp;\u0026amp; 逻辑和 双竖线 逻辑或 使用双方括号 双方括号提供了针对字符串比较的高级特性双方括号里的expression使用了test命令中采用的标准字符串比较。但它提供了test命令未提供的另一个特性——模式匹配（pattern matching）. 在模式匹配中，可以定义一个正则表达式来匹配字符串的值 e.g.\n#!/bin/bash if [[ $USER == R* ]] then echo \u0026quot;Hello $USER\u0026quot; else echo \u0026quot;Sorry, I don't know you\u0026quot; fi case命令 有了case命令，就不需要再写出所有的elif语句来不停地检查同一个变量的值了。格式如下： \u0026gt; case variable in \u0026gt; \u0026gt; pattern1 | pattern2) commands1;; \u0026gt; \u0026gt; parrtern3) commands2;; \u0026gt; \u0026gt; *) default commands;; \u0026gt; \u0026gt; esac\n更多结构化命令 for命令 for命令允许你创建一个遍历一系统值 的循环。基本格式： \u0026gt;for var in list \u0026gt; \u0026gt;do \u0026gt; \u0026gt;​\tcommands \u0026gt; \u0026gt;done\n读取列表中的值\ne.g.\nfor test in Alabama Alaska Arizona Arkansas do echo \u0026quot;The next state is $test\u0026quot; done 读取列表中的复杂值\ne.g.\nfor test in I don't know if this'll work do echo \u0026quot;word:$test\u0026quot; done --- word:I word:dont know if thisll word:work shell看到了列表值中的单引号并尝试使用它们来定义一个单独的数据值。有两种办法解决这个问题：\n使用转义字符来将单引号转义 使用双引号来定义用到单引号的值 从变量读取列表 从命令读取值\ne.g.\n#!/bin/bash file = \u0026quot;states\u0026quot; for state in $(cat $file) do echo \u0026quot;Visit beautiful $state\u0026quot; done 更改字段分隔符\n造成这个问题的原因是特殊的环境变量IFS， 叫作内部字段分隔符（internal field separator）.IFS环境变量定义了bash shell用作字符分隔符的一系列字符。默认情况下，bash shell会将下列字符当作字段分隔符。\n空格 制表符 换行符 如果bash shell在数据中看到了这些字符中的任意一个，它就会假定这表明列表 中一个新数据字段的开始。在处理可能含有空格的数据（比如文件名）时，这空运 非常麻烦。要解决这个问题，可以在shell脚本中临时更改IFS环境变量的值来限制被bash shell当作字段分隔符的字符。 \u0026gt; IFS=$\u0026quot;\\n\u0026quot; 将这个语句加入到脚本中，告诉bash shell在数据值中忽略空格和制表符。\n用通配符读取目录\n最后，可以用for命令来自动遍历目录中的文件。进行操作时，必须在文件名或路径名中使用通配符。它会强制shell使用文件扩展配置。文件扩展匹配是生成匹配指定通配符的文件名或路径名的过程。\n#!/bin/bash for file in /home/* do if [ -d '$file' ] then echo \u0026quot;$file is a directory\u0026quot; elif [ -f \u0026quot;$file\u0026quot; ] then echo \u0026quot;$file is a file\u0026quot; fi done C语言风格的for命令\nfor (( variable assignment ; condition ; iteration process)) for (( a = 1; a \u0026lt; 10; a++)) 注意：\n变量赋值可以有空格； 条件中的变量不以美元符开头 迭代过程的算式未用expr命令格式 使用多个变量\nC语言风格的for命令也允许为迭代使用多个变量。循环会单独处理每个变量，你可以为每个变量定义不同的迭代过程。尽管可以使用多个变量，但你只能在for循环中定义一种条件。\nfor (( a = 1, b = 10; a \u0026lt;-10; a++, b--)) while命令 while命令某种单方上是if-then语句和for循环的混杂体。格式如下：\nwhile test command do other commands done while命令定义了每次迭代时检查的测试条件成立性。\n使用多个测试命令\nwhile命令允许你在while语句行定义多个测试命令。只有最后一个测试命令的退出状态 码会被用来决定什么时候结束循环。\nutil命令 util命令和while命令工作的方式完全相反。util命令要求你指定一个通常返回非零退出状态码的测试命令。只有测试命令的退出状态码不为0，bash shell才会执行循环中列出的命令。一量测试命令返回了退出状态码0，循环就结束了。\nuntil test commands do other commands done 和while类似，你可以在util命令语句中放入多个测试命令。只有最后一个命令的退出状态码决定了bash shell是否执行已定义的other comands。\n嵌套循环 循环语句可以在循环内使用任意类型的命令，包括其他循环命令。这种循环叫做嵌套循环。\n循环处理文件数据 通常必须遍历存储在文件中的数据。这要求结合已经进过的两种技术：\n使用嵌套循环 修改IFS环境变量 典型的例子就是处理/etc/passwd文件中的数据。这要求你逐行遍历/etc/passwd文件。并将IFS变量的值改成冒号，这样就能分隔开每行中的各个字段值了。\n#!/bin/bash change this IFS Value IFS.OLD = $IFS IFS=$'\\n' for entry in $(cat /etc/passwd) do echo \u0026quot;Values in $entry -\u0026quot; IFS=: for value in $entry do echo \u0026quot;\t$value\u0026quot; done done 控制循环 如果不能控制循环，那么一旦启动了循环，就必须等待循环完成所有迭代才会停止。有两个命令能帮助我们控制循环内部的情况：\nbreak continue break命令\nbreak命令是退出循环的一个简单方法。可以使用break命令来退出任意类型的循环。\n单层循环 内部循环 外部循环语法： break n *其中n指定了要跳出的循环层级。默认情况下n为1，表明跳出的是当前的循环。如果你将n设为2，break命令会停止下一级的外部循环。 continue\ncontinue命令可以提前中止某次循环中的命令，但并不会完全终止整个循环。\n处理循环的输出 在shell脚本中你可以对循环的输出使用管道或进行重定向。这可以通过在done命令之后添加一个处理命令来实现\nfor file in /home/rich/* do if [ -d \u0026quot;$file\u0026quot;] then echo \u0026quot;$file is a directory\u0026quot; elif echo \u0026quot;$file is a file\u0026quot; fi done \u0026gt; output.txt 处理用户输入 命令行参数 向shell脚本传递数据的最基本方法是使用命令行参数。命令行参数允许在运行脚本时向命令行添加数据。 e.g.\n$ ./addem 10 30 读取参数\nbash shell会将一些称为位置参数的特殊变量分配 给输入到命令行中的所有参数。这也包括shell所执行的脚本名称。公交车参数变量是标准的数字：\n$0: 程序名 $1: 第一个参数 $2: 第二个参数 \u0026hellip; 直到第九个参数$9 如果脚本需要的命令行参数不止9个，你仍然可以处理，但是需要稍微修改一下变量名。在第9个变量之后，你必须在变量数字周围加上花括号，比如${10}。\n读取脚本名\n使用$0参数获取shell在命令行启动的脚本名。当传给$0变量的实际字符串不仅仅是脚本名，而是完整的脚本路径时，变量$0变会使用整个路径。 e.g.\n$ bash /home/Christine/test.sh The zero paramter is set to ： /home/Christine/test.sh 测试参数\n当脚本认为参数变量中会有数据而实际上并没有时，脚本很有可能会产生错误消息。这种写脚本的方法并不可取。在使用参数前一定要检查其中是否存在数据。 e.g.\n#!/bin/bash if [ -n \u0026quot;$1\u0026quot; ] then echo Hello $1. else echo \u0026quot;Sorry, you did not identify yourself\u0026quot; fi 我们可以使用-n测试来检测命令行参数$1中是否有数据。\n特殊参数变量 参数统计\n特殊变量$*含有脚本运行时携带的命令行参数的个数。可以在脚本中任何地方使用这个特殊变量。\n抓取所有的数据\n\\(*和\\)@变量可以用来轻松访问所有参数。 $\\*变量会将命令行上提供的所有参数当作一个单词保存。这个单词包含了命令行中出现的每一个参数值，基本上\\(\\*变量会将这些参数视为一个整体，而不是多个个体。而\\)@变量会将命令行上提供的所有参数当作同一字符串中的多个独立的单词。这样就能够遍历所有的参数值，得到每个参数了。\n移动变量 bash shell工具箱中另一件工具是shift命令。它能够用来操作命令行参数。shift命令会根据它们的相对位置来移动命令行参数。在默认情况下，它会将每个参数变量向左移动一个位置。所以变量$3的值会移到$2， 变量$2的值会移到$1， 而变量$1的值则会被删除。而$0的值则不会变。\n处理选项 查找选项\n命令行选项(是跟在单破折线后面的单个字母，它能改变命令的行为)，可以像处理命令行参数一样处理命令行选项。\n处理简单选项你可以使用处理脚本 程序携带的命令行参数一样处理命令行选项。如在提取每个单独参数时，使用case语句来判断某个参数是否为选项。 分离参数和选项 shell中会有同时使用选项和参数的情况。Linux中处理这个问题的标准方式是用特殊字符来将二者分开。如\u0026ndash; 处理带值的选项 使用getopt命令\ngetopt命令是一个在处理命令行选项和参数时非常方便的工具。它能够识别命令行参数。\n命令的格式 getopt命令可以接受一系列任意形式的命令行选项和参数，并自动将它们转换成适当 的格式。命令格式如下: \u0026gt; getopt optstring parameters 在脚本中使用getopt \u0026gt; set \u0026ndash; \\((getopt -q ab:cd \u0026ldquo;\\)@\u0026rdquo;) getopt命令并不擅长处理带空格和引号的参数值。它会将空格当用参数分隔符，而不是根据双引号将二者当作一个参数。\n使用更高级的getopts\ngetopts内建于bash shell。 它跟近亲getopt看起来很像，但多了一些扩展功能。与getopt不同，前者将命令行上选项和参数处理后只生成一个输出，而getopts命令能够和已有的shell参数变量配合默契。每次调用 它时，它一次只处理命令行上检测到的一个参数。处理完所有的参数后，它会退出并个大于0的退出状态码。这让它非常适合解析命令行所有的参数的循环中。 getopts后面的字符串就是可以使用的选项列表，每个字母代表一个选项，后面带：意味着选项除了定义本身之外，还会带上一个参数作为选项的值，getopts字符串中没有跟随：的是开关型选项，不需要再指定值，相当于true/false，只要事字这个参数就是true。如果命令行中包含了没有在getopts列表中的选项，会有警告信息，如果在整个getopts字符串加上一个：，就能消除警告信息了。格式如下： \u0026gt; gettopts [optstring[:]] [descrition] variable\noptstring: 表示为某个脚本可以使用的选项 “：”： 如果某个选项（optstring）后面出现了冒号，则表示这个选项后面可以接参数（即一段描述信息description） variable： 表示将某个选项保存在变量variable中 getopts会用到两个环境变量。如果需要跟一个参数值，OPTARG环境变量就会保存这个值。OPTIND环境变量保存了参数列表中getopts正在处理的参数位置。这样你就能在处理完选项这后继续处理其他命令行参数了。\nOPTARG： 就是将选项后面的参数或者描述信息保存在这个变量中 OPTIND：这个表示命令行的下一个选项或参数的索引（文件名不算选项或参数）。 e.g.\n#!/bin/bash echo $* while getopts \u0026quot;:a:bc:\u0026quot; opt do case $opt in a) echo $OPTARG $OPTIND;; b) echo \u0026quot;b $OPTIND\u0026quot;;; c) echo \u0026quot;c $OPTIND\u0026quot;;; ?) echo \u0026quot;error\u0026quot; exiit 1;; esac done echo $OPTIND shift $(( $OPTIND -)) echo $0 echo $* 执行结果如下： \u0026gt; * sh getopts.sh -a 11 -b -c 6 -a 11 -b -c 6 11 3 b 4 c 6 6 getopts.sh 解释：\nwhile getopts “\u0026#x1f170;\u0026#xfe0f;bc:\u0026quot; opt * 第一个冒号表示忽略错误；字符后面的冒号表示该 选项必须有自己的参数。 $OPTARG 存储相应选项的参数，如上例中的11， 6 OPTIND总是存储原始$*中下一个要处理的选项（不是参数，而是选项，此处指的是a,b,c这三个选项，而不是那些数字，当然数字也是会占有位置的）的位置。 getopts与getopt的区别\ngetopts是shell内建的命令，getopt是一个独立外部工具 getopts的使用语法简单，而getopt使用语法较为复杂 getopts不支持长参数，getopt支持 getopts不会重排所有参数的顺序，而getopt会 getopts出现的目的是为了代替getopt较快捷的执行参数分析工作 将选项标准化 在创建shell脚本时，你完全可以决定用哪些字母选项以及它们的用法。但有些字母选项在Linux世界里已经拥有了某种程度的标准含义。如果你能在shell脚本中支持这些选项，脚本看起来能更友好一些。下面显示了Linux中用到的一些命令行选项有常用含义：\n选项 描述 -a 显示所有对象 -c 生成一个计数 -d 指定一个目录 -e 扩展一个对象 -f 指定读入数据的文件 -h 显示命令的帮助信息 -i 忽略文本大小写 -l 产生输出的长格式版本 -n 使用非交互模式 -o 将所有输出重定向到指定的输出文件 -q 以安静模式运行 -r 递归地处理目录和文件 -s 以安静模式运行 -v 生成详细输出 -x 排除某个对象 -y 对所有问题回答yes 获得用户输入 比如你想要在脚本 运行时问个问题，等待运行脚本 的人来回答。bash shell为此提供了read命令。\n基本的读取\nread命令从标准输入（通常是键盘）或另一个文件描述符中接受输入。在收到输入后，read命令会将数据放进一个变量。 e.g.\n#!/bin/bash *testing the read commannd echo -n \u0026quot;Enter you name: \u0026quot; read name echo \u0026quot;Hello $name, welcome to my program.\u0026quot; \u0026gt; ./test.shh Enter you name: Rich hello Rich, welcome to my proogram. 注意，生成提示的echo命令使用了-n选项，该 选项不会在字符串末尾输出换行符。实际上read命令包含了-p选项，允许你直接在read命令行指定提示符。 \u0026gt; read -p \u0026ldquo;Please enter you age: \u0026quot; age\n超时\n使用read命令时要当心，脚本很可能会一直等待用户输入。如果不管是否有数据输入，脚本都必须执行，你可以使用-t选项指定一个计时器。-t选项指定了read命令的等待输入的秒数。当计时器过期后，read命令会返回一个非零的退出状态码。\n隐藏方式读取\n有时你需要脚本从用户处得到输入，但又不在屏幕上显示输入信息，比如输入密码。你可以使用-s选项。（其实-s选项只是将文本颜色设置成 跟背景色一样）\n从文件中读取\n最后，也可以用read命令来读取Linux系统上文件里保存的数据。每次调用read都会从文件中读取一行文本。当文件中没有内容时，read命令会退出并返回非零状态码。其中最难的部分是将文件中的数据传给read命令，最常用的方法是对文件使用cat，将结果通过管理直接传给含有read命令的while命令。 e.g.\n#!/bin/bash reading data from a file count=1 cat test | while read line do echo \u0026quot;Line number: $line\u0026quot; count=$[ $count + 1] done echo \u0026quot;Finished processing thhe file\u0026quot; while循环会持续通过read命令处理文件中的行，直到read命令以非零退出状态码退出。\n呈现数据 理解输入和输出 标准文件描述符\nLinux将每个对象当作文件来处理。这包括输入和输出进程。Linux用文件描述符来标识每个文件对象。文件描述符是一个非负整数，可以唯一标识会话中打开的文件。每个进程一次最多可以有九个文件描述符。出于特殊目的，bash shell保留了前三个谁的描述符（0， 1， 2） Linux的标准文件描述符：\n文件描述符 缩写 描述 0 STDIN 标准输入 1 STDOUT 标准输出 2 STDERR 标准错误 STDIN STDIN文件描述符代表shell的标准输入。对终端来说，标准输入就是键盘。在使用输入重定向符号（\u0026lt;）时，Linux会重定向指定的文件来替换标准输入文件描述符。它会读取文件并提取数据，就如同它是键盘上的键入一样。\nSTDOUT STDOUT文件描述符代表shell的标准输出。在终端界面上，标准输出就是终端显示器。shell的所有输出（包括shell中运行的程序脚本）会被定向到标准输出，也就是显示器。你也可以使用输出重定向来改变（\u0026gt;）\nSTDERR shell通过特殊的STDERR文件描述符来处理错误消息。STDERR文件描述符代表shell的标准错误输出。默认，错误消息也会输出到显示器输出中。但STDERR并不会随着STDOUT的重定向而发生改变。\n重定向错误\n只重写向错误 \u0026gt; ls -all badfile 2\u0026gt; errorMsg 使用2\u0026gt;可以将错误重定向到指定文件或其它位置，这样，错误消息就不会出现在屏幕上了。\n重定向错误和数据 如果想重定向错误和正常输出，必须用两个重定向符号。需要在符号前面放上待重定向数据所对应的文件描述符，然后指向用于保存数据的输出文件。 \u0026gt; ls -all testt test2 badfiile 2\u0026gt; faiiMsg 1\u0026gt; msg\nw全部重定向 \u0026gt; ls -lah fiile badfile \u0026amp;\u0026gt; alllMsg\n在脚本中重定向输出 有两种方法在脚本中重定向输出：\n临时重定向行输出 永久重定向脚本中的所有命令 临时重定向\n如果有意思在脚本中生成错误消息，可以将单独的一行输出重定向到STDERR。你所需要做的是使用输出重定向符来将输出信息重定向到STDERR文件描述符。在重定向到文件描述符时，你必须在文件描述符数字之前加一个\u0026amp; \u0026gt; echo \u0026ldquo;This is an error messagge \u0026quot; \u0026gt;\u0026amp;2 如果像平时一样运行这个脚本，不会发生任何改变，因为默认情况下，Linux会将STDERR导向STDOUT。但是，如果你在运行脚本时重定向了STDERR，脚本中所有导向STDERR的文本都会被重定向。\n永久重定向\n可以使用exec命令告诉shell在脚本执行期间重定向某个特定文件描述符。 \u0026gt; exec 1\u0026gt; msg exec命令会启动一个新shell并将STDOUT文件描述符重定向到文件。脚本中发给STDOUT的所有输出都会被重定向到文件msg\n在脚本中重定向输入 exec命令允许你将STDIN重定向到Linux系统的文件中： \u0026gt; exec 0\u0026lt; testfile 这个命令会告诉shell它应该从文件testfile中获得输入，而不是STDIN。这个重定向只要在脚本需要输入时就会作用。\n创建自己的重定向 创建输出文件描述符\n可以使用exec命令来给输出分配文件描述符。和标准的文件描述符一样，一旦将另一个文件描述分配给一个文件，这个重定向就会有一直有效，直到你重新分配。 e.g.\n#!/bin/bashh *usiing an alternative fiile descriptor exec 3\u0026gt; test3out echo \u0026quot;This should diispplay on the monitor\u0026quot; echo \u0026quot;and thhis shhould be shtoored in the file\u0026quot; \u0026gt;\u0026amp;3 echo \u0026quot;Then thhiis should be bac on thhe montoor\u0026quot; \u0026gt; $ ./test This shhould display on thhe montor Thhis thhiis shhould be back on thhe montoor \u0026gt; cat test3out and this should be stored in the file 这个脚本用exec命令将文件描述符3重定向到另一个文件。\n重定向文件描述符\n你可以分配另外一个文件描述符给标准文件描述符，反之亦然。这意味着你可以将STDOUT的原来位置重定向到另一个文件描述符，然后再利用该文件描述符重定向回STDOUT。 e.g.\n#!/bin/bash *sttoring STDOUT, thhen cooming back to it exec 3\u0026gt;\u0026amp;1 exec 1\u0026gt;test4out echo \u0026quot;This should store in the output file\u0026quot; eccho \u0026quot;allong with thhe line\u0026quot; exec 1\u0026gt;\u0026amp;3 echo \u0026quot;Now thiings should be back to normall\u0026quot; \u0026gt; .test Now thhings should be back too normal cat test4out This should store in thhe output fiile along with thhiie line\n创建输入文件描述符\n可以用和重定向输出文件描述符同样的办法重定向输入文件描述符。在重定向到文件之前，先将STDIN文件描述符保存到另外一个文件描述符，然后在读取完文件之后再将STDIN恢复到它原来的位置。 e.g.\n#!/bin/bash *redirecting input file descriiptors exec 6\u0026lt;\u0026amp;0 exec 0\u0026lt;testfile count=1 while read line do echo \u0026quot;Line *$count: $line\u0026quot; count=$[ $count + 1] done exec 0\u0026lt;\u0026amp;6 read -p \u0026quot;Are you done now?\u0026quot; answer case $annswer in Y|y) echo \u0026quot;Goodbye\u0026quot;;; N|n) echo \u0026quot;Sorry, thhis is the end.\u0026quot;;; esac#+end_src 创建读写文件描述符\n\u0026gt; exec 3\u0026lt;\u0026gt; testfile\n关闭文件描述符\nshell会在脚本退出时自动关闭你创建的新输入或输出文件描述符。然而在有些情况下，你需要在脚本结束前手动关闭文件描述符。需要将它重定向特殊符号\u0026amp;-. \u0026gt; exec 3\u0026gt;\u0026amp;-\n列出打开的文件描述符 lsof命令会列出整个Linux系统打开的所有文件描述符。常用参数\n-p ：允许指定PID -d： 允许指定要显示的文件描述符编号 要想知道进程当前的PID，可以用特殊变量\\[(shell会将它设为当前PID)。-a选项来对其他两个选项的结果执行布尔And运算，e.g.\n/usr/sbin/lsof -a -p \\] -d 0,1,2 lsof默认有7列信息，如下：\n列 描述 COMMAND 正在运行的命令名的前9个字符 PID 进程的PID USER 进程属主的登录名 FD 文件描述符号以及访问类型（r代表读，w代表写，u代表读写） TYPE 文件的类型（CHR代表字符型， BLK代表块型，DIR代表目录，REG代表常规文件 DEVICE 设备的设备号（主设备和从设备号） SIZE 如果有的话，表示文件的大小 NODE 本地文件的节点号 NAME 文件名 与STDIN， STDOUT，TDERR关联的文件类型是字符型。因为STDIN， STDOUT和STDERR文件描述符都指向终端，所以输出的名称就是终端的设备名。\n阻止命令输出 如果运行在后台的脚本出现错误消息，shell会通过电子邮件将它们发给进程的属主。这会很麻烦，尤其是当运行会生成很多烦琐的小错误的脚本时。要解决这个问题，可以将STDERR重定向到一个叫作null文件的特殊文件。相当于全部被丢掉了。 \u0026gt; ls -la \u0026gt; /dev/null\n创建临时文件 Linux系统有特殊的目录，专供临时文件使用。Linux使用/tmp目录来存放不需要永久保留的文件。大多数Linux发行版配置了系统在启动时自动删除/tmp目录的所有文件。\n创建本地临时文件\n默认情况下，mktemp会在本地目录中创建一个文件。要用mktemp命令在本地目录中创建一个临时文件，你只要指定一个文件名模板就行了。模板可以包含任意文本文件，在文件名末尾加上6个X就可以了。 mktemp命令会用6个字符码替换这6个X，从而保证文件在目录中的唯一性。 mktemp命令的输出正是它所创建的文件的名字。在脚本中使用mktemp命令时，可能要将文件名保存到变量中，这样就能在后面的脚本中引用了。 \u0026gt; tempfilename = $(mktemp testfile.XXXXXX)\n在/tmp目录创建临时文件\n-t选项会强制mktemp命令在临时目录来创建该文件。在用这个特性时，mktemp命令会返回用来创建临时文件的全路径，而不只是文件名。\n创建临时目录\n-d选项会告诉mktemp命令来创建一个临时目录而不是临时文件。\n记录消息 将输出同时发送到显示器和日志文件，这种做法有时候能够派上用场。你不用将输出重定向两次，只要用特殊的tee命令就行。 tee命令相当于管理的一个T型接口。它将从STDIN过来的数据同时发往两处。一处理是STDOUT，另一处是tee命令行所指定的文件名。 \u0026gt; date | tee testfile 默认情况下，tee命令会在每次使用时覆盖输出文件内容。如果你想将数据追加到文件中，必须用-a选项。 e.g. 例子是读取csv文件，然后创建Insert语句将数据插入MySQL数据库。\n#!/bin/bash # read file and create Insert statement for MySQL outfile='members.sql' IFS=',' while read lname fname address city state zip do cat \u0026gt;\u0026gt; $outfile \u0026lt;\u0026lt; EOF INSERT INTO MEMBERS(lname,fname, address, city, state, zip) values('$lname', '$fname', '$address', '$city', '$state', '$zip'); EOF done \u0026lt; ${1} 运行脚本： \u0026gt; test23 \u0026lt; members.csv\n控制脚本 处理信号 Linux利用信号与运行在系统中的进程进行通信。\n重温Linux信号\nLinux系统和应用程序可以生成超过30信号。如下列出了常用的。\n信号 值 描述 1 SIGHUP 挂起进程 2 SIGINT 终止进程 3 SIGQUIT 停止进程 9 SIGKILL 无条件终止进程 15 SIGTERM 尽可能终止进程 17 SIGSTOP 无条件停止进程，但不是终止进程 18 SIGTSTP 停止或暂停进程，但不终止进程 19 SIGCONT 继续运行停止的进程 默认情况下，bash shell会忽略收到的任何SIGQUIT（3）和SIGTERM（5）信号（正因为这样，交互式shell才不会被意外终止）。但是bash shell会处理收到的SIGHUP（1）和SIGINT（2）信号 。\n生成信号\nbash shell允许用键盘上的组合键生成两种基本的Linux信号。\n中断进程 Ctrl+C组合键会生成SIGINT信号，并将其发送给当前在shell中运行的所有进程。 Ctrl+C组合键会发送SIGINT信号，停止shell中当前运行的进程。\n暂停进程 你可以在进程运行期间暂停进程，而无需终止它。 Ctrl+Z组合键会生成一个SIGTSTP信号，停止shell中运行的任何进程。停止进程跟终止进程不同：停止进程会让程序继续保留在内存中，并能从上次停止的位置继续运行。可以使用ps命令来查看已停止的作业。\n捕获信号\n也可以不忽略信号，在信号出现时捕获它们并执行其他命令。trap命令允许你来指定shell脚本要监看并从shell中拦截的Linux信号。如果脚本收到了trap命令中列出的信号，该信号不再由shell处理，而是交由本地处理。命令格式： \u0026gt; trap commands signals 在trap命令行上，你只要列出想要shell执行的命令，以及一组用空格分开的待捕获的信号。你可以用数值或Linux信号名来指定信号。 e.g. 使用trap命令来忽略SIGINT信号，并控制脚本的行为\n#!/bin/bash # Testing signal trapping trap \u0026quot;echo 'sorry! I have trapped Ctrl-C'\u0026quot; SIGINT echo This is a test script count=1 while [ $count -le 10] do echho \u0026quot;Loop *$count\u0026quot; sleep 1 count=$[ $count + 1] done echo \u0026quot;This is thhe end of the test script\u0026quot;#+end_src 本例中用到的trap命令会在每次检测到SIGINT信号时显示一行简单的文本消息。捕获这些信号会阻止用户用bash shell组合键Ctrl+C来停止程序。每次使用Ctrl+C组合键，脚本都会执行trap命令中指定的echo语句，而不是处理该信号并允许shell停止该脚本。\n捕获脚本退出\n除了在shell脚本中捕获信号，你也可以在shell脚本退出时进行捕获。这是在shell完成任务时执行命令的一种简便方法。要捕获shell脚本的退出，只要在trap命令后加上EXIT信号 就行。\n修改或移除捕获\n想要在脚本 中的不同位置进行不同的捕获处理，只需要重新使用带有新选项的trap命令。修改了信号捕获之后，脚本处理信号的方式就会发生变化。但如果一个信号是在捕获被修改前接收到的，那么脚本仍然会根据最初的trap命令进行处理。也可以删除已设置好的捕获。只需要在trap命令与希望恢复默认行为的信号列表之间加上破折号（一个或两个都可以）就行了。\n以后台模式运行脚本 后台运行脚本\n以后台模式运行shell脚本只需要在命令后加个\u0026amp;符就行了。当\u0026amp;符放到命令后时，它会将命令和bash shell分离开来，将命令作为系统中的一个独立的后台进程运行。不过需要注意，当后台进程运行时，它仍然会使用终端显示器来显示STDOUT和STDERR消息。这样脚本的输出就会与shell提示符混杂在一起了。所以最好是将后台运行的脚本 的STDOUT和STDERR重定向。\n运行多个后台作业 在非控制台下运行脚本 有时你会想在终端会想在终端会话中启动shell脚本，然后让脚本一直在后台模式运行到结束，即使你退出了终端会话。这可以使用nohup命令来实现。 nohup命令运行了另外一个命令来阻断所有发送给该进程的SIGHUP信号。这会在退出终端会话时阻止进程退出。格式如下： \u0026gt; nohup testshell.sh \u0026amp; 由于nohup命令会解除终端与进程的关联，进程也就不再同STDOUT和STDERR联系在一起。为了保存该命令产生的输出，nohup命令会自动 将STDOUT和STDERR的消息重定向到一个名为nohup.out的文件中。\n作业控制 启动，停止，终止以及恢复作业的这些功能统称为作业控制。\n查看作业\n作业控制中的关键命令是jobs命令。jobs命令允许查看shell当前正在处理的作业。 脚本中使用$$变量来显示Linux系统分配给该脚本的PID。 jobs命令的常用参数：\n参数 描述 -l 列出进程的PID以及作业号 -n 只列出上次shell发出的通知后改变了状态的作业 -p 只列出作业的pid -r 只列出运行中的作业 -s 只列出已停止的作业 作业列表中带加号的作业会被当作默认作业。在使用作业控制命令时，如果示在命令行指定任何作业号，该 作业会被当成作业控制命令的操作对象。\n重启停止的作业\n要以后台模式重启一个作业，可用bg命令加上作业号。要以前台模式重启作业，可用带有作业号的fg命令。\n调整谦让度 在Linux系统中，由shell启动的所有进程的调试优先级默认都是相同的。调试优先级是个整数值，从-20（最高优先级）到+19（最低优先级）。默认情况下，bash shell以优先级0来启动所有进程。可以使用nice命令改变优先级\nnice命令\n在启动命令时只要用nice命令指定优先级别，就可以降低命令的优先级。 \u0026gt; nice -n 10 ./testshell.sh \u0026gt; out.out \u0026amp;\nrenice命令\n如需要改变已运行命令的优先级。renice可以允许你指定运行进程的PID来改变它的优先级。 \u0026gt; renice -n num -p pid 不过有一些限制：\n只能对属于你的进程执行renice 只能通过renice降低优先级 root用户可以通过renice来任意调整进程的优先级。 定时运行作业 Linux系统提供了多个在预选时间运行脚本的方法： at命令和cron表。\n用at命令来计划执行作业\nat命令允许指定Linux系统何时运行脚本。at命令会将作业提交到队列中，指定shell何时运行该作业。at的守护进程atd会双后台模式运行，检查作业队列来运行作业。大多数Linux发行版会在启动时运行此守护进程。 atd守护进程会检查系统上的一个特殊目录（var/spool/at）来获取用at命令提交的作业。默认情况下atd守护进程会每60秒检查一下这个目录。有作业时，atd守护进程会检查作业设置的运行时间。如果时间跟当前时间匹配，atd守护进程就会运行此作业。\nat命令的格式 \u0026gt; at [ -f filename] time 如果你指定的时间已经错过，at命令会在第二天的那个时间运行指定的作业。 at命令能识别多种不同的时间格式\n标准的小时和分钟格式，比如10：15 AM/PM指示符，比如10：15 PM 特定可命名时间，比如now, noon, midnight或者teatime(4 PM)。 除了指定运行作业的时间，也可以通过不同的日期格式指定特定的日期。\n标准日期格式，比如MMDDYY，MM/DD/YY或DD.MM.YY 文本日期，比如Jul 4或Dec 25，加不加年份均可。 你也可以指定时间增量 当前时间+25 min 明天10：15 PM 10：15 + 7天 在你使用at命令时，该 作业会被提交到作业队列。作业队列会保存通过at命令提交的待处理作业。针对不同优先级，存在 26种不同的作业队列。作业队列通常用小写字母a-z和大写字母A-Z来指代。作业队列的字母排序越高，作业运行的优先级主小老虎 低（更衰败的nice值）。默认情况下，at的作业会被提交到a作业队列。如果想以更高优先级运行作业，可以用-q参数指定不同的队列字母。\n获取作业的输出当作业在Linux系统上运行时，显示器并不会关联到该作业。取而代之的是，Linux系统会将提交该作业的用户的电子邮件地址作为STDOUT和STDERR 列出等待的作业 atq命令可以查看系统中有哪些作业在等待。 删除作业 atrm命令可以删除等待的作业 安排需要定期执行的脚本\ncron时间表 cron时间表采用一种特别的格式来指定作业何时运行。其格式如下： \u0026gt; min hour dayofmnthh month dayofweekk command\n构建cron时间表列出已的有时间表： \u0026gt; crontab -l 添加时间表： \u0026gt; crontab -e\n浏览目录如果你创建的脚本对精确的执行时间要求不高，用预配置的cron脚本目录会更方便。有4个基本目录：hourly, daily, monthly和weekly 在/etc/下。 anacron程序 cron程序 的唯一问题是它假定系统是7*24小时运行的。如果某个作业在cron时间表中安排运行的时间已到，但这个时间Linux系统系统处理于关机状态，那么这个作业就不会被执行。当系统开机时，cron程序不会再去运行那些错过的作业。要解决这个问题，许多Linux发行版还包含了anacron程序。如果anacron程序知道某个作业错过了执行时间，它会尽快运行该作业。这意味着Linux关机了几天，当它再次开机时，原定在关机期间运行的作业会自动 运行。 anacron程序使用自己的时间表（通常位于/etc/anacrontab）来检查作业目录。 anacron时间表的基本格式和cron时间表略有不同： \u0026gt; period delay identifier command\nperiod条目定义了作业多久运行一次，以天为单位。\ndelay条目会指定系统启动后anacron程序需要等待多少分钟再开始运行错过的脚本。 command条目包含了run-parts程序和一个cron脚本目录名。run-parts程序负责运行目录中传给它的任何脚本。 identifier条目是一种特别的非空字符串，如cron-weekly。它用于唯一标识日志消息和错误邮件中的作业。 高级Shell脚本编程 创建函数 基本的脚本函数 在开始编写较复杂的shell脚本时，你会发现自己毛毛虫使用了部分能够执行特定任务的代码。这些代码有时简单，比如显示一条文本消息，或者从脚本用户那里获得一个答案，有时则会比较复杂，需要作为大型处理过程中的一部分被多次使用。函数是一个脚本代码块，你可以为其命名并在代码中任意位置重用。要在脚本中使用该 代码，只要使用所起的函数名就行了（这个过程称为函数调用）。\n创建函数\n有两种格式可以用来在bash shell脚本 中创建函数。第一种格式采用function关键字，后跟分配该代码块的函数名。 \u0026gt; function funcname { commands } funcname属性定义了赋予函数的唯一名称。脚本中定义的每个函数都必须有一个唯一的名称。 commands是构成函数的一条或多条bash shell命令。第二种格式更接近于其他编程语言中定义函数的方式。 \u0026gt; funcname() { commands } 函数名后的空括号表明正在定义的是一个函数。这种格式的命名规则和之前定义shell脚本 函数的格式一样。\n使用函数\n要在脚本中使用函数，只需要像其他shell命令一样，在行中指定函数名就行了。\n返回值 bash shell会把函数当作一个小型脚本，运行结束时会返回一个退出状态码，有3种不同的方法来为函数生成退出码。\n默认退出状态码\n默认情况下，函数的退出状态码是函数中最后一条命令退出状态码。在函数执行结束后，可以用标准变量$?来确定函数的退出状态码。\n使用return命令\nbash shell使用return命令来退出函数并返回特定的退出状态码。return命令允许指定一个整数值来定义函数的退出状态码，从而提供了一种简单的途径来编程设定函数退出状态码。不过需要注意：\n函数一结束就取返回值 退出状态码必须是0-255 如果在用$?变量提取函数返回值 之前执行了其他命令，函数的返回值就会丢失。\n使用函数输出\n正如可以将命令的输出保存到shell变量中一样，你也可以对函数同样的处理办法。可以用这种技术来获得任何类型的函数输出，并将其保存到变量中。 \u0026gt; result=$(func)\n在函数中使用变量 在函数中使用变量时，你需要注意它们的定义方式以及处理方式。\n向函数传递参数\nbash shell会将函数当作小型脚本来对待。这意味着你可以像普通脚本那样向函数传递参数。函数可以使用参数环境变量来表示命令行上传给函数的参数。也可以用特殊变量$*来判断传给函数的参数数目。\n在函数中处理变量\n给shell脚本程序员带来麻烦的原因之一就是变量的作用域。作用域是变量可见的区域。函数中定义的变量与普通变量的作用域不同。也就是说，对脚本 的其他部分而言，它们是隐藏的。函数使用两种类型的变量：\n全局变量 局部变量 全局变量\n全局变量是在shell脚本中任何地方都有效的变量。如果你在脚本的记事本部分定义了一个全局变量。那么可以在函数内读取它的值。类似你在函数内定义了一个全局变量，可以在脚本的主体部分读取它的值。默认情况下，你在脚本中定义的任何变量都是全局变量。在函数外定义的变量可在函数内正常访问。如果变量在函数内被赋予了新值，那么在脚本中引用该变量时，新值也依然有效。\n局部变量\n函数内部使用的任何变量都可以被声明成局部变量。要实现这一点只要在变量声明前面加上local关键字就可以了 \u0026gt; local variable_name 你也可以在变量赋值语句中使用local关键字 \u0026gt; local variable_name=$[ $value + 5] local关键字保证了变量只局限在该函数中。如果脚本中在该函数之外有同样名字的变量，那么shell将会保持这两个变量的值是分离的。现在你就能很轻松地将函数变量和脚本变量隔离开了，只共享需要共享的变量。\n数组变量和函数 向函数传数组参数\n向脚本函数传递数组变量的方法会有点不好理解 。将数组变量当作单个参数传递的话，它不会起作用。如果你试图将数组变量作为函数参数，函数只会取数组变量的第一个值。要解决这个问题，你必须将该数组的值分解成单个的值，然后将这些值作为函数参数使用。\n从函数返回数组\n从函数里向shell脚本传回数组变量用类似的方法。函数用echo语句来按正确顺序输出单个数组值，然后脚本再将它们重新放进一个新的数组变量中。\n函数递归 局部函数变量的一个特性是自成体系。除了从脚本 命令行处获得的变量，自成体系的函数不需要使用任何外部资源。这个特性使得函数可以递归地调用，也就是说，函数可以调用 自己来得到结果。\n创建库 使用函数可以在脚本 中省去一些输入工作，但若需要在多个脚本 中使用同一段代码。我们就需要创建函数库文件。bash shell允许创建函数库文件，然后在多个脚本 中引用该库文件。格式： \u0026gt; . 库文件\n在命令行上使用函数 在命令行上创建函数\n因为shell会解释用户输入 的命令，所有可以在命令行上直接定义一个函数。有两种方法一种方法是采用行方式定义函数。当在命令行上定义函数时， 你必须记得在每个命令后面加个分号，这样shell就能知道 在哪里是命令的起止了。另一种方法是采用多行方式来定义函数。在定义时，bash会使用次提示符来提示输入更多命令。用这种方法， 你不用在每条命令的末尾放一个分号，只要按下回车键就行。在函数的尾部使用花括号，shell就会知道你已经完成了函数的定义。\n在.bashrc文件中定义函数\n直接定义函数 读取函数文件 图形化桌面环境中的编程脚本 创建文本菜单 shell脚本 菜单的核心是case命令。case命令会根据用户在菜单 上的选择来执行特定命令。\n创建菜单布局\n使用clear清屏 使用echo打印菜单项 使用read命令读取用户输入。 创建菜单函数\nshell脚本 菜单 选项作为一组独立 的函数实现起来更为容易。要做到这一点，你要为每个菜单 选项创建独立的shell函数。创建shell菜单 脚本 的第一步是决定你希望脚本执行哪些功能，然后将这些功能以函数的形式放在代码中。通常我们会为还没有实现的函数先创建一个桩函数（stud function）。桩函数是一个空函数或者只有一个echo语句，说明最终这里需要什么内容。这允许你的菜单在你实现某个函数时仍然能正常操作。\n添加菜单逻辑 整合shell脚本菜单\n#!/usr/bash # simple script menu function diskspace { clear df -k } function whoseon { clear } function memusage { cat /proc/meminfo } function menu { clear echo echo -e \u0026quot;\\t\\t\\tSys Admin Menu\\n\u0026quot; echo -e \u0026quot;\\t1. Display disk space\u0026quot; echo -e \u0026quot;\\t2. Display logged on users\u0026quot; echo -e \u0026quot;\\t3. Display memory usage\u0026quot; echo -e \u0026quot;\\t0. Exit program\\n\\n\u0026quot; echo -en \u0026quot;\\t\\tEnter option: \u0026quot; read -n 1 option } while [ 1 ] do menu case $option in 0) break ;; 1) diskspace ;; 2) whoseon ;; 3) memusage ;; *) clear echo \u0026quot;Sorry, wroong selectiion\u0026quot;;; esac echo -enn \u0026quot;\\n\\n\\t\\t\\tHit any key to coontinue\u0026quot; read -n 1 line done 使用select命令\nselect命令只需要一条命令就可以创建出菜单，然后获取输入的答案并自动处理。select命令的格式如下： list参数是由空格分隔的文本选项列表，这些列表构成了整个菜单。select命令会将每个列表项显示成一个带编号的选项，然后为选项显示一个由PS3环境变量定义的特殊提示符。 select var in list do done\n制作窗口 dialog包\ndialog命令使用命令行参数来决定生成哪种容器部件,部件是容器元素类型术语。dialog包现在运行如下部件类型：\n部件 描述 calendar 提供选择日期的日历 checklist 显示多个选项（其中每个选项都能打开或关闭） form 构建一个带有标签以及文本字段（可以赶写内容）的表彰 fselect 提供一个文件选择容器来浏览选择文件 gauge 显示完成的百分比进度条 infobox 显示一条消息，但不用等待回应 inputbox 提供一个输入文本用的文本表单 inputmenu 提供一个可编辑的菜单 menu 显示可选择的一系列选项 msgbox 显示一条消息，并要求用户选择OK按钮 pause 显示一个进度条来显示暂定期间的状态 passwordbox 显示一个文本框，但会隐藏输入的文本 passwordform 显示一个带标签和隐藏文本字段的表彰 radiolist 提供一组菜单 选项，但只能选择其中一个 tailbox 用tail命令在滚动容器中显示文件的内容 tailboxbg 跟tailbox一样，介是在中运行 textbox 在滚动容器中显示文件的内容 timebox 提供一个选择小时，分钟和秒数的容器 yesno 提供一条带有Yes和No按钮的简单消息 要在命令行上指定某个特定的部件，需要使用双破折线格式。dialog \u0026ndash;wiidgett parameters 其中widget是表中的部件名，parameters定义了部件容器的大小以及部件需要的文本每个dialog部件都提供了两种形式的输出：\n使用STDERR 使用退出状态码 可以通过dialog命令的退出状态码来确定用户选择的按钮。如果选择了Yes或OK按钮，dialog命令会返回退出状态码0.如果选择了Cancel或No按钮，dialog命令会返回退出状态码1.可以用标准$?变量来确定dialog部件中具体选择了哪个按钮。如果部件返回了数据，比如菜单选择，那么dialog命令会将数据发送到STDERR。可以用标准的bash shell方法来将STDERR输出重定向到另一个文件或文件描述符中。 e.g. $ dialog \u0026ndash;inputbox \u0026ldquo;Enter you age: \u0026quot; 10 20 2\u0026gt;age.txt 常用的dialog部件\nmsgbox部件 它会在窗口中显示一条简单的消息，直到用户单击OK按钮才消失 $dialog -msgboox text height width text参数是你想在容器中显示的字符串。如果你想在容器顶部放一个标题，也可以用\u0026ndash;title参数，后接作为标题的文本。 $ dialog \u0026ndash;title titleName \u0026ndash;msgbox \u0026ldquo;This is a msg\u0026rdquo; 10 20\nyesno部件 yesno部件进一步扩展了msgbox部件的功能，允许用户对容器中显示的问题选择yes或no。 $ dialog \u0026ndash;title \u0026ldquo;Please answer\u0026rdquo; \u0026ndash;yesno \u0026ldquo;Is this thhing on?\u0026rdquo; 10 20 echo $?\ninputbox部件 inputbox部件为用户提供了一个简单的文本框区域来输入文本字符串。dialog命令会将文本字符串的值发给STDERR。你必须重定向STDERR来获取用户输入。\ntextbox部件 textbox部件是在容器中显示大量信息的极佳办法。它会生成一个滚动容器来显示由参数所指定的文件中的文本。 \u0026gt;$ dialog \u0026ndash;textbox /etc/passwd 15 45\nmenu部件 menu部件允许你来创建我们之前所缺件的文本菜单的窗口版本。只要为每个选项提供一个选择标号和文本就行了。 $ dialog \u0026ndash;menu \u0026ldquo;Sys Admin mennu\u0026rdquo; 20 300 10 1 \u0026ldquo;Display diskk space\u0026rdquo; 2 \u0026ldquo;Display users\u0026rdquo; 3 \u0026ldquo;Display memory usage\u0026rdquo; 4 \u0026ldquo;Exit\u0026rdquo; 2\u0026gt;test.txt\nfselect部件 dialog选项\n除了标准部件，还要以在dialog命令中定制很多不同的选项。\n选项 描述 :\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; :\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; \u0026ndash;add-widget 继续下个对话框，直到按下Esc或Cancel按钮 \u0026ndash;aspect ratio 指定容器宽度和高度的宽高比 \u0026ndash;backtitle title 指定显示在屏幕顶部背景上的标题 \u0026ndash;begin x y 指定容器左上角的起始位置 \u0026ndash;cancel-label label 指定Cancel按钮的替代标签 \u0026ndash;clear 用默认的对话背景来清空屏幕内容 \u0026ndash;colors 在对话文本中嵌入ANSI色菜编码 \u0026ndash;cr-wrap 在对话文本中允许使用换行符并强制换行 \u0026ndash;create-rc file 将示例配置文件的内容复制到指定的file文件中 \u0026ndash;defaultno 将yes/no对话框的默认答案设为No \u0026ndash;default-item string 设定复选列表，表单或菜单 对话中的默认项 \u0026ndash;exit-label label 指定Exit按钮的替代标签 \u0026ndash;extra-buton 在OK按钮和Cancel按钮之间显示一个额外按钮 \u0026ndash;extra-label label 指定 额外按钮的替代标签 \u0026ndash;help 显示dialog命令的帮助信息 \u0026ndash;help-button 在OK按钮 和Cancel按钮后显示一个Help按钮 \u0026ndash;help-label label 指定Help按钮的替代标签 \u0026ndash;help-status 当选定Help按钮后，在帮助信息后写入多选列表，单选列表或表彰信息 \u0026ndash;ignore 忽略dialog不能识别的选项 \u0026ndash;input-fd fd 指定 STDIN之外的另一个文件描述符 \u0026ndash;insecure 在password部件 中键入内容时显示星号 \u0026ndash;item-help 为多选列表，单选列表或菜单中的每个标号在屏幕的底部添加一个帮助栏 \u0026ndash;keep-window 不要清除屏幕上显示过的部件 \u0026ndash;max-input size 指定输入的最大字符串长度。默认为2048 \u0026ndash;nocancel 隐藏Cancel按钮 \u0026ndash;no-collapse 不要将对话文本中的制表符转换成空格 \u0026ndash;no-kill 将tailboxbg对话放到后台，并禁止该进程的SIGHUP信号 \u0026ndash;no-label label 为No按钮指定替代标签 \u0026ndash;no-shadow 不要显示对话容器的阴影效果 \u0026ndash;ok-label label 指定OK按钮的替代标签 \u0026ndash;output-fd fd 指定除STDERR之外的另一个输出文件描述符 \u0026ndash;print-maxsize 将对话容器的最大尺寸打印到输出中 \u0026ndash;print-size 将每个对话容器的大小打印到输出中 \u0026ndash;separate-output 一次一行地输出checklist部件 的结果，不使用引号 \u0026ndash;separator string 指定 用于分隔部件输出的字符串 \u0026ndash;separate-widget string 指定用于分隔部件输出的字符串 \u0026ndash;shadow 在每个容器的右下角绘制阴影 \u0026ndash;single-quoted 需要时对多选列表的输出采用单引号 \u0026ndash;sleep sec 在处理完对话容器之后延迟指定的秒数 \u0026ndash;stderr 将输出发送到STDERR \u0026ndash;stdout 将输出发送到STDOUT \u0026ndash;tab-correct 将制表符转换成空格 \u0026ndash;tab-len n 指定一个制表符占用的空格数（默认为8） \u0026ndash;timeout sec 指定无用户输入 时，sec秒后退出并返回错误代码 \u0026ndash;title title 指定对话窗口的标题 \u0026ndash;trim 从对话文本中删除前导空格和换行符 \u0026ndash;visit-items 修改对话窗口中制表符停留位置，使其包括选项列表 \u0026ndash;yes-label label 为Yes按钮指定替代标签 在脚本中使用dialog命令\n在脚本中使用dialog需要注意：\n如果有cancel或No按钮，检查dialog命令的退出状态码 重定向STDERR来获得输出值 使用图形 KDE环境\nKDE图形化环境默认包含kdialog包\nGNOME环境\nGNOME图形化环境支持两种流行的可生成标准容器的包：\ngdialog zenity 初识sed和gawk 文本处理 sed编辑器\nsed编辑器被称作流编辑器(stream editor)，和普通的交互式文本编辑器恰好相反。 sed编辑器可以根据命令来处理数据流中的数据，这些命令要么从命令行中输入，要么存储在一个文本文件中。sed编辑器会执行下列操作。\n一次从输入中读取一行数据。 根据所提供的编辑器命令匹配数据 按照命令修改流中的数据。 将新的数据输出到STDOUT 在流编辑器将所有命令与一行数据匹配完毕后，它会读取下一行数据并重复这个过程。在流编辑器处理完流中的所有数据行后，它就会终止。由于命令是按顺序逐行给出的，sed编辑器只需要对数据流进行一遍处理就可以完成编辑操作。 sed命令的格式如下 \u0026gt; sed options script file 选项允许你修改sed命令的行为，可以使用的：\n选项 描述 :\u0026ndash; :\u0026ndash; -e script 在处理输入时，将script中指定的命令添加到已有的命令中 -f file 在处理输入时，将file中指定的命令添加到已有的命令中 -n 不产生命令输出，使用print命令来完成输出 script参数指定了应用于流数据上的单个命令。如果需要用多个命令，要么使用-e选项在命令行中指定，要么使用-f选项在单独的文件中指定。\n在命令行定义编辑器命令 默认情况下，sed编辑器会将指定的命令应用到STDIN输入流上。这样你可以直接将数据通过管道输入sed编辑器处理。 e.g. \u0026gt; echo \u0026ldquo;This is a test\u0026rdquo; | sed \u0026rsquo;s/test/big test/' This is a big test 重要的是，要记住，sed编辑器并不会修改文本文件的数据。它只会将修改后的数据发送到STDOUT。\n在命令行使用多个编辑器命令 要在sed命令行上执行多个命令时，只要用-e选项就可以了。 e.g. \u0026gt; sed -e \u0026rsquo;s/brown/green/; s/dog/cat/\u0026rsquo; data1.txt 两个命令都作用到文件中的每行数据上。命令之间必须用分号隔开，并且在命令末尾和分号之间不能有空格。如果不想用分号，也可以用bash shell中的次提示符来分隔命令。只要输入 第一个单引号标示出sed程序脚本的起始（sed编辑器命令列表），bash会继续提示你输入更多的命令，直到输入了标示结束的单引号。 e.g. \u0026gt; sed -e ' s/brown/green/ s/fox/elephant/ s/dog/cat/\u0026rsquo; data.txt 必须记住，要在封尾单引号所在行结束命令。bash shell一旦发现了封尾的单引号，就会执行命令。开始后，sed命令就会将你指定的每笨命令应用到文本谁的中的每一行上。\n从文件中读取编辑器命令 最后，如果有大量要处理的sed命令，那么将它们放进一个单独的文件中通常会更方便一些。可以在sed命令中用-f选项来指定文件。 e.g. \u0026gt; sed -f script.sed data.txt 在sed文件中，不用在每条命令后面放一个分号，sed编辑器知道每行都是一条单独的命令。跟在命令行输入命令一样。\ngawk程序\ngawk能提供一个类编程环境来修改和重新组织文件中的数据。 gawk程序是Unix中的原始awk程序 的GNU版本。在gawk编程语言中，你可以做正面的事情：\n定义变量来保存数据 使用算术和字符串操作符来处理数据 使用结构化编程概念（比如if-then语句和循环）来为数据处理增加处理逻辑 通过提取数据文件中的数据元素，将其重新排列或格式化，生成格式化报告。 gawk程序的报告生成能力通常用来从大文本文件中提取数据元素，并将它们格式化成可读的报告。其中最完美的例子就是格式化日志文件。\ngawk命令格式 \u0026gt; gawkk options program file 可用选项：\n选项 描述 :\u0026ndash; :\u0026ndash; -F fs 指定行中划分数据字段的字段分隔符 -v var=value 定义gawk程序中的一个变量及其默认值 -mf N 指定要处理的数据文件中的最大字段值 -mr N 指定数据文件中的最大数据行数 -W keyword 指定gawk的兼容模式或警告等级 命令行选项提供了一个简单的途径来定制gawk程序的功能。\n从命令行读取程序脚本 gawk程序脚本用一对花括号来定义。你必须将脚本命令放到两个花括号（{}）中。由于gawk命令行假定脚本是单个文本字符串，你还必须将脚本放到单引号中。 e.g. \u0026gt; gawk \u0026lsquo;{print \u0026ldquo;Hello World!\u0026rdquo;}\u0026rsquo; 要终止这个gawk程序，你必须表明数据流已经结束了。bash shell提供了一个组合键来生成EOF（End-of-File）字符。Ctrl+D组合键会在bash中产生一个EOF字符。这个组合键能够终止gawk程序并返回到命令行界面提示符下。\n使用数据字段变量 gawk的主要特性之一是其处理文本文件中数据的能力。它会自动给一行中的每个数据元素分配一个变量。 -$0: 代表整个文本行\n$1：代表文本行中的第1个数据字段。 \u0026hellip; 在文本行中，每个数据字段字段都是通过字段分隔符划分的。gawk在读取一行文本时，会用预定义的字段分隔符划分每个数据字段。gawk中默认的字段分隔符是任意的空白字符（例如空格或制表符）。\n在程序脚本 中使用多个命令 gawk编程语言允许你将多条命令组合成一个正常的程序。要在命令行上有程序脚本中使用多条命令，只要在命令之间放个分号即可。 e.g. \u0026gt; echo \u0026ldquo;My name is Rich\u0026rdquo; | gawk \u0026lsquo;{$4=\u0026ldquo;Christine\u0026rdquo;; print $0}\u0026rsquo; My name is Christine 第一条命令会给字段变量$4赋值。第二条命令会打印整个数据字段。\n从文件中读取程序 跟sed编辑器一样，gawk编程器允许将程序存储到文件中，然后再在命令行中引用。 e.g. \u0026gt; cat script.gawk {print $1 \u0026ldquo;\u0026rsquo;s homedirectory is \u0026quot; $6} gawk -F: -f scrippt.gawk /etc/passwd\n在处理数据前运行脚本 gawk还允许指定程序脚本何时运行。默认情况下，gawk会从输入中读取一行文本，然后针对该行的数据执行程序脚本 。有时可能需要在处理数据前运行脚本，比如为报告创建标题。BEGIN关键字就是用来做这个的。它会强制gawk在读取数据前执行BEGIN关键字后指定的程序脚本 。 e.g. \u0026gt; gawkk \u0026lsquo;BEGIN {print “Hello World！”}\u0026rsquo;\n在处理数据后运行脚本 与BEGIN关键字类似，END关键字允许你指定一个程序脚本，gawk会在读完数据后执行它。 e.g. \u0026gt; gawk \u0026lsquo;BEGIN {print \u0026ldquo;The data3 File Contents: \u0026ldquo;} {print $0} END {print \u0026ldquo;End of File\u0026rdquo;}\u0026rsquo; data3.txt 在脚本中除了使用-F还可以使用叫作FS的特殊变量指定分隔符。\nsed编程基础 成功使用sed编辑器的关键在于掌握其各式各样的命令和格式。\n更多的替换选项\ns命令（substitute）：替换\n替换标记 替换命令在替换多行中的文本时能正常工作，但默认情况下它只替换每行中出现的第一处，要让替换命令替换一行中不同地方出现的文本必须使用替换标记。替换标记会在替换命令字符串之后设置。 \u0026gt; s/pattern/replaccement/flags 有4种可用的替换标记：\n数字： 表明新文本将替换第几处模式匹配的地方 g： 表明新文本将会替换所有匹配的文本 -p： 表明原先行的内容要打印出来 -w file：将替换的结果写到文件中 \u0026gt; sed \u0026rsquo;s/test/trial/w test.txt\u0026rsquo; data.txt * w替换标记会产生输出到test.txt文件\n替换字符 有时你会在文本字符串中遇到一些不太方便在替换模式中使用的字符。如：正斜线。要解决这个问题，sed编辑器允许选项其他字符来作为替换命令中的字符串分隔符。 e.g. 使用感叹号做为分隔符 \u0026gt; sed \u0026rsquo;s!/bin/bash!/bin/zsh!\u0026rsquo; /etc/passwd\n使用地址\n默认情况下，在sed编辑器中使用的命令会作用于文本数据的所有行。如果只想将命令作用于特定行或某些行，则必须用行寻址。在sed编辑器中有两种形式的行寻址：\n以数字形式表示行区间 用文本模式来过滤出行 两种形式都使用相同的格式来指定地址： \u0026gt; [address] command 也可以将特定地址的多个分组： \u0026gt; address { command1 command2 command3 }\n数字方式 的行寻址 e.g. \u0026gt; sed \u0026lsquo;2s/dog/cat/\u0026rsquo; data1.txt *只替换第二行 sed \u0026lsquo;2,3s/dog/cat/\u0026rsquo; data1.txt *替换2到3行 sed \u0026lsquo;2, $s/dog/cat/\u0026rsquo; data1.txt *替换2到最后一行\n使用文本模式过滤器 sed允许指定文本模式来过滤出命令要作用的行，命令格式如下： \u0026gt; pattern/command 必须用正斜线将要指定的pattern封起来。sed编辑器会将该 命令作用到包含指定文本模式的行上。 e.g. \u0026gt; sed \u0026lsquo;/root/s/bash/zsh\u0026rsquo; /etc/passwd *替换root用户的默认shell sed编辑器在文本模式中采用了一种称为正则表达式的特性来帮助创建匹配模式。\n命令组合 如果需要在单选上执行多条命令，可以用花括号将多条命令组合在一起。sed编辑器会处理地址行处列出的每条命令。 e.g. \u0026gt; sed \u0026lsquo;2, ${ s/foox/elephant/ s/dog/cat/ }\u0026rsquo; data.txt\n删除行\n删除命令d，会删除匹配指定寻址模式的所有行。如果忘记加入寻址模式的话，流中的所有文本行都会被删除。\n通过区间指定 \u0026gt; sed \u0026lsquo;2, 5d\u0026rsquo; data.txt\n通过模式匹配删除 \u0026gt; sed \u0026lsquo;/number 1/d\u0026rsquo; data.txt 记住sed编辑器不会修改原始文件，你删除的行只是从sed编辑器的输出中消失了。原始文件仍然包含那些“删除掉的”行\n插入了附加文本\nsed编辑器允许向数据流 插入附加 文本行。\n插入（insert）命令（i）会在指定行前增加一个新行； 附加（append）命令（a）会在指定行后增加一个新行。 它们不能在单个命令行上使用。你必须指定是要将行插入还是附加 到另一行。格式如下： \u0026gt; sed \u0026lsquo;[address]command\\ new line\u0026rsquo; new line中的文本将会出现在sed编辑器输出中你指定的位置。 e.g. \u0026gt; echo \u0026ldquo;Test Line 2\u0026rdquo; | sed \u0026lsquo;i\\Test Line 1\u0026rsquo; \u0026gt; sed \u0026lsquo;3i\\ This is an inserted line.\u0026rsquo; data.txt *数据会插入到数据流的第三行\n修改行\n修改（change）命令（c）允许你修改数据流中事先 文本的内容。同样可以使用行号模式和文本模式也寻址 e.g. \u0026gt; sed \u0026lsquo;3c\\ This is a changed line of text.\u0026rsquo; data.txt sed \u0026lsquo;/number 4/c\\ This is a change line of txt .\u0026rsquo; data.txt\n转换命令\n转换（transform）命令（y）是唯一可以处理单个字符的sed编辑器命令。格式如下： \u0026gt; [address]y/inchars/outchars/ 转换命令会对inchars和outchars值 进行一对一的映射。如果inchars和outchars的长度不同，则sed编辑器会产生一条错误消息。e.g. \u0026gt; sed \u0026lsquo;y/123/789/\u0026rsquo; datta.txt 转换命令是个全局命令，也就是说，它会在文本行中找到的所有指定字符自动 进行转换，而不会考虑它们出现的位置。\n回顾打印\n有3个命令可以用来打印数据流中的信息：\np命令 等号（=）命令用来打印行号 小写的L命令用来列出行 打印行 \u0026gt; echo \u0026ldquo;thhis is a test\u0026rdquo; | sed \u0026lsquo;p\u0026rsquo; sed -n \u0026lsquo;/number 3/p\u0026rsquo; data.txt 在命令行上用-n选项，你可以禁止输出其他行只打印包含匹配文本模式的行。 \u0026gt; sed -n \u0026lsquo;2,3p\u0026rsquo; data.txtt 如果需要在修改之前查看行，也可以使用打印命令，比强替换或修改命令一起使用。 e.g. \u0026gt; sed -n \u0026lsquo;/3/{ p s/line/test/p }\u0026rsquo; data.txt *sed命令会查找包含数字3的行，然后执行两条命令。\n打印行号 等号命令会打印行在数据流中的当前行号。 \u0026gt; sed \u0026lsquo;=\u0026rsquo; data.txtt\n列出行 列出（list）命令（l）可以打印数据流中的文本和不可打印的ASCII字符。 e.g. \u0026gt; sed -n \u0026rsquo;l\u0026rsquo; data.txt\n使用sed处理文件\n1.写入文件 w命令用来向文件写入行。格式如下： \u0026gt; [adddress]w filename filename可以使用相对路径 或绝对 路径，但不管是哪种，运行sed编辑器的用户都必须有文件的写权限。 e.g. \u0026gt; sed \u0026lsquo;1,2w test.txt\u0026rsquo; data.txtt *将data.txt中的前两行写入test.txt\n从文件读取数据 读取（read）命令（r）允许你将一个独立 文件中的数据插入到数据流中。格式如下： \u0026gt; [address]r filename filename参数指定了数据文件的绝对路径 或相对路径 。你在读取命令中使用地址区间，只能指定单独一个行号或文本模式地址。sed编辑器会将文件中的文本插入到指定 地址后。 e.g. \u0026gt; sed \u0026lsquo;3r data1.txt\u0026rsquo; data2.txt *会将data1.txt中的数据插入data2的第三行后。\n正则表达式 在脚本 中成功运用sed编辑器和gawk程序的着急在于熟练使用正则表达式。\n什么是正则表达式 定义 正则表达式的类型\n正则表达式是通过正则表达式引擎（regular expression engine）实现的。正则表达式引擎是一套底层软件，负责解释正则表达式模式并使用这些模式进行文本匹配在Linux中，有两种流行的正则表达式引擎：\nPOSIX基础正则表达式（basic regular expression.BRE）引擎 POSIZ扩展正则表达式（extended regular expression， ERE）引擎 定义BRE模式 纯文本 特殊字符\n正则表达式识别的特殊字符包括： \u0026gt; .*[]^${}\\+?|() 如果需要某个特殊字符作为文本字符，就必须转义。在转义特殊字符时，你需要在它前面加一个特殊字符来告诉正则表达式引擎应该将接下来的字符当作普通的文本字符。这个特殊字符就是反斜线（\\）。\n锚字符\n锁定在行首 脱 字符（^）定义从流中文本行的行首开始的模式。如果模式出现在行首之外的位置，正则表达式模式则无法匹配。\n锁定在行尾 特殊字符$定义了行尾锚点。\n组合锚点 点号字符\n特殊字符点号用来匹配除换行符之外的任意单个字符。\n字符组\n使用方括号来定义一个字符组。方括号里包含所有你希望出现在该 字符组中的字符。\n排除型字符组\n在字符组的开头加一个脱字符，就可以反转字符组的作用。寻找组中没有的字符。\n区间\n可以使用单破折线符号在字符组中表示字符区间。\n特殊的字符组\nBRE特殊字符组\n组 描述 :\u0026ndash; :\u0026ndash; :alpha: 匹配任意字母字符，不管是大写还是小写 :allnum: 匹配任意字母数字字符0-9, a-z或A-Z :blank: 匹配空格或制表符 :diigit: 匹配0-9之间的数字 :lower: 匹配小写字母字符 :print: 匹配伴音可打印字符 :punct: 匹配标点符号 :space: 匹配任意空白字符：空格，制表符，ML， FF， VT和CR :upper: 匹配任意大写字母字符 可以在正则表达式模式中将特殊字符组像普通字符组一样使用。\n星号\n在字符后面放置昨号表明该 字符那也得在匹配模式的文本中出现0次或多次\n扩展正则表达式 POSIX ERE模式包括了一些可供Linux应用和工具使用的额外符号 。gawk程序能够识别ERE模式，但sed编辑器不能。\n问号\n问题类似于星号，表明前面的字符可以出现0次或1次。\n加号\n表明前面的字符可以出现1次或多次。\n使用花括号\n花括号允许你为可重复的正则表达式指定一个上限。这通常称为间隔。可以用两种格式来指定区间\nm： 正则表达式准确出现m次 m,n：正则表达式至少出现m次，至多出现n次。 管道符号\n管道符号允许你在检查数据流时，用逻辑OR方式指定正则表达式引擎要用的两个或多个模式。如果任何一个模式匹配了数据流文本，文本就通过测试。\n表达式分组\n正则表达式也可以用圆括号分组。当你将正则表达式模式分组时，该分组会被视为一个标准字符。可以像对普通字符一样给该组使用特殊字符。\nsed进阶 多行命令 sed编辑器包含了三个可用来处理多行文本的特殊命令。\nN： 将数据流中的下一行加进来创建一个多行组来处理 D： 删除多行组中的一行 P： 打印多行组中的一行。 next命令\n单行的next命令 e.g. \u0026gt; sed \u0026lsquo;/header/{n; d}\u0026rsquo; data.txt * 删除含有header的行的下一行。\n合并文本行 多行版本的next命令（用大写的N）会将下一文本行添加到模式空间中已有的文本后。这样的作用是将数据流中的两个文本行合并到同一个模式空间中 。文本用换行符分隔。 e.g. \u0026gt; sed \u0026lsquo;first/{N ; s\\n/ /}\u0026rsquo; data.txt *查询含有单词first的那行文本。找到该行后，它会用N命令将下一行合并到那行，然后用替换命令s将拣选符替换成空格。\n多行删除命令\ne.g. \u0026gt; sed \u0026lsquo;N ; /Systemm\\nAdministrator/d\u0026rsquo; datta.txt *会删除合并后的两行内容 \u0026gt; sed \u0026lsquo;N ; /System\\nAdministrator/D\u0026rsquo; datta.txt * 会删除模式空间中的第一行。\n多行打印命令\n多行打印命令（P）没用了同样的方法。它只打印多行模式空间中的第一行。\n保持空间 模式空间（pattern space）是一块活跃的缓冲区，在sed编辑器执行命令时它会保存待检查的文本。但它并不是sed编辑器保存文本的唯一空间。 sed编辑器有另一块称作保持空间（hold space）的缓冲区域。有5条命令可用来操作保持空间：\n命令 描述 :\u0026ndash; :\u0026ndash; h 将模式空间复制到保持空间 H 将模式空间附加到保持空间 g 将保持空间复制到模式空间 G 将保持空间附加到模式空间 x 交换模式空间和保持 空间的内容 排除命令 感叹号命令（!）用来排除（negate）命令，也就是说原本会起作用的起作用。相当于取反的作。\n改变流 分支\n分支（branch）命令b的格式如下： \u0026gt; [address]b [label] adddress参数决定了哪些行的数据会触发分支命令。label参数定义了要跳转到的位置。如果没有加label参数，跳转命令会跳转到脚本 的结尾。 \u0026gt; sed \u0026lsquo;{first/b jump1 ; s/This is the /No jump on :jump1 s/This is the Jump here on}\u0026rsquo; data.txt e.g. \u0026gt; echo \u0026ldquo;This, is , a test, to, remove, commands.\u0026rdquo; | sed -n \u0026lsquo;{ :atart s/,//1p /,/b tart }\u0026rsquo; 分支命令会在行中有逗号的情况下跳转。在最后一个逗号被删除后，分支命令不会再执行，脚本也就能正常停止了。\n测试\n格式： \u0026gt; [address]t [label] e.g. \u0026gt; sed \u0026lsquo;{ s/firstmatched/ t s/This is the No match on }\u0026rsquo; data.txt 第一替换命令会查找模式文本firstt。如果匹配了行中的模式，它就会替换文本，而且测试命令会路过后面的替换命令。如果第一个替换命令未能匹配模式，第二个替换命令就会被执行。\n模式替代 \u0026amp;符号\n\u0026amp;符号可以用来代表替换命令中的匹配的模式。不管模式匹配的是什么样的文本，你都可以在替代模式中使用\u0026amp;符号来使用这段文本。 e.g. \u0026gt; echo \u0026ldquo;The cat sleeps in his hat.\u0026rdquo; | sed \u0026rsquo;s/.at/\u0026quot;\u0026amp;\u0026quot;/g\u0026rsquo; The \u0026ldquo;cat\u0026rdquo; sleeps in his \u0026ldquo;hat\u0026rdquo;.\n替代单独的单词\nsed编辑器用圆括号来定义替换模式中的子模式。你可以在替代模式中使用特殊字符来引用每个子模式。替代字符由反斜线和数字组成。数字表明子模式的位置。sed编辑器会给第一个子模式分配字符\\1,给第二个子模式分配字符\\2，依此类推。 e.g. \u0026gt;echo \u0026ldquo;The System Administrator manuall\u0026rdquo; | sed ' s/\\(System\\) Administrator/\\1 User\u0026rsquo; 这个替换命令用一对圆括号将单词System括起来，将其标示为一个子模式。然后它在替代模式中使用\\1来提取第一个匹配的子模式。\n在脚本中使用sed 创建sed实用工具 加倍行间距\n\u0026gt; sed \u0026lsquo;$!G\u0026rsquo; data.txt\n对可能 含有空白行的文件加倍行间距\n\u0026gt; sed \u0026lsquo;/^$/d ; $!G\u0026rsquo; data.txt\n给文件中的行编号\n\u0026gt;sed \u0026lsquo;=\u0026rsquo; data.txt | sed \u0026lsquo;N; s/\\n/ /\u0026rsquo;\n打印末尾行\n\u0026gt; sed -n \u0026lsquo;$p\u0026rsquo; data.txt\n删除行\n删除数据流中不需要的空白行。\n删除连续的空白行 \u0026gt; sed \u0026lsquo;.,/^$/!d\u0026rsquo; data.txt\n删除开头的空白行 \u0026gt; sed \u0026lsquo;.,$!d\u0026rsquo;\n删除结尾的空白行 \u0026gt; sed \u0026lsquo;{ :start /^\\n*$/{$d; N; b start } }\u0026rsquo;\n删除HTML标签 \u0026gt; sed \u0026rsquo;s/\u0026lt;.*\u0026gt;//g\u0026rsquo; data.txt\ngawk进阶 使用变量 所有编程语言共有的一个重要特性是使用变量来存取值。gawk编程语言支持两种不同类型的变量：\n内建变量 自定义变量 内建变量\n字段和记录分隔符变量 数据字段变量：允许你使用美元符号和字段在该 记录中的位置修士来引用记录对应的字段。如第一个：$1。数据字段由字段分隔符来划定的。默认情况下，字段分隔符是一个空白字符，也就是空格符或制表符。我们在命令行下可以使用-F或者gawk程序中使用特殊的内建变量FS来更改字段分隔符。 gawk数据字段和记录变量：\n变量 描述 :\u0026ndash; :\u0026ndash; FILEDWIDTHS 由空格分隔的一列数字，定义了每个数据字段确切宽度 FS 输入字段分隔符 RS 输入记录分隔符 OFS 输出字段分隔符 ORS 输出记录分隔符 数据变量 更多的gawk内建变量：\n变量 描述 :\u0026ndash; :\u0026ndash; ARGC 当前命令行参数个数 ARGIND 当前文件在ARGV中的位置 ARGV 包含命令行参数的数组 CONVFMT 数字的转换格式（参见printf语句），默认值为%.6g ENVIRON 当前Shell环境变量及其值组成的关联数组 ERRNO 当读取或关闭输入文件发生错误时的系统错误号 FILENAME 用作GAWK输入数据的数据文件的文件名 FNR 当前数据文件中的数据行数 IGNORECASE 设成非零值时，忽略gawk命令中出现的字符串的字符大小写 NF 数据文件中的字段总数 NR 已处理的输入记录数 OFMT 数字的输出格式，默认值为%.6g RLENGTH 由match函数所匹配的子字符串的长度 RSTART 由match函数所匹配的子字符串的起始位置 说明：跟shell变量不同，在脚本 中引用gawk变量时，变量名前不加美元符。\n自定义变量\ngawk自定义变量名可以是任意数目 的字母，数字和下划线，但不能以数字开头。而且区分大小写。\n在脚本 中给变量赋值 在gawk程序 中给变量赋值跟在shell脚本 中赋值类似，都用赋值语句。 e.g. \u0026gt; gawk ' BEGIN{ testing=\u0026ldquo;This is a test\u0026rdquo; print testing }\u0026rsquo; \u0026gt; This is a test\n在命令行上给变量赋值 处理数组 Gawk使用关联数组提供数组功能 。\n定义数组变量\n可以用标准赋值语句 来定义 数组变量。格式如下： \u0026gt; var[index] = element\n遍历数组变量\n可以使用for语句的一种特殊形式。 \u0026gt; for (var in arrayy) { print \u0026ldquo;Index: \u0026ldquo;, test, \u0026quot; - Value: \u0026ldquo;, var[test] }\n删除数组变量\n\u0026gt; delete array[index]\n使用模式 正则表达式\n在使用正则表达式时，正则表达式必须出现在它要控制的程序脚本 的左花括号前。 \u0026gt; gawk \u0026lsquo;BEGIN{FS=\u0026rdquo;,\u0026rdquo;} /11/{print $1}\u0026rsquo; data 正则表达式/11/匹配了数据字段中含有字符串11的记录。\n匹配操作符\n匹配操作符（matching operator)允许将正则表达式限定在记录中的特定数据字段。匹配操作符的波浪线（~）可以指定匹配操作符，数字字段变量以及要匹配的正则表达式。 e.g. \u0026gt; gawk \u0026lsquo;BEGIN{FS=\u0026rdquo;,\u0026rdquo;} $2 ~ /^data2/{print $0}\u0026rsquo; data 匹配操作符会用正则表达式/^data2/来比较第二个数据字段。\n数学 表达式\n除了正则表达式，你也可以在匹配模式中用数学表达式。 e.g. \u0026gt; gawkk -F: \u0026lsquo;$4==0{print $1}\u0026rsquo; /etc/passwd\n结构化命令 if语句\ngawk编程语言支持标准的if-then-else格式的if语句。格式： \u0026gt; if (condition) statment e.g. \u0026gt; gawk \u0026lsquo;{ if ($1 \u0026gt; 20) { x = $1 *2 print x } }\u0026rsquo; datta\nwhile语句\n格式： \u0026gt; while (condition) { statements }\ndo-while语句\n格式： \u0026gt; do { stattements } while (conditiion)\nfor语句\n格式： \u0026gt; for( variable asssignmennt; coondition; iteration process)\n格式化打印 gawk中的printf命令跟C语言的用法一致，格式如下： \u0026gt; printf \u0026ldquo;format string\u0026rdquo;, var1, var2 \u0026hellip; 格式化指定符采用如下格式： \u0026gt; %[modifier]control-letter 其中control-leter是一个单字符代码，用于指明显示什么类型的数据，而modifier则定义了可选的格式化特性。格式化指定字符的控制字母表：\n控制字母 描述 :\u0026ndash; :\u0026ndash; c 将一个数作为ASCII字符显示 d 显示一个整数值 i 显示一个整数值（跟d一样） e 用科学计数法显示一个数 f 显示一个浮点数 g 用科学计数法或浮点数显示（选择较短的格式） o 显示一个八进制数 s 显示一个文本字符串 x 显示一个十门进制数 X 显示一个十六进制值，但用大写字母A-F 除了控制字母外，还有3种修饰符可以用来进一步控制输出。\nwidthh: 指定输出字段最小宽度的数字值。如果输出短于这个值 ，printf会将文本右对齐，并用空格进行填充。如果输出比指定的宽度还要长，则按照实际长度输出。 prec：这是一个数字值，指定浮点数中小数点后面位数，或者文本字符串显示的最大字符数。 -（减号）： 指明在向格式化空间中放入数据时采用左对齐而不是右对齐。 内建函数 gawk提供了不少内置函数，可进行一些常见的数学，字符串以及时间函数运算。\n数学函数\n函数 描述 :\u0026ndash; :\u0026ndash; atan2(x, y) x/y的反正切， x和y以弧度为单位 cos(x) x的余弦，x以弧度为单位 exp(x) x的指数函数 int(x) x的整数部分，取靠近零一侧的值 log(x) x的自然对数 randd() 比0大比1小的随机浮点数 sin(x) x的正统，x以弧度为单位 sqrt(x) x的平方根 srand(x) 为计算随机数指定 一个种子 值 除了标准数学函数外，gawk还支持一些按位操作数据的函数\n函数 描述 :\u0026ndash; :\u0026ndash; and(v1, v2) 执行值v1和v2的按位运算 compl(vall) 执行val的补位运算 lshift(val,count) 将值val左移count位 or(v1, v2) 执行值v1和v2的按位或运算 rshift（val， count） 将值val右移count位 xor(v1, v2) 执行值v1和v2的按位异或运算 字符串函数 函数 描述 :\u0026ndash; :\u0026ndash; asort(s [,d]) 将数组s按数据元素值排序。索引值 会被替换成的排序顺序的连续数字。另外，如果指定了d，则排序后的数组会存储在数组d中 asorti(s [,d]) 将数组s按索引值排序。生成的数组会将作为数据元素值，用连续数字索引来表明排序顺序。另外如果指定了d，排序后的数组会存储在数组d中 gensub(r,s,h [,t]) 查找变量$0或目标字符串t（如果提供了的话）来匹配正则表达式r。如果h是一个以g或G开头的字符串，就用s替换掉匹配的文本。如果h是一个数字，它表示替换掉第h处r匹配的地方 gsub(r, s [,t]) 查找变量$0或目标字符串t(如果提供了的话)来匹配正则表达式r。如果找到了，就全部替换成字符串s index(s,t) 返回字符串t在字符串s中的索引值，如果没找到的话就返回0 length([s]) 返回字符串s的长度，如果没有指定的话，返回$0的撒谎 match(s, r [,a]) 返回字符串s中正则表达式r出现位置的索引。如果指定了数组a，它会存储s中匹配正则表达式的那部分 split(s, a [,r]) 将s用FS字符或正则表达式r（如果指定了的话）分开放到数组a中。返回字段的总数. sprintf(format, variables) 用提供的format和variables返回一个类似于printf输出的字符串 sub(r, s [,t]) 在变量$0或目标字符串t中查找正则表达式r的匹配。如果找到了，就用字符串s替换掉第一处理匹配。 substr(s, i [,n]) 返回s中从索引值i开始的n个字符组成的子字符串。如果未提供n，则返回s剩下的部分 toloweer(s) 将s中的所有字符转换成小写 tooupper(s) 将s中的所有字符转换成大写 时间函数 函数 描述 :\u0026ndash; :\u0026ndash; mktiime(datesppec) 将一个按YYYY MM DD HH MM SS [DST]格式指定的日期转换成时间戳值 strftime(format [,timestamp]) 将当前时间的时间戳或tiimestammp（如果提供了的话）转化格式化日期（采用shell函数date()的格式) systime() 返回当前时间的时间戳 自定义函数 要定义自己的函数，必须用function关键字。 \u0026gt; function name([variables]) { statements } 函数名必须能够唯一标识函数。\n使用自定义函数\n在定义函数时，它必须出现在所有代码块之前（包括BEGIN代码块）。它有助于将函数代码与gawk程序的其他部分分开。\n创建函数库\ngawk提供了一种途径来将多个函数放到一个库文件中，这样你就能在所有的gawk程序中使用了。首先，你需要创建一个存储所有gawk函数的文件使用时间需要使用-f命令行参数来使用它们。\n使用其它Shell dash shell zsh shell 创建实用的脚本 编写简单的脚本实用工具 创建与数据库、Web及电子邮件相关的脚本 一些小有意思的脚本 附录 A1. bash命令快速指南 命令 描述 :\u0026ndash; :\u0026ndash; : 扩展参数列表，执行重定向操作 . 读取并执行指定文件中的命令（在当前shell环境中） alias 为指定命令定义一个别名 bg 将作业以后台模式运行 bind 将键盘序列绑定到一个readline函数或宏 break 退出for,while,selecct或until循环 builtin 执行指定的shell内建命令 caller 返回活动子函数调用 的上下亠 cd 将当前目录切换为指定的目录 command 执行指定的命令，无需进行通常的shell查找 compgenn 为指定单词生成可能的补全匹配 complete 显示指定的单词是如何补全的 compopt 修改指定单词的补全选项 continue 继续执行for, while,select或until循环的下一次迭代 declare 声明一个变量或变量类型 dirs 显示当前存储目录的列表 disown 从进程作业表中删除指定的作业 echo 将指定字符串输出到STDOUT enable 启用或禁用指定的内建shell命令 eval 将指定的参数拼接成一个命令，然后再执行该命令 exec 用指定命令替换shell进程 exit 强制shell以指定的退出状态码退出 export 设置子shell进程可用的变量 fc 从历史记录中选择命令列表 fg 将作业以前台模式运行 getopts 分析指定的位置参数 hash 查找并记住指定命令的全路径名 help 显示帮助文件 history 显示命令历史记录 jobs 列出活动作业 kill 向指定的进程ID发送一个系统信号 let 计算一个数学表达式中的每个参数 local 在函数中创建一个作用域受限的变量 logout 退出登录shell mapfile 从STDIN读取数据行，并将其加入索引数组 popd 从目录栈中删除记录 printf 使用格式化字符串显示文本 pushd 向目录栈添加一个目录 pwd 显示当前工作目录的路径名 read 从STDIN读取一行数据并将其赋给一个变量 readarray 从STDIN读取数据行并将其放入索引数组 readonly 从STDIN读取一行数据并将其赋给一个不可修改的变量 return 强制函数以某个值退出，这个值可以被调用脚本提取 set 设计并显示环境变量的值和shell属性 shift 将位置参数依次向下降一个位置 shopt 打开/关闭控制shell可选 行为的变量值 source 读取并执行指定文件中的命令 suspend 暂停shell的执行，直到收到一个SIGCONT信号 test 基于指定条件返回退出状态码0或1 times 显示累计的用户和系统时间 trap 如果收到了指定的系统信号，执行指定的命令 type 显示指定的单词如果作为命令将会如何被解释 typeset 声明一个变量或变量类型 ulimit 为系统用户设置指定的资源的上限 umask 为新建的文件和目录设置默认权限 unalias 删除指定的别名 unset 删除指定的环境变量或shell属性 wait 等待指定的进程完成，并返回退出状态码 A2. 常见的bash命令 命令 描述 \u0026mdash;\u0026mdash;\u0026mdash;- \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; bzip2 采用Burrows-Wheeler块排序文本压缩算法和霍夫曼编码进行压缩 cat 列出指定文件的内容 chage 修改指定系统用户账户的密码过期日期 chfn 修改指定用户账户的备注信息 chgrp 修改指定文件或目录的默认属组 chmod 为指定文件或目录修改系统安全权限 chown 修改指定文件或目录的默认发证 chpasswd 读取一个包含登录名/密码的文件并更新密码 chsh 修改指定用户账户的默认shell clear 从终端仿真器或虚拟控制台终端删除文本 compress 最初的Unix文件压缩工具 coproc 在后台模式中生成子shell，并执行指定的命令 cp 将指定文件复制到另一个位置 crontab 初始化用户的crontable对应的编辑器（如果允许的话） cut 删除文件行中指定的位置 date 以各种格式显示日期 df 显示所有挂载设备的当前磁盘空间使用情况 du 显示指定文件路径的磁盘使用情况 emacs 调用emacs文本编辑器 file 查看指定文件的文件类型 find 对文件进行递归查找 free 查看 系统上可用的和已用的内存 gawk 使用编程语言命令的流编辑器 grep 在文件中查找指定的文本字符串 gedit 调用 GNOME桌面编辑器 getopt 解析命令选项（包括长格式选项） groups 显示指定用户的组成员关系 groupadd 创建新的系统组 groupmod 修改已有的系统级 gzip 采用Lempel-Ziv编码的GNU项目压缩工具 head 显示指定文件内容的开头部分 help 显示bash内建命令的帮助页面 killall 根据进程名向运行中的进程发送一个系统信号 kwrite 调用 KWrite文本编辑器 less 查看文件内容的高级方法 link 用别名创建一个指向文件的链接 ln 创建针对指定文件的符号链接或硬链接 ls 列出目录内容 makewhatis 创建能够使用手册页关键字进行搜索的whatis数据库 man 显示指定命令或话题的手册页 mkdir 在当前目录下创建指定目录 more 列出指定文件的内容，在每屏数据后暂停下来 mount 显示虚拟文件系统上挂载的设备或将磁盘设备挂载到虚拟文件系统上 mv 重命令名或移动文件，文件夹 nano 调用nano文本编辑器 nice 在系统上使用不同优先级来运行命令 passwd 修改某个系统用户的账户的密码 ps 显示系统上运行中进程的信息 pwd 显示当前目录 renice 修改系统上运行的优先级 rm 删除文件 rmdir 删除指定目录 sed 使用编辑的文本流编辑器 sleep 在的一段时间内暂停bash shell操作 sort 基于指定的顺序组织数据文件中的数据 stat 显示指定文件的文件统计数据 sudo 以root用户账户身价运行应用 tail 显示指定文件内容的末尾内容 tar 将数据和目录归档到 单个文件中 top 显示活动进程以及其他重要的系统统计数据 touch 新建一个空文件，或更新一个已有文件的时间戳 umount 从虚拟文件系统上删除一个已挂载的磁盘设备 uptime 显示系统已运行了多久 useradd 新建一个系统用户账户 uaserdel 删除已有的一个系统账户 usermod 修改已有系统用户账户 vi 调用vim文本编辑器 vmstat 生成一个详尽的系统内存和CPU使用情况报告 whereis 显示指定命令的相关文件，包括二进制文件，源代码文件以及手册页 which 查找可执行文件的位置 who 显示当前系统中的登录用户 whoami 显示当前用户的用户名 xargs 从STDIN中获取数据项，构建并执行命令 zip Windows下的PKZIP程序的Unix版本 A.3 环境变量 变量 描述 * 含有所有命令行参数（以单个文本值的形式） @ 含有所有命令行参数（以多个文本值的形式） * 命令行参数数目 ？ 最近使用的前台退出状态码 - 当前命令行选项标记 $ 当前shell的进程ID ! 最近执行后台PID 0 命令行中使用的命令名称 _ shell的绝对路径名 BASH 用户调用shell的完整文件名 BASHOPTS 允许冒号分隔列表形式的shell选项 BASHPID 当前bash shell的进程ID BASH_ALIASED 含有当前所用别名的数组 BASH_ARGC 当前子函数中的参数数量 BASH_ARGV 含有所有指定命令行参数的数组 BASH_CMDS 含有命令的内部的数组 BASH_COMMAND 当前正在被执行的命令名 BASH_ENV 如果设置了的话，每个bash脚本都会尝试在运行前执行由该 变量定义的起始文件 BASH_EXECUTION_STRING 在-c命令行选项中用到的命令 BASH_LINENO 含有脚本 中每个命令的行号的数组 BASH_REMATCH 含有与指定的正则表达式匹配的文本元素的数组 BASH_SOURCE 含有shell中已声明函数所在源文件名的数组 BASH_SUBSHELL 当前shell生成的子shell数目 BASH_VERSINFO 含有当前bash shell实例的主版本号和次版本号的数组 BASH_VERSION 当前bash shell实例的版本号 BASH_STRACFED 当设置一个有效的文件描述衔整数时，跟踪输出生成，并与诊断和错误信息分离开文件描述 符必须设置-x启动 COLUMNS 含有当前bash shell实例使用的终端的宽度 COMP_CWORD 含有变量COMP_WORDS的索引值，COMP_WORD包含当前光标所在的位置 COMP_KEY 调用补全功能的按键 COMP_LINE 当前命令行 COMP_POINT 当前光标位置相对于当前命令起始位置的索引 COMP_TYPE 实例类型所对应的整数值 COMP_WORDBREAKS 在进行单词补全时用作单词分隔符的一组字符 COMP_WORDS 含有当前命令行上所有单词的数组 COMPREPLY 含有由shell函数生成的可能补全码的数组 COPROC 含有用于匿名协程I/O的文件描述符的数组 DIRSTACK 含有目录栈当前内容的数组 EMACS 如果设置了该环境变量，则shell认为其使用的是emacs shell缓冲区，同时禁止行编辑功能 ENV 当shell以POSIX模式调用时，每个bash脚本在运行之前都会执行由该环境变量所定义的起始文件 EUID 当前用户的有效用户ID FCEDIT fc命令使用的默认编辑器 FIGNORE 以冒号分隔的后缀名列表，在文件名补全时会被忽略 FUNCNAME 当前执行的shell函数的名称 FUNCNEST 嵌套函数的最高层级 GLOBIGNORE 以早号分隔的模式列表，定义了文件名展开时要忽略的文件名集合 GROUPS 含有当前用户属组的数组 histchars 控制历史记录展开的字符（最多可有3个） HISTCMD 当前命令在历史记录中的编号 HISTCONTROL 控制哪些命令留在历史记录列表中 HISTFILE 保存shell历史记录列表的文件名（默认是.bash_history） HISTFILESIZE 保存在历史文件中的最大行数 HISTIGNORE 以冒号分隔的模式列表，用来决定哪些命令不存进历史文件 HISTSIZE 最多在历史文件中保存多少条命令 HISTIMEFORMAT 设置后，决定历史文件条目的时间戳的格式字符串 HOSTFILE 含有shell在补全主机名时读取的文件的名称 HOSTNAME 当前主机的名称 HOSTTYPE 当前运行bash shell的机器 IGNOREEOF shell在退出前必须收到连续的EOF字符的数量。如果这个值不存在，默认是1 INPUTRC readline初始化文件名（默认是.inputrc） LANG shell的语言环境分类 LC_ALL 定义一个语言环境分类，它会覆盖LANG变量 LC_COLLATE 设置对字符串值排定义了终端上可见的行数 名扩展和模式匹配时，如何解释其中的字符 LC_MESSAGES 决定解释前置美元符（$）的双引号字符串的语言环境设置 LC_NUMERIC 决定格式化数字时的所使用的语言环境设置 LINENO 脚本中当前执行代码的行号 LINES 定义了终端上可见的行数 MACHTYPE 用“cpu公司系统”格式定义的系统类型 MAILCHECK shell多久查看一次新邮件（以秒为单位，默认值是60） MAPFILE 含有mapfile命令所读入文本的数组，当没有给出变量名的时候，使用该环境变量 OLDPWD shell之前的工作目录 OPTERR 设置为1时，bash shell会显示getopts命令产生的错误 OSTYPE 定义了shell运行的操作系统 PIPESTATUS 含有前台进程退出状态码的数组 POSIXLY_CORRECT 如果设置了该环境变量，bash会以POSIX模式启动 PPID bash shell父进程的PID PROMPT_COMMAND 如果设置该环境变量，在显示命令行主提示符之前会执行这条命令 PS1 主命令行提示符字符串 PS2 次命令行提示符字符串 PS3 select命令的提示符 PS4 如果使用了bash的-x选项，在命令行显示之前显示的提示符 PWD 当前工作目录 RANDOM 返回一个0~32 767的随机数，对其赋值可作为随机数生成器的种子 READLINE_LINE 保存了readline行缓冲区中的内容 READLINE_POINT 当前readline行缓冲区的插入点位置 REPLY read命令的默认变量 SECONDS 自shell启动到现在的秒数，对其赋值将会重置计时器 SHELL shell的全路径名 SHELLOPTS 已启用bash shell选项列表，由冒号分隔 SHLVL 表明shell层级，每次启动一个新的bash shell时计数加1 TIMEFORMAT 指定了shell显示的时间值的格式 TMOUT select和read命令在没输入的情况下等待多久（以秒为单位）。默认值为零，表示无限长 TMPDIR 如果设置成目录名，shell会将其作为临时文件目录 UID 当前用户的真实用户ID（数字形式） 可以用set内建命令来显示这些环境变量。对于不同的Linux发行版，开机时设置的默认shell变量经常会不一样。\n","permalink":"https://stoneepigraph.github.io/posts/os/linux/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E5%A4%A7%E5%85%A8/","title":"Linux命令行与Shell脚本大全"},{"content":" Maven库： http://repo2.maven.org/maven2/\nMaven依赖查询： http://mvnrepository.com/\nMaven常用命令： 创建Maven的普通java项目： mvn archetype:create -DgroupId=packageName -DartifactId=projectName 创建Maven的Web项目： ​ mvn archetype:create ​ -DgroupId=packageName ​ -DartifactId=webappName ​ -DarchetypeArtifactId=maven-archetype-webapp\n编译源代码： mvn compile 编译测试代码：mvn test-compile 运行测试：mvn test 产生site：mvn site 打包：mvn package 在本地Repository中安装jar：mvn install 清除产生的项目：mvn clean 生成eclipse项目：mvn eclipse:eclipse 生成idea项目：mvn idea:idea 组合使用goal命令，如只打包不测试：mvn -Dtest package 编译测试的内容：mvn test-compile 只打jar包: mvn jar:jar 只测试而不编译，也不测试编译：mvn test -skipping compile -skipping test-compile ​ ( -skipping 的灵活运用，当然也可以用于其他组合命令)\n清除eclipse的一些系统设置:mvn eclipse:clean ps：一 般使用情况是这样，首先通过cvs或svn下载代码到本机，然后执行mvn eclipse:eclipse生成ecllipse项目文件，然后导入到eclipse就行了；修改代码后执行mvn compile或mvn test检验，也可以下载eclipse的maven插件。 mvn -version/-v 显示版本信息 mvn archetype:generate 创建mvn项目 mvn archetype:create -DgroupId=com.oreilly -DartifactId=my-app 创建mvn项目 mvn package 生成target目录，编译、测试代码，生成测试报告，生成jar/war文件 mvn jetty:run 运行项目于jetty上, mvn compile 编译 mvn test 编译并测试 mvn clean 清空生成的文件 mvn site 生成项目相关信息的网站 mvn -Dwtpversion=1.0 eclipse:eclipse 生成Wtp插件的Web项目 mvn -Dwtpversion=1.0 eclipse:clean 清除Eclipse项目的配置信息(Web项目) mvn eclipse:eclipse 将项目转化为Eclipse项目在应用程序用使用多个存储库\n\u0026lt;repositories\u0026gt; ​ \u0026lt;repository\u0026gt; ​ \u0026lt;id\u0026gt;Ibiblio\u0026lt;/id\u0026gt; ​ \u0026lt;name\u0026gt;Ibiblio\u0026lt;/name\u0026gt; ​ \u0026lt;url\u0026gt;http://www.ibiblio.org/maven/\u0026lt;/url\u0026gt; ​ \u0026lt;/repository\u0026gt; ​ \u0026lt;repository\u0026gt; ​ \u0026lt;id\u0026gt;PlanetMirror\u0026lt;/id\u0026gt; ​ \u0026lt;name\u0026gt;Planet Mirror\u0026lt;/name\u0026gt; ​ \u0026lt;url\u0026gt;http://public.planetmirror.com/pub/maven/\u0026lt;/url\u0026gt; ​ \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; mvn deploy:deploy-file -DgroupId=com -DartifactId=client -Dversion=0.1.0 -Dpackaging=jar -Dfile=d:client-0.1.0.jar -DrepositoryId=maven-repository-inner -Durl=ftp://xxxxxxx/opt/maven/repository/ 发布第三方Jar到本地库中： mvn install:install-file -DgroupId=com -DartifactId=client -Dversion=0.1.0 -Dpackaging=jar -Dfile=d:client-0.1.0.jar -DdownloadSources=true -DdownloadJavadocs=true mvn -e 显示详细错误 信息. mvn validate 验证工程是否正确，所有需要的资源是否可用。 mvn test-compile 编译项目测试代码。 。 mvn integration-test 在集成测试可以运行的环境中处理和发布包。 mvn verify 运行任何检查，验证包是否有效且达到质量标准。 mvn generate-sources 产生应用需要的任何额外的源代码，如xdoclet。\n常用命令： mvn -v 显示版本 mvn -Dplugin=help 使用 help 插件的 describe 目标来输出 Maven Help 插件的信息。 mvn -Dplugin=help -Dfull 使用Help 插件输出完整的带有参数的目标列 mvn -Dplugin=compiler -Dmojo=compile -Dfull 获取单个目标的信息,设置 mojo 参数和 plugin 参数。此命令列出了Compiler 插件的compile 目标的所有信息 mvn -Dplugin=exec -Dfull 列出所有 Maven Exec 插件可用的目标 mvn 看这个“有效的 (effective)”POM，它暴露了 Maven的默认设置 mvn archetype:create -DgroupId=org.sonatype.mavenbook.ch03 -DartifactId=simple -DpackageName=org.sonatype.mavenbook 创建Maven的普通java项目，在命令行使用Maven Archetype 插件 mvn exec:java -Dexec.mainClass=org.sonatype.mavenbook.weather.Main Exec 插件让我们能够在不往 classpath 载入适当的依赖的情况下，运行这个程序 mvn dependency:resolve 打印出已解决依赖的列表 mvn dependency:tree 打印整个依赖树 mvn install -X 想要查看完整的依赖踪迹，包含那些因为冲突或者其它原因而被拒绝引入的构件，打开 Maven 的调试标记运行 mvn install -Dmaven.test.skip=true 给任何目标添加maven.test.skip 属性就能跳过测试 mvn install assembly:assembly 构建装配Maven Assembly 插件是一个用来创建你应用程序特有分发包的插件 mvn jetty:run 调用 Jetty 插件的 Run 目标在 Jetty Servlet 容器中启动 web 应用 mvn compile 编译你的项目 mvn clean install 删除再编译 mvn hibernate3:hbm2ddl 使用 Hibernate3 插件构造数据库\n","permalink":"https://stoneepigraph.github.io/posts/language/java/maven/","title":"maven基础"},{"content":" Nginx基础1 Nginx架构 nginx事件模型 nginx是采用的异步非阻塞。\n拿epoll为例，当事件没准备好时，放到epoll里，事件准备好了，我们就去读写，当读写返回EAGAIN时，我们将它再次加入到epoll里。这样，只要有事件准备好了，我们就去处理它，只有当所有事件都没准备好时，才在epoll里等着。这样我们就可以并发处理大量的并发了，当然，这里的并发请求，是指未处理完的请求，线程只有一个，所以同时能处理的请求当然只有一个，只是在请求间进行不断切换而已，切换也是因为异步事件未准备好，而主动让出的。这里的切换是没有任何代价的，你可以理解为循环处理多个准备好的事件，事实上就是这样的。与多线程相比，这事事件处理方式是有很大的优势的，不需要创建线程，每个请求占用的内存也很少，没有上下文切换，事件处理非常轻量级。并发数再多也不会导致无谓的资源浪费（上下文切换）。更多的并发数，只是会占用更多的内存而已。\nNginx的worker数最好设置为CPU的核数。 Nginx基本概念 connection\n在Nginx中connection就是对tcp连接的封闭，其中包括连接的socket, 读事件，写事件。利用Nginx封闭的Connection，我们可以很方便的使用Nginx来处理与连接相关的事情，比如，建立连接，发送与接受数据等。而Nginx中的http请求的处理就是建立在Connection之上的，所以Nginx不公可以作为一个web服务器， 也可以作为邮件服务器。当然，利用Nginx提供的Connection,我们可以与任何后端服务打交道。\nNginx处理连接的流程\n首先Nginx在启动时，会解析配置文件，得到需要监听的端口与IP地址，然后在Nginx的master进程里面，先初始化好这个监控的socket（创建Socket， 设置Addrreuse等选项，绑定到指定的IP地址端口，再Listen），然后再fork出多个子进程出来，然后子进程会竞争accept新的连接。此时，客户端就可以向Nginx发起连接了。当客户端与服务端通过三次握手建立好一个连接后，Nginx的某一个子进程会Accept成功，得到这个建立好的连接的Socket，然后创建Nginx对连接的封闭，即ngx_connection_t结构体。接着，设置读写事件处理函数并添加读写事件来与客户端进行数据的交换。最后，Nginx或客户端主动关掉连接，到此，一个连接就结束了。 Nginx在实现时，是通过一个连接池来管理的，这里的连接池里保存的其实不是真实的连接，它只是一个worker_connections(不大于系统对fd的限制)大小的ngx_connection_t结构体的数组。并且，Nginx会通过一个链表free_connections来保存所有的空闲ngx_connection_t，每次获取一个连接时，就从空闲连接链表里获取一个，用完后，再放回空间连接链表里。\nrequest\n在Ningx中request我们指的是http请求，具体到Nginx中的数据结构是ngx_http_request_t。它是对一个Http请求的封装。\n指令 server 用于定义服务，http中可以有多个server块\nlisten 指定服务器侦听请求的IP地址和端口，如果省略地址，服务器将侦听所有地址，如果省略端口，则使用标准端口\nserver_name 服务名称，用于配置域名使用_表示不做域名匹配.\nlocation 用于配置映射路径uri对应的配置，一个server中可以有多个location, location后面跟一个uri,可以是一个正则表达式，/表示匹配任意路径，当客户端访问的路径满足这个uri时就会执行location块里的代码\n修饰符\n= 进行普通字符精确匹配。也就是完全匹配 ^~ 前缀匹配。如果匹配成功，则不再匹配其他location. ~ 表示执行一个正则匹配，区分大小写 ~* 表示执行一个正则匹配，不区分大小写 xxx 常规字符串路径匹配 / 通用匹配， 任何请求都会匹配到 检查顺序\nlocation = \u0026gt; location 完整路径 \u0026gt; location ^~ \u0026gt; location ~, ~* \u0026gt; location 部分起始路径 \u0026gt; / 注意： location的优先级与location配置的位置无关\n正则表达式\n.: 匹配除换行符以外的任意字符 ?: 重复0次或1次 ?+: 重复1次或更多次 * : 重复0次或更多次 \\d: 匹配数字 ^: 匹配字符串的开始 $: 匹配字符串的结束 {n}: 重复n次 {n,}: 重复n次或更多次 (a|b|c): 竖线表示匹配任意一种情况，每种情况使用竖线分隔，一般使用小括号括住，匹配符合a字符或b字符或是c字符的字符串小括号()之间匹配的内容，可以在后面通过$1来引用，$2表示的是前面第二个()里的内容。 \\: 用于转义特殊字符 root root指令用于设置请求的根目录，从而允许Nginx将传入的请求映射到文件系统上。\nserver { listen 80; server_name stonemind.cn; root /var/www/html; } index 设置首页， 当只访问server_name时后面不跟任何路径是不走直接走index指令的。如果访问路径中没有指定具体的文件，则返回index设置的资源。\nset 自定义变量\nset $doc_root /usr/local/var/www; proxy_pass 反向代理（Reverse Proxy)\n反向代理方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。反向代理使用proxy_pass指令来实现。\nserver { listen 80; server_name localhost; location / { proxy_pass http://localhost:8081; proxy_set_header Host $host:$server_port; # 设置用户IP地址 proxy_set_header X-Forwarded-For $remote_addr; } } upstream 负载均衡策略\nPR(round robin: 轮询默认) upstream web_servers { server localhost:8081; server localhost:8082; } server { listen 80; server_name localhost; #access_log logs/host.access.log main; location / { proxy_pass http://web_servers; # 必须指定Header Host proxy_set_header Host $host:$server_port; } } 权重 # 4次请求只有一次被分配到8081上，其他3次分配到8082上。backup是指热备，只有当8081和8082都宕机的情况下才走8083 upstream test { server localhost:8081 weight=1; server localhost:8082 weight=3; server localhost:8083 weight=4 backup; } ip_hash 上面的2种方式都有一个问题，那就是下一个请求来的时候请求可能分发到另外一台服务器，当我们的程序不是无状态的时候，这时候就有一个很大的问题了，比如把登记信息保存到了session中，那么中转到另外一台服务器的时候就需要重新登录了，所以很多时候我们需要一个客户只访问一个服务器， 那么就需要用ip_hash了，ip_hash的每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 upstream test { ip_hash; server localhost:8080; server localhost:8081; } fair(第三方) 按后端服务器的响应时间来分配请求，响应时间短的优先分配。 upstream backend { fair; server localhost:8080; server localhost:8081; } url_hash(第三方) 按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法 upstream backend { hash $request_uri; hash_method crc32; server localhost:8080; server localhost:8081; } return 返回http状态码和可选的每二个参数（可重定向的URL）\nlocation /permantly/moved/url { return 301 http://wwww.example.com/moved/here; } rewrite 重写URI请求 rewrite，通过使用rewrite指令在请求处理期间多次修改请求URI，该指令具有一个可选参数和两个必需参数。第一个(必需)参数是请求URI必须匹配的正则表达式。第二个参数是用于替换匹配URI的URI。可选的第三个参数是可以停止进一步重写指令的处理或发送重定向(代码301或302)的标志\nlocation /users/ { rewrite ^/users/(.*)$ /show?user=$1 break; } error_page 使用error_page指令，您可以配置NGINX返回自定义页面以及错误代码，替换响应中的其他错误代码，或将浏览器重定向到其他URI。在以下示例中，error_page指令指定要返回404页面错误代码的页面(/404.html)。\nerror_page 404 /404.html; 日志 访问日志：需要开启压缩 gzip on; 否则不生成日志文件，打开log_format、access_log注释\nlog_format main '$remote_addr - $remote_user [$time_local] \u0026quot;$request\u0026quot; ' '$status $body_bytes_sent \u0026quot;$http_referer\u0026quot; ' '\u0026quot;$http_user_agent\u0026quot; \u0026quot;$http_x_forwarded_for\u0026quot;'; access_log /usr/local/etc/nginx/logs/host.access.log main; gzip on; deny # 禁止访问某个目录 location ~* \\.(txt|doc)${ root $doc_root; deny all; } 内置变量 nginx的配置文件中可以使用的内置变量以美元符$开始，也有人叫全局变量。其中，部分预定义的变量的值是可以改变的。另外，关注Java知音公众号，回复“后端面试”，送你一份面试题宝典！ $args ：#这个变量等于请求行中的参数，同$query_string $content_length ：请求头中的Content-length字段。 $content_type ：请求头中的Content-Type字段。 $document_root ：当前请求在root指令中指定的值。 $host ：请求主机头字段，否则为服务器名称。 $http_user_agent ：客户端agent信息 $http_cookie ：客户端cookie信息 $limit_rate ：这个变量可以限制连接速率。 $request_method ：客户端请求的动作，通常为GET或POST。 $remote_addr ：客户端的IP地址。 $remote_port ：客户端的端口。 $remote_user ：已经经过Auth Basic Module验证的用户名。 $request_filename ：当前请求的文件路径，由root或alias指令与URI请求生成。 $scheme ：HTTP方法（如http，https）。 $server_protocol ：请求使用的协议，通常是HTTP/1.0或HTTP/1.1。 $server_addr ：服务器地址，在完成一次系统调用后可以确定这个值。 $server_name ：服务器名称。 $server_port ：请求到达服务器的端口号。 $request_uri ：包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。 $uri ：不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。 $document_uri ：与$uri相同\n","permalink":"https://stoneepigraph.github.io/posts/middle/nginx-note/","title":"Nginx-note"},{"content":" 数据结构与算法 解压序列赋值给多个变量 注意_, /, /_, 级别的使用\n保留最后N个元素 collections deque\n查找最大或最小的N个元素 heapq.nlargest(count, list) heapq.nsmallest(count, list)\n实现一个优先级队列 heapq.heappush() heapq.heappop()\n字典中的键映射多个值 可以将多个值放到另外的容器中。也可以全用collections模块中的defaultdict来构造这样的字典\n字典排序 可以使用collections模块中的OrderedDict类，它会保持元素被插入时的顺序。\n字典的运算 对字典运算，通常需要使用zip()函数先将键值反转过来。\nzip(dict.values(), dict.keys())\n可以使用sorted()对反转后的字典进行排序。因为你在一个字典上执行普通的数字运算，它们仅仅作用于键，而不是值 。\n查找两个字典的相同点 可以简单的在两字典的keys()或者items()方法返回结果上执行集合操作。\n删除序列相同元素并保持顺序 如果序列上的值都是hashable类型，那么可以简单的利用集合或者生成器来解决问题。\n命令切片 使用s = slice(start, stop, step)避免大量无法理解 的硬编码下标。你还可以使用s.start, s.stop, s.step获取它的属性。\n序列中出现次数最多的元素 collections.Counter类\nwords = [\u0026hellip;] from collections import Counter word_counts = Counter(words) #出现频率最高的3个单词 top_three = word_counts.most_common(3)\nCounter实例还可以很容易的跟数学运算操作相结合。\n通过一个关键字排序一个字典列表 通过全用operator模块的itemgetter函数。\nrows = [ {'fname': 'Brian', 'lname': 'Jones', 'uid': 1003}, {'fname': 'David', 'lname': 'Beazley', 'uid': 1002}, {'fname': 'John', 'lname': 'Cleese', 'uid': 1001}, {'fname': 'Big', 'lname': 'Jones', 'uid': 1004} ] from operator import itemgetter rows_by_fname = sorted(rows, key=itemgetter('fname')) rows_by_uid = sorted(rows, key=itemgetter('uid')) rows_by_lfname = sorted(rows, key=itemgetter('lname', 'fname')) # itemgetter也可以使用lambda表达式代替 rows_by_fname_lambda = sorted(rows, key=lambda r: r['fname']) rows_by_lfname_lambda = sorted(rows, key=lambda r: (r['lname'], r['fname'])) 排序不支持原生比较的对象 class User: def __init__(self, user_id): self.user_id = user_id def __repr__(self): return 'User({})'.format(self.user_id) def sort_notcompare(): users = [User(23), User(3), User(99)] print(users) print(sorted(users, key=lambda u: u.user_id)) # 或者使用operator from operator import attrgetter sorted(users, key=attrgetter('user_id')) 通过某个字段将记录分组 rows = [ {'address': '5412 N CLARK', 'date': '07/01/2012'}, {'address': '5148 N CLARK', 'date': '07/04/2012'}, {'address': '5800 E 58TH', 'date': '07/02/2012'}, {'address': '2122 N CLARK', 'date': '07/03/2012'}, {'address': '5645 N RAVENSWOOD', 'date': '07/02/2012'}, {'address': '1060 W ADDISON', 'date': '07/02/2012'}, {'address': '4801 N BROADWAY', 'date': '07/01/2012'}, {'address': '1039 W GRANVILLE', 'date': '07/04/2012'}, ] from operator import itemgetter from itertools import groupby # Sorted by the desired field first, because groupby only check continuous elements. rows.sort(key=itemgetter('date')) # Iterate in groups for date, items in groupby(rows, key=itemgetter('date')): print(date) for in in items: print(' ', i) 过滤序列元素 最简单的过滤序列元素的方法就是使用列表推导。\nn for n in list if n \u0026gt; 0\n但是使用时会占用大量内存。如果你对内存比较敏感，那么你可以使用生成器表达式迭代产生过滤的元素。\npos = (n for n in list if n \u0026gt; 0) for x in pos: ​print(x)\n有时候过滤规则比较复杂，不能简单的在列表推导 或者生成器表达式中表达出来。这时候你可以将过滤代码放到一个函数中，然后使用内建的filter()函数。\nvalues = ['1', '2', '### 3', '### ', '4', 'N/A', '5'] def is_int(val): try: x = int(val) return True except ValueError: return False ivals = list(filter(is_int, values)) print(ivals) # Outputs ['1', '2', '### 3', '4', '5'] 另外一个值得关注的过滤工具就是itertools.compress()，它以一个iterable对象和一个相对应的Boolean选择器序列作为输入参数。然后输出 iterable对象中对应选择器为True的元素。当你需要用另外一个相关联的序列来过滤某个序列的时候，这个函数是非常有用的。\naddresses = [ '5412 N CLARK', '5148 N CLARK', '5800 E 58TH', '2122 N CLARK' '5645 N RAVENSWOOD', '1060 W ADDISON', '4801 N BROADWAY', '1039 W GRANVILLE', ] counts = [ 0, 3, 10, 4, 1, 7, 6, 1] from itertools import compress more5 = [n \u0026gt; 5 for n in counts] more5 [False, False, True, False, False, True, True, False] list(compress(addresses, more5)) # output ['5800 E 58TH', '4801 N BROADWAY', '1039 W GRANVILLE'] 从字典中提取子集 最简单的方式是使用字典推导。\nprices = { 'ACME': 45.23, 'AAPL': 612.78, 'IBM': 205.55, 'HPQ': 37.20, 'FB': 10.75 } p1 = {key: value for key, value in prices.items() if value \u0026gt; 200} 通过创建一个元组序列然后把它传给dict()函数也能实现\np1 = dict((key, value) for key, value in prices.items() if value \u0026gt; 200) 映射名称到序列元素 想通过名称来访问元素，可以使用collections.namedtuple()函数。这个函数实际上是一个返回Python中标准元组类型子类的一个工厂方法。你需要传递一个类型名和你需要的字段给它，然后它就会返回一个类，你可以初始化这个类为你定义的字段传递值等。\nfrom collections import namedtuple Subscriber = namedtuple('Subscriber', ['addr', 'joined']) sub = Subscriber('stoneepigraph@163.com', '2018-01-01') sub.addr # stoneepigraph@163.com 命名元组的 一个主要用途是将你的代码从下标操作中解脱出来。命名元组另一个用途就是作为字典的替代，因为字典存储需要更多的内存空间。但命名空间不能像字典那样可修改。如果你真的需要改变属性，那么你可以使用命名元组实例的_replace()方法。\n转换并同时计算数据 你如果需要在数据序列上执行聚集函数（sum(), min(), max()等），首先你需要先转换或者过滤数据。最好的方法就是使用一个生成器表达式参数。\nnums = [1,2,3,4,5] s = sum(x * x for x in nums) 合并多个字典或映射 使用collections模块中的ChainMap类。\nfrom collections import ChainMap c = ChainMap(a, b) print(c['key']) 一个ChainMap接受多个字典并将它们在逻辑上变为一个字典。如果出现重复键，那么第一次出现的映射会被返回。 p## 字符串和文本\n使用多个界定符分割字符串 string的split()方法只适应于非常简单的单分隔符。当你需要更加灵活的切割字符串时最好使用re.split(r\u0026rsquo;')\n字符串开头或结尾匹配 str.startswith()或者是str.endswith()方法如果你想检查多种匹配可能，只需要将所有的匹配项放入到一个元组中去，然后传给startswith或endswith. 也可以使用字符串切片来处理。更可以使用正则表达式实现。\n用Shell通配符匹配字符串 fnmatch模块提供了两个函数：fnmatch()和fnmatchcase()\n字符串匹配搜索 使用正则表达式。re.match()， re.findall()\n字符串搜索和替换 对于简单的字面模式，直接使用str.replace()方法即可。对于复杂的模式，需要使用re模块中的sub()函数。\nimport re re.sub(r'old', r'new', str) import re # 预编译正则提升性能 datepat = re.compile(r'(\\d+)/(\\d+)/(\\d+)') datepat.sub(r'\\3-\\1-\\2', str) 对于更复杂的替换，可以传递一个替换回调函数来代替\nfrom calendar import month_abbr def change_date(m): mon_name = month_abbr[int(m.group(1))] return \u0026quot;{} {} {}\u0026quot;.format(m.group(2), mon_name, m.group(3)) datepat.sub(change_date, str) 如果替换后的结果外，你还想知道有多少替换发生了，可以使用re.subn()来代替。\nnewtest, n = datepat.subn(r'\\3-\\1-\\2', str) # newtest：新字符串，n：替换次数 字符串忽略大小写的搜索替换 在使用re模块的时候给这些操作提供re.IGNORECASE标志参数。\nre.findall('python', 'java', flags=re.IGNORECASE) 最短匹配模式 在模式中的*/+操作符后面加上?修饰符。即使匹配变成 非贪婪模式。\n多行匹配模式 re.compile()函数接受一个标志参数叫re.DOTALL,它可以让正则表达式中的(.)匹配包括换行符在内的任意字符。\ncomment = re.compile(r'/\\*(.*?)\\*/', re.DOTALL) comment.findall(str) 删除字符串中不需要的字符 strip([\u0026lsquo;xxx\u0026rsquo;]) lstrip(\u0026rsquo;\u0026rsquo;) rstrip(\u0026rsquo;\u0026rsquo;)\n审查清理文本字符串 str.translate()\n字符串对齐 ljust() rjust() center() format()\n合并拼接字符串 如果想合并的字符串是在一个序列或者iterable中，那么最快的方式就是使用join()方法。简单的合并几个字符串可以直接使用加号 。\n字符串中插入变量 可以使用format方法。\n以指定列宽格式化字符串 使用textwrap模块来格式化字符串的输出。\ntextwrap.fill(str, num)\n获取终端的大小 import os os.get_terminal_size().columns 在字符串中处理html和xml html.escape()可以很容易的将html或xml中的\u0026lt;、\u0026gt;、\u0026amp;做转换成\u0026gt;\u0026hellip;.\n字符串令牌解析 使用正则表达式做匹配。\n实现一个简单递归下降分析器 。。。没看懂\n字节字符串上的字符串操作 数字日期和时间 数字的四舍五入 对于简单的传入 运算，使用内置的round(value, ndigits)函数即可。对一个值刚好在两个边界的中间的时候，round函数返回离它最近的偶数。\n执行精确的浮点数运算 使用decimal模块\na = decimal('4.2') b = decimal('2.1') a + b 数字的格式化输出 可以使用内置的format()函数。\n二八十六进制整数 bin() oct() hex() 如果不想显示前缀的话，可以使用format()函数。\n字节到大整数的打包与解包 ？？？\n复数的数学运算 复数可以使用函数complex(real, imag)或者是带有后缀j的浮点数来指定。\na = complex(2,4) b = 3 - 5j 所有觉的数学运算都可以对复数运算。\n无穷大与NaN 可以使用float()来创建。\na = float('inf') b = float('-inf') c = float('nan') 分数运算 fractions模块可以被用来执行包含分数的数学运算。\nfrom fractions import Fraction a = Fraction(5,4) b = Fraction(7, 16) a + b 大型数组运算 涉及到数组的重量级运算操作，可以使用NumPy库。\n矩阵与线性代数运算 NumPy\n随机选择 random模块有大量的函数用来产生随机数和随机选择元素。 random.choice(list)随机选择一个 random.sample(list, num)随机选择num个 random.shuffle(list)打乱顺序 random.random()： 生成0-1范围内均匀分布的浮点数。 random.getrandbits(num): 获取N位随机位（二进制）的整数。\n基本的日期与时间转换 为了执行不同的时间单位 的转换和计算，请使用datetime模块。比如，为了表示一个时间段，可以创建一个timedelta实例。对于大多数基本的日期和时间处理问题，datetime模块足够了。如果你需要执行更加复杂的日期的操作，比如处理时区，节假日计算等，可以考虑dateutil模块。\n字符串转换为日期 datetime.strptime(str, partition)\n迭代器与生成器 手动遍历迭代器 e.g.\ndef manual_iter(): with open('/etc/passwd') as f: try: while True: line = nex(f) print(lie, end='') except StopIteration: pass 代理迭代 你构建了一个自定义容器对象，里面包含有列表、元组或其他可迭代对象。你想直接在你的这个新容器对象上执行迭代操作。 e.g.\nclass Node: def __init__(self, value): self._value = value self._children = [] def __repr__(self): return \u0026quot;Node({!r})\u0026quot; .format(self._value) def add_child(self, node): self._children.append(node) def __iter__(self): return iter(self._children) 使用生成器创建新的迭代模式 如果你想实现 一种新的rwwasaa,wget一个生成器函数来定义它。下面是一个生产某个范围内浮点数的生成器：\ndef frange(start, stop, increment): x = start while x \u0026lt; stop： yield x x += increment **一个函数只需要有一个yield语句即可将其转换为一个生成器。跟普通函数不同的是，生成器只能用于迭代操作。\n反向迭代 使用内置的reversed()函数。反向迭代公公当对象的大小可预先确定或者对象实现了_/reversed_/()函数的特殊方法时才能生效。如果两者都不符合，那么你必须先将对象转换成一个列表才行。\n排列组合的迭代 itertools模块提供了三个函数来解决这个问题。 itertools.permutations(items, num):它接受一个集合并产生一个元组序列，每个元组由集合中所有元素的一个可能排列组成。items为预集合，num为生成的元组的长度。 itertools.combinations(items, num): 可得到输入集合的所有的组合 。 itertools.combinations.with_replacement(): 允许同一个元素被选择多次。\n序列上索引值迭代 内置的enumerate()函数可以很好的解决。\nlist = ['a', 'b', 'c'] start_num = 0 for idx, val in enumerate(list, start_num): print(idx, val) ... 0 a 1 b 2 c 同时迭代多个序列 使用zip()函数 zip(a, b)会生成一个可返回元组(x, y)的迭代器，其中x来自a，y来自b。\n不同集合上元素的迭代 如果想对不同容器中的对象执行同样操作。在代码不失可读性的情况下避免写重复的循环。\nfrom itertools import chain a = [1,2,3,4,5] b = ['x', 'y', 'z'] for x in chain(a, b): print(x) 创建数据处理管道 ？？？\n展开嵌套的序列 可以写一个包含yield from 语句的递归生成器业轻松解决。\nfrom collections import Iterable def flatten(items, ignore_types=(str, bytes)): for x in items: if isinstance(x, Iterable) and not isinstance(x, ignore_types): yield from flatten(x) else: yield x items = [1,2,[3,4,[5,6],7],8] for x in flatten(items): print(x) 顺序迭代合并后的排序迭代对象 heapq.merge()\nimport heapq a = [1,2,4,5] b = [3,6,7,8] for c in heapq.merge(a,b): print(c) 强调：heapq.merge()需要所有输入序列那也得是排过序的。\n迭代器代替while无限循环 import sys f = open('/etc/passwd') for chunk in iter(lambda: f.read(10), ''): n = sys.stdout.write(chunk) 文件与IO 读写文本数据 使用系统自带的open()函数读取文件。\nwith open('somefile.txt', 'rt') as f: data = f.read() with open('sonefile.txt', 'rt'): for line in f: print(line) with open('somefile.txt', 'wt') as f: f.write(text1) 读取文本文件使用rt模式，写入文件使用wt模式，追加文件使用at\n打印输出至文件中 在print()函数中指定file关键字参数，可以输出到文件。\nwith open('/usr/local/temp.txt', 'wt') as f: print('Hello World!', file=f, sep=',', end='\\n') 读写字节数据 使用模式为rb或wb的open()函数可以来读取或写入二进制数据。\nwith open('somefile.bin', 'rb') as f: data = f.read(16) text = data.decode('utf-8') with open('somefile.bin', 'wb') as f: text = 'Hello World' f.write(text.encode('utf-8')) 二进制I/O有一个特性就是数组和C结构体类型能直接被写入，而不需要中间转换为自己的对象。\nimport array nums = array.array('i', [1,2,3,4]) with open('data.bin', 'wb') as f: f.write(nums) a = array.array('i', [0,0,0,0,0,0,0]) with open('data.bin', 'rb') as f: f.readinto(a) 文件不存在时才能写入 可以在open()函数中使用x模式来代替w模式的方法来解决。\n字符串的I/O操作 使用io.StringIO()和io.BytesIO()类来创建类文件对象操作字符串数据。\n读写压缩文件 可以使用gzip和bz2模块处理这些文件\nimport gzip import bz2 with gzip.open('somefile.gz', 'rt') as f: text = f.read() with bz2.open('somefile.bz2', 'rt') as f: text = f.read() with gzip.open('somefile.gz'. 'wt') as f: f.write(text) with bz2.open('somefile.bz2', 'wt') as f: f.write(text) gzip和bz2的open函数跟内置的函数一样包括encoding, errors, newline等可选参数。\n固定大小记录的文件迭代 from functools import partial RECORD_SIZE = 32 with open('somefile.data', 'rb') as f: records = iter(partial(f.read, RECORD_SIZE), b'') for r in record: ... 读取二进制数据到可变缓冲区 import os.path def read_into_buffer(filename): buf = bytearray(os.path.getsize(filename)) with open(filename, 'rb') as f: f.readinto(buf) return buf 内存映射的二进制文件 使用mmap模块\n文件路径名的操作 使用os.path模块中的函数来操作路径名。\n测试文件是否存在等 # 测试文件是否存在 os.path.exists(filename) # 测试文件是否是一个文件 os.path.isfile(filename) # 测试文件是否是一个目录 os.path.isdir(filename) # 测试文件是否是一个链接文件 os.apth.islink(filename) # 获取文件的大小 os.path.getsize(filename) # 获取文件的修改时间 os.path.getmtime(filename) 使用os.path需要考虑文件的权限问题\n获取文件夹中的文件列表 使用os.listdir()函数来获取某个目录中的文件列表\nimport os names = os.listdir(dirname) # 获取所有的py文件 pyfiles = [name for name in os.listdir(dirname) if name.endswith('.py')] # 使用glob或fnmatch模块获取所有py文件 import glob pyfiles = glob.glob('dirname/*.py') from fnmatch import fnmatch pyfile = [name for name in os.listdir(dirname) if fnmatch(name, '*.py')] 忽略文件名编码 默认情况下，所有的文件名都会根据sys.getfilesystemencoding()返回的文本编码来编码或解码。如果因为某种原因你想忽略这种编码，可以使用一个原始字节字符串来指定一个文件名即可。\n打印不合法文件名 def bad_filename(filename): return repr(filename)[1:-1] try: print(filename) except UnicodeEncodeError: print(bad_filename(filename)) 增加或改变已打开文件的编码 如果你想修改一个已经打开的文本模式的文件的编码方式，可以先使用detch()方法移除掉已存在的文本的编码层，并使用新的编码方式代替\nimport sys sys.stdout = io.TextIOWrapper(sys.stdout.detach(), encoding='latin-1') I/O系统以层级结构的形式萏而成。文本文件是通过在一个拥有缓冲的二进制模式文件上增加一个Unicode编码/解码层来创建。Buffer属性指向对应的底层文件。如果你直接访问它的话会绕过文本编码/解码层。\n将文件描述 符包装成文件对象 一个文件描述符和一个打开的普通文件是不一样的。文件描述符仅仅是一个由操作系统指定的整数，用来指代某个系统的I/O通道。如果你碰巧有这么一个文件描述符，你可以通过使用open()函数来将其包装为一个Python的文件对象。 e.g.\nimport os fd = os.open('somefile.txt', os.O_WRONLY | os.O_CREATE) f = open(fd, 'wt') f.write('hello world') f.close() 当高层的文件对象被关闭或者破坏的时候，底层的文件描述符也会被关闭。\n创建临时文件和文件夹 tempfile模块中有很多的函数可以完成这个任务\nfrom tempfile import TemporaryFile with TemporaryFile('w+t') as f: ... TemporaryFile另外还支持跟内置的open()函数一样的参数。在大多数Unix系统上。通过TemporaryFile()创建的文件都是匿名的。文件关闭的时候就会自动删除文件。 tempfile.TemporaryDirectory()可以创建临时目录\n与串行端口的数据通信 典型的场景就是和一些硬件设备打交道。尽管可以使用Python内置的I/O模块来完成。但对于串行通信最好的选择是使用pySerial包。\nimport serial ser = serial.Serial('/dev/tty.usbmodem641', baudrate=9600, bytesize=8, parity='N', stopbits=1) 一旦端口打开，就可以使用read(), readline()，write()函数读写数据了。\n序列化Python对象 对于序列化最普遍做法就是使用pickle模块。\nimport pickle data = .. f = open('somefile', 'wb') pickle.dump(data, f) 为了将一个对象转储为字符串，可以使用pickle.dumps() 为了从字节流中恢复一个对象，使用pickle.load()或pickle.loads()函数。\n数据编码和处理 读写CSV文件 import csv with open('csv.csv') as f: f_csv = csv.read(f) # 读取头 headers = nex(f_csv) for row in f_csv: # TODO Parse import csv headers = [...] rows = [(...),(...)] with open('csv.csv', 'w') as f: f_csv = csv.writer(f) f_csv.writerow(headers) f_csv.writerows(rows) 读写JSON数据 json模块的json.dumps和json.loads方法。可以使用pprint模块的pprint()函数来代替普通的print函数打印json.\n解析简单的XML数据 可以使用xml.etree.ElementTree模块从简单的XML文档中提取数据。\nfrom xml.etree.ElementTree import parse xml.etree.ElementTree.parse()函数解析整个XML文档并将其转换成一个文档对象。然后就可以使用find(), iterfind()和findtext()等方法来搜索特定的XML元素。而且ElementTree模块中的每个元素有一些重要的属性和方法。\n增量式解析大型XML文件 e.g.\nfrom xml.etree.ElementTree import iterparse def parse_and_remove(filename, path): path_parts = path.split('/') doc = iterparse(filename, ('start', 'end')) # Skip the root element next(doc) tag_stack = [] elem_stack = [] for event, elem in doc: if event == 'start': tag_stack.append(elem.tag) elem_stack.append(elem) elif event == 'end': if tag_stack == path_parts: yield elem elem_stack[-2].remove(elem) try: tag_stack.pop() elem_stack.pop() except IndexError: pass from collections import Counter potholes_by_zip = Counter() data = parse_and_remove('potholes.xml', 'row/row') for pothole in data: potholes_by_zip[pothole.findtext('zip')] += 1 for zipcode, num in potholes_by_zip.most_common(): print(zipcode, num) 将字典转换成XML from xml.etree.ElementTree import Element def dict_to_xml(tag, d): elem = Element(tag) for key , val in d.items(): child = Element(key) child.next = str(val) elem.append(child) return elem 如果你想给某个元素添加属性值，可以使用set()方法。如果值的字符串中含有特殊字符，可以使用xml.sax.saxutils中的escape()和unescape()函数。\n解析和修改XML 使用xml.etree.ElementTree import parse,Element\n利用命名空间解析 XML文档 。。。\n与关系型数据库的交互 。。。\n编码和解码十六进制数 可以使用binascii.b2a_hex(str)或者base64.b16encode(s)\n编码解码Base64数据 使用base64模块中的两个函数b64encode() 和 b64decode()。 Base64编码仅仅用于面向字节的数据比如字节字符串和字节数组。此外，编码处理的输出结果总是一个字节字符串。如果你想混合使用Base64编码的数据和Unicode文本，你必须添加一个额外的解码步骤。\na = base64.b64encode(str).decode('ascii') 当解码Base64的时候，字节字符串和Unicode文本都可以作为参数。但Unicode字符串只能包含ASCII字符。\n读写二进制数组数据 可以使用struct模块处理二进制数据。。。。\n读取嵌套和可变长二进制数据 。。。\n数据的累加与统计操作 对于任何涉及到统计，时间序列以及其他相关技术的数据分析问题，都可以考虑使用Pandas库。\n函数 可接受任意数量参数的函数 e.g.\ndef avg(first, *other)： pass def kwargs(first, second, **kwargs): pass 只接受关键字参数的函数 将强制关键字参数放到某个/参数或者单个/后面就可以\ndef recv(maxsize, *, block): pass 给函数参数增加元信息 def add(x:int, y:int) -\u0026gt; int: return x + y 返回多个值的函数 def myfun(): return 1,2,3 实际上是返回了一个元组。\n定义有默认参数的函数 def spam(a, b = 42): pass 首先，默认参数的值仅仅在函数定义的时候赋值一次。其次，默认参数的值应该是不可变的对象。\n定义匿名或内联函数 使用lambda表达式来替代。\n匿名函数捕获变量值 lambda表达式中的变量是一个自由变量，在运行时绑定值，而不是定义时绑定。\n减少可调用对象 的参数个数 使用functools.partial()将参数固定并返回一个新的可调用 函数\ndef spam(a,b,c,d)： print(a,b,c,d) from functools import partial s1 = partial(spam,1) s1(2,3,4) \u0026gt; 1,2,3,4 将单方法类转换为函数 def urltemplate(template): def opener(**kwargs): return urlopen(template.format_map(kwargs)) return opener 带额外状态信息的回调函数 pass\n内联回调函数 pass\n访问闭包中的变量 pass\n类与对象 改变对象的字符串显示 要改变一个实例的字符串表示，可重新定义 它的_str_() 和_repr_()方法\n自定义字符串的格式化 为了自定义字符串的格式化，我们需要在类上面定义一个_/format_/()方法。\nclsas Date: def __init__(self, year, month, day): self.year = year self.month = month self.day = day def __format__(self, code): if code == '': code = 'ymd' fmt = _formats[code] return fmt.format(d = self) 让对象支持上下文协议 使用with语句为了让一个对象兼容with语句，你需要实现_enter_()和_exit_()方法。\n创建大量对象时节省内存方法 可以通过给类添加__slots__属性来减少实例所占的内存。Python就会为实例使用一种更加紧凑的内部表示。通过一个很小的固定大小的数组来构建，而不是为每个实例定义一个字典。\n在类中封装属性名 Python程序员不去依赖语言特性去封装数据，而是通过遵循一定的属性和方法命名规约来达到这个效果。\n任何以单下划线开头的名字都应该是内部实现。 使用双下划线开始会导致访问名称变成其他形式。这种属性通过继承是无法被覆盖的。 创建可管理的属性 自定义某个属性的一种简单方法是将它定义为一个property. e.g.\nclass Person: def __init__(self, first_name): self.first_name = first_name @property def first_name(self): return self.first_name @first_name.setter def first_name(self, value): if not isinstance(value, str): raise TypeError('Expected a string') self._first_name = value @first_name.deleter def first_name(self): raise AttributeError(\u0026quot;Can't delete attribute\u0026quot; ) property的一个关键特征是它看上去跟普通的attribute没什么两样，但是访问它的时候会自动触发getter，setter和deleter方法。\n调用父类方法 为了调用父类的一个方法，可以使用super()函数。\n子类中扩展property 因为一个property是getter，setter和deleter方法的集合，而不是单个方法。因此，扩展一个property的时候，你需要先确定你是否要重新定义所有的方法还是说只修改其中的某一个。\n创建亲的类或实例属性 可以通过一个描述器类的形式来定义 它的功能 。一个描述器就是一个实现了三个核心属性访问操作（get, set, delete)的类。分别为_get_(), set(), delete(). 。。。\n使用延迟计算属性 。。。\n简化数据结构的初始化 。。。\n定义接口或者抽象基类 使用abc模块可以很轻松的定义抽象基类抽象类的一个特点是它不能直接被实例化，得让别的类继承并实现特定的抽象方法。主要用途是在代码中检查类是否为特定类型。\n实现数据模型的类型约束 。。。\n实现自定义容器 collections定义了很多抽象类。比如你想让你的类支持迭代，那就让你的类继承collections.Iterable即可。\n属性的代理访问 。。。\n在类中定义多个构造器 你想实现一个类，除了使用_init_()方法外，还有其他方式可以初始化它。你需要使用到类方法。\n创建不调用init方法的补全 可以通过_new_()方法创建一个未初始化的实例。\n利用Mixins扩展类功能 。。。\n实现状态对象 或者状态机 将每个状态抽取出来定义成一个类。\n通过字符串调用对象方法 使用operator.methodcaller。\n实现访问者模式 。。。\n不使用递归实现访问者模式 。。。\n循环引用数据结构的内存管理 可以考虑使用weakref库中的弱引用\n让类支持比较操作 Python类对每个比较操作都需要实现一个特殊方法来支持，例如为了支持\u0026gt;=操作符，你需要定义一个_ge_()方法。装饰器functools.total_ordering可以简化这个处理。使用它来装饰一个类，你只需要定义一个_eq_()方法，外加其他方法（lt, le, gt, or ge）中的一个即可。然后装饰器会自动为你填充其它比较方法。\n创建缓存实例 通常是因为你希望相同参数创建的对象时是单例的。为了达到这样的效果，你需要使用一个和类本身分开的工厂函数。 e.g.\nclass Spam: def __init__(self, name): self.name = name import weakref _spam_cache = weakref.WeakValueDictionary() def get_spam(name): if name not in _spam_cache: s = Spam(name) _spam_cache[name] = s else: s = _spam_cache[name] return s 元编程 在函数上添加包装器 如果你想使用额外的代码包装一个函数，可以定义一个装饰器函数。 e.g.\nimport time from functools import wraps def timethis(func): ''' Decorator that reports the execution time. ''' @wraps(func) def wrapper(*args, **kwargs): start = time.time() result = func(*args, **kwargs) end = time.time() print(func.__name__, end-start) return result return wrapper @timethis def countdown(n): ''' Counts down ''' while n \u0026gt; 0: n -= 1 一个装饰器就是一个函数，它接受一个函数作为参数并返回一个新的函数。\n创建装饰器时保留函数元信息 任何时间你定义装饰器的时候，都应该使用functools的@wraps装饰器来注解底层包装函数。\n解除一个装饰器 假设装饰器是通过@wraps来实现的，那么你可以通过访问__wrapped__属性来访问原始函数。\n定义一个带参数的装饰器 e.g.\nfrom functools import wraps import logging def logged(level, name=None, message=None): ''' Add logging to a function. level is the logging level, name is the logger name, and message is the log message. If name and message aren't specified, they default to the function's module and name ''' def decorate(func): logname = name if name else func.__module__ log = logging.getLogger(logname) logmsg = message if message else func.__name__ @wraps(func) def wrapper(*args, **kwargs): log.log(level, logmsg) return func(*args, **kwargs) return wrapper return decorate @logged(logging.DEBUG) def add(x,y): return x + y @logged(loogging.CRITICSL, 'example') def spam(): print('Spam!!!') 自定义属性的装饰器 。。。\n利用装饰器强制函数上的类型检查 e.g. 作为编程规约，你想在对函数参数进行强制类型检查\n@typeassert(int, int) def add(x, y): return x + y from inspect import signature from funtools import wraps def typeassert(*ty_args, **ty_kwargs): def decorate(func): # If in optimized mode, disable type checking if not __debug__: return func # Map function argument names to supplied types 它运行你提取一个可调用对象的参数签名信息。 sig =signature(func) bound_types = sig.bind_partial(*ty_args, **ty_kwargs).arguments @wraps(func) def wrapper(*args, **wargs): bound_values = sig.bind(*args, **kwargs) # Enforce type assertions across supplied arguments for name, value in bound_values.arguments.items(): if name in bound_types: if not isinstance(value, bound_types[name]): raise TypeError( 'Argument {} must be {}'.format(name, bound_types[name]) ) return func(*args, **kwargs) return wrapper return decorate 将装饰器定义为类的一部分 你想在类中定义装饰器，并将其作用在其他函数或方法上\n将装饰器定义为类 为了将装饰器定义成一个实例，你需要确保它实现了_call_（）和_get_（）方法。 e.g.\nimport types from tunctools import wraps class Profiled: def __init__(self, func): wraps(func)(self) self.ncalls = 0 def __call__(self, *args, **kwargs): self.ncalls += 1 return self.__wrapped__(*args, **kwargs) def __get__(self, instance, cls): if instance is None: return self else: return types.MethodType(self, instance) 。。。\n为类和静态方法提供装饰器 给类或静态方法提供装饰器是很简单的，不过要确保装饰器在@classmethod或?? (????)。\n装饰器为被包装函数增加参数 。。。\n使用装饰器扩充类的功能 。。。\n使用元类控制实例的创建 。。。\n捕获类的属性定义顺序 。。。\n定义有可选参数的元类 。。。\n*args和**kwargs的强制参数签名 对任何涉及到操作函数调用签名的问题，你都应该使用inspect模块中的签名特性。我们最主要关注两个类：Signature和Parameter.\n在类上强制使用编程规约 如果你想监控类的定义，通常可以通过定义一个元类，一个基本元类通常是继承自type并重定义它的_new_()方法或是_init_()方法。为了使用这个元类，你通常要将它放到一个顶级父类定义中，然后其他的类继承这个顶级父类。\n以编程方式定义类 。。。\n在定义的时候初始化类的成员 。。。\n利用函数注解实现方法重载 。。。\n避免重复的属性方法 。。。\n定义上下文管理器的简单方法 实现一个新的上下文管理器的最简单的方法就是使用contextlib模块中的@contextmanager装饰器。。。。\n在局部变量域中执行代码 。。。\n解析与分析Python源码 。。。\n拆解Python字节码 dis模块可以被用来输出任何Python函数反编译结果。如果你想自己解释dis出的代码，你需要使用一些在opcode模块中定义 的常量。。。。\n模块与包 构建一个模块的层级包 在文件系统上组织你的代码，并确保每个目录都定义了一个_init_.py文件。\n控制模块被全部导入的内容 在模块或包中添加： all = [\u0026rsquo;\u0026rsquo;，\u0026rsquo;\u0026rsquo;，\u0026rsquo;\u0026rsquo;\u0026hellip;]，在使用import*时只会导入列表里的列举的内容。如果__all__包含未定义的名字，在导入时将引起AttributeError.\n使用相对路径 名导入包中子模块 e.g.\nfrom . import source from ..B import source 将模块分割成多个文件 原: mymodule.py文件\nclass A: def spam(self): print(\u0026quot;A spam\u0026quot;) class B(A): def bar(self): print('B spam') 假设你想mymodule.py分为两个文件，每个文件定义一个类。你需要用mymodule目录来替换文件mymodule.py。在这个目录下创建_init_。py, a.py和b.py三个文件。在a.py中插入a类的代码，在b.py中插入b类的代码。然后在_init_.py中插入如下代码\nfrom .a import A from .b import B 对于一个很大的模块，还需要做延迟导入。那么_init_.py将做如下修改\ndef A(): from .a import A return A() def B(): from .b import B return B() 延迟加载的主要缺点是继承和类型检查可能会中断。\n利用命名空间导入目录分散的代码 。。。\n重新加载模块 使用imp.reload(模块名)来重新加载先前加载的模块。\n运行目录或压缩文件 您有一个涉及多个文件的应用程序。你想有一些简单的方法让用户运行程序。你可以把你的应用程序放进它自己的目录并添加一个_main_.py文件。 e.g.\nmyapplication/ spam.py bar.py grok.py __main__.py 如果_main_.py存在，你可以简单地在顶级目录运行Python解释器\nbash $ python myapplication 解释器将执行_main_.py文件作为主程序。如果你将你的代码打包成zip文件，这种技术同样也适用。\n读取位于包中的数据文件 mypackage/ __init__.py somedata.dat spam.py 假设spam.py文件需要读取somedata.dat文件中的内容。\nimport pkgutil data = pkgutil.get_data(__package__, 'somedata.dat') 由此产生的变量是包含请该文件的原始内容的字节字符串。\n将文件夹加入到sys.path 写代码手动调节sys.path的值\nimport sys from os.path import abspath, join, dirname sys.path.insert(0, abspath(dirname('__file__'), 'src')) 通过字符串名导入模块 使用importlib.import_module()函数\nimport import lib math = importlib.import_module('math') math.sin(2) 通过钩子远程加载模块 。。。\n导入模块的同时修改模块 。。。\n安装私有的包 python setup.py install --user or pip install --user packagename 创建新的Python环境 可以使用pyvenv\u0026hellip;\n分发包 第一件是就是给它一个唯一的名字，并且清理它的目录结构。一个典型的函数库包会类似下面这样：\nprojectname/ README.txt Doc/ documentation.txt projectname/ __init__.py foo.py bar.py utils/ __init__.py spam.py grok.py examples/ helloword.py ... 要让你的包可以发布出去，首先你要编写一个setup.py。如：\nfrom distutils.core import setup setup(name='projectname', version='1.0', author='your name', author_email='your email', url='your url', packages=['projectname', 'projectname.utils'], ) 下一步，就是创建一个MANIFEST.in文件，列出所有在你包中需要包含进来的非源码文件。\ninclude *.txt recursive-include examples * recursive-include Doc * 确保setup.py和MAINIFEST.in文件放在你的包的最顶级目录中。一旦你已经做了这此地，你就可以像下面这样执行命令来创建一个源码分发包了：\nbash $ python setup.py sdist 它会创建一个文件比如“projectname-1.0.zip”或“projectname-1.0.tar.gz”.\n网络与WEB编程 作为客户端与HTTP服务交互 对于简单的事情来说，通常使用urllib.request模块就够了。 e.g.\nfrom urllib import request, parse url = 'https://www.baidu.com' params = { \u0026quot;search\u0026quot;: \u0026quot;123\u0026quot; } querystring = parse.urlencode(params) u = request.urlopen(url + \u0026quot;?\u0026quot; + querystring) resp = u.read() 如果你需要使用POST方法在请求主体中发送查询参数，可以将参数编码后作为可选参数提供给urlopen()函数。\nfrom urllib import request, parse url = 'http://httpbin.org/post' params = { 'name1': 'value1', 'name2': 'value2' } querystring = parse.urlencode(params) u = request.urlopen(url, querystring.encode('ascii')) resp = u.read() 如果你需要在以出的请求中提供一些自定义的HTTP头，可以创建一个包含字段值的字典，并创建一个Request实例然后将其传给urlopen()。例：\nfrom urllib import request, parse url = \u0026quot;\u0026quot; headers = { 'User-agent': 'none/ofyourbusiness', 'Spam': 'Eggs' } params = {} querystring = parse.urlencode(params) req = request.Request(url, querystring.encode('ascii'), headers=headers) u = request.urlopen(req) resp = u.read() 如果需要更复杂的请求，那么可以使用request库\n创建TCP服务器 创建一个TCP服务器的一个简单方法是使用socketserver库。 e.g.\nfrom socketserver import BaseRequestHandler, TCPServer class EchoHandler(BaseRequestHandler): def handle(self): print('Got connection from ', self.client_address) while True: msg = self.request.recv(8192) if not msg: break self.request.send(msg) if __name__ == '__main__': serv = TCPServer(('', 20000), EchoHandler) serv.serve_forever() socketserver可以让我们很容易的创建简单的TCP服务器。但是，它默认是单线程的，如果你想处理多个客户端，可以初始化一个ForkingTCPServer或是ThreadTCPServer对象.如：\nfrom socketserver import ThreadingTCPServer if __name__ == '__main__': serv = ThreadingTCPServer(('', 20000), EchoHandler) serv.serve_forever() 但是fork或线程服务器有个潜在问题就是它会为每个客户端连接创建一个新的进程或线程。由于客户端连接数是没有限制的，如果担心可以创建一个预先分配大小的工作线程池或进程池。例：\nif __name__ == '__main__': from threading import Thread NWORKERS = 16 serv = TCPServer(('', 20000), EchoHandler) for n in range(NWORKERS): t = Thread(target=serv.serv_forever) t.daemon = True t.start() serv.serve_forever() 创建UDP服务器 跟TCP一样，UDP服务器也可以通过使用socketserver库。\n通过CIDR地址生成对应的IP地址集 例CIDR网络地址： 123.45.67.64/27 转换成:123.45.67.64, 123.45.67.65\u0026hellip;. 可以使用ipaddress模块\nimport ipaddress net = ipaddress.ip_network('123.45.67.64/27') for a in net: print(a) 创建一个简单的REST接口 构建一个REST风格的接口最简单的方法是创建一个基于WSGI标准的很小的库。 e.g.\nimport cgi def notfound_404(environ, start_response): start_response('404 Not Found', [('Content-type', 'text/plain')]) return [b'NotFound'] class PathDispatcher: def __init__(self): self.pathmap = {} def __call__(self, environ, start_response): path = environ['PATH_INFO'] params = cgi.FieldStorage(environ['wsgi.input'], environ=environ) method = environ['REQUEST_METHOD'].lower() environ['params'] = {key: params.getvalue(key) for key in params} handler = self.pathmap.get((method, path), notfound_404) return handler(environ, start_response) def register(self, method, path, function): self.pathmap[method.lower(), path] = function return function 通过XML-RPC实现简单的远程调用 。。。\n在不同的Python解释器之间交互 通过使用multiprocessing.connection模块可以很容易的实现解释器之间的通信。\n实现远程方法调用 将函数请求，参数和返回值使用pickle编码后，在不同的解释器直接传送pickle字节字符串，可以很容易的实现RPC.\n简单的客户端认证 使用hmac模块。。。\n在网络服务中加入SSL ssl模块为底层socket连接添加SSL的支持。ssl.wrap.socket()函数接收一个已经存在的socket作为参数并使用SSL层来包装它。\n进程间传递Socket文件描述符 。。。\n理解事件驱动的IO 。。。\n发送与接收大型数组 。。。\n并发编程 启动与停止线程 import time def countdown(n): while n \u0026gt; 0: print('T-mins ', n) n -= 1 time.sleep(5) from threading import Thread t = Thread(target = countdown, argn(10,)) t.start() 你可以查询一个线程对象的状态，看它是否还在执行\nif t.is_al1ive(): print('Still running') else: print('completed') 你也可以将一个线程加入到当前线程，并等待它终止\nt.join 对于需要长时间运行的线程或者需要一直运行的后台任务，你应当考虑使用后台线程。\nt = Thread(target=countdown, args=(10,), daemon=True) t.start() 由于全局解释锁（GIL）的原因，Python的线程被限制到同一时刻只允许一个线程执行这样一个执行模型。所以，Python的线程更适合用物处理I/O和其他需要并发执行的阻塞操作（比如等待I/O、等待从数据库获取数据等等），而不是需要多处理器并行的计算密集型任务。\n判断线程是否已经启动 我们需要使用threading库中的Event对象。Event对象包含一个可由线程设置的信号标志，它允许线程等待某些事件的发生。。。。\n线程间通信 从一个线程向另一个线程发送数据最安全的方式可能就是使用queue库中的队列了。创建一个被多个线程共享的Queue对象，这些线程通过使用put()和get()操作来向队列中添加或删除元素。 Queue对象已经包含了必要的锁，所以可以通过它在多个线程间安全地共享数据。\n给关键部分加锁 需要使用threading库中的Lock对象。 e.g.\nimport threading class SharedCounter: def __init__(self, initial_value = 0): self._value = initial_value self._value_lock = threading.Lock() def incr(self, delta=1): with self._value_lock: self._value += delta def decr(self, delta=1): with self._value_lock: self._value -= delta 防止死锁的加锁机制 可以为每个锁创建一个ID，然后只允许使用升序方式获取锁。可以利用上下文管理器实现。\n保存线程的状态信息 可以使用thread.local()创建一个本地线程存储对象。对这个对象的属性的保存读取操作都只会对执行线程可见，而其他线程并不可见。\n创建一个线程池 concurrent.futures函数库有一个ThreadPoolExecutor类可以被用来处理。\nfrom socket import AF_INET, SOCK_STREAM, socket from concurrent.futures import ThreadPoolExecutor def echo_client(sock, client_addr): print('Got connection from', client_addr) while True: msg = sock.recv(65536) if not msg: break sock.sendall(msg) print('Client closed connection') sock.close() def echo_server(addr)： pool = ThreadPoolExecutor(128) sock = socket(AF_INET, SOCK_STREAM) sock.bind(addr) sock.listen(5) while True: client_sock, client_addr = sock.accept() pool.submit(echo_client, client_sock, client_addr) echo_server(('', 15000)) 如果你想手动创建自己的线程池，通常可以使用一个Queue。\n简单的并行编程 concurrent.futures库提供一个ProcessPoolExecutor类，可被用在一个单独的Python解释器中捃密集型函数。\nPython的全局锁问题 GIL 。。。\n定义一个Actor任务 。。。\n实现消息发布/订阅模型 。。。\n使用生成器代替线程 产生要对生成器函数和yield语句有深刻理解。。。。\n多个线程队列轮询 。。。\n在Unix系统上面启动守护进程 e.g.\n#！/usr/bin/env python3 import os import sys import atexit import signal def daemonize(pidfile, *, stdin='/dev/null', stdout='/dev/null', stderr='/dev/null'): if os.path.exists(pidfile): raise RuntimeError('Already running') try: if os.fork() \u0026gt; 0: raise SystemExit(0) except OSError as e: raise RuntimeError('fork #1 failed.') os.chdir('/') os.umask(0) os.setsid() try: if os.fork() \u0026gt; 0: raise SystemExit(0) except OSError as e: raise RuntimeError('fork #2 failed') sys.stdout.flush() sys.stderr.flush() with open(stdin, 'rb', 0) as f: os.dup2(f.fileno(), sys.stdin.fileno()) with open(stdout, 'ab', 0) as f: os.dup2(f.fileno(), sys.stdout.fileno()) with open(stderr, 'ab', 0) as f: os.dup2(f.fileno(), sys.stderr.fileno()) with open(pidfile, 'w') as f: print(os.getpid(), file=f) atexit.register(lambda: os.remove(pidfile)) def sigterm_hadnler(signo, frame): raise SystemExit() signal.signal(signal.SIGTERM, sigterm_hadnler) def main(): import time sys.stdout.write('Daemon started with pid {}\\n'.format(os.getpid())) while True: sys.stdout.write('Daemon Alive {}\\n'.format(time.ctime())) time.sleep(10) if __name__ == '__main__': PIDFILE = '/tmp/daemon.pid' if len(sys.argv) != 2： print('Usage: {} [start | stop]'.format(sys.argv[0]), file=ssy.stderr) raise SystemError(1) if sys.argv[1] == 'start': try: daemonize(PIDFILE, stdout='/tmp/daemon.log', stderr='/tmp/daemon.log') except RuntimeError as e: print(e, file=sys.stderr) raise SystemExit(1) main() elif sys.argv[1] == 'stop': if os.path.exists(PIDFILE): with open(PIDFILE) as f: os.kill(int(f.read()), signal.SIGTERM) else: print('Not running', file=sys.stderr) raise SystemExit(1) else: print('Unknown command {!r}'.format(sys.argv[1]), file=sys.stderr) raise SystemExit(1) 要启动这个守护进程，用户需要使用如下命令：\ndaemon.py start cat /tmp/daemon.pid tail -f /tmp/daemon.log 脚本编程与系统管理 通过重定向、管道、文件接受输入 Python内置的fileinput模块。 e.g.\nimport fileinput with fileinput.input() as f_input： for line in f_input: print(line, end='') ls | ./fileinput.py ./fileinput.py /etc/passwd ./fileinput.py \u0026lt; /etc/passwd 如上方式都可以接收到输入 。\n终止程序并给出错误信息 raise SystemExit('error Message') 解析命令行选项 命令行选项位于sys.argv中 argparse模块可被用来解析命令行选项。为了解析命令行选项，你首先要创建一个ArgumentParser补全，并使用add_argument()方法声明你想要支持的选项。\n运行时弹出密码输入提示 getpass模块。\n获取终端的大小 使用os.get_terminal_size()函数。\n执行外部命令并获取它的输出 使用subprocess.check_output()函数。\n复制或者移动文件和目录 shutil模块\n创建和解压归档文件 shutil.archive()和unpack.archive()\n通过文件名查找文件 os.walk()遍历目录。每次进入一个目录，它会返回一个三元组，包含相对于查找目录的相对路径，一个该目录下的目录列表，以及那个目录正面的文件名列表。\n读取配置文件 configparser模块读取.ini文件。\n给简单脚本增加日志功能 使用logging模块。\n给函数库增加日志功能 如果你想给某个函数库增加日志功能，但是又不能影响到那些不使用日志功能的程序。你应该创建一个专属的logger对象，并且像下面这样初始化配置\nimport logging log = logging.getLogger(__name__) log.addHandler(logging.NullHandler()) 实现一个计时器 使用time模块\n限制内存和CPU的使用量 在Unix系统上可以使用resource模块\n启动一个WEB浏览器 webbrowser模块能被用来启动一个浏览器，并且与平台无关。\n测试、调试和异常 测试stdout输出 。。。\n在单元测试中给对象打补丁 。。。\n在单元测试中测试异常情况 。。。\n将测试输出用日志记录到文件中 重定向sys.stderr\n忽略或期望测试失败 。。。\n处理多个异常 将多个异常放入一个元组中。\n捕获所有异常 直接捕获Exception即可。\n创建自定义异常 创建一个新的类，让它继承Exception或者是任何一个已存在 的异常类型。\n捕获异常后抛出另外的异常 使用raise from 语句来代替简单的raise.它可以让你同时保留两个异常的信息。\n重新招聘被捕获的异常 简单的一个单独的raise语句即可。\n输出警告信息 可使用warning.warn()函数。\n调试基本的程序 崩溃错误 运行python -i somefile.py可执行简单的调试。\n给你的程序 做性能测试 如果只是简单的想测试下你的程序整体花费的时间，通常使用Unix时间函数就行\ntime python stonefile.py 如果你还需要一个程序 各个细节的详细报告可以使用cProfile模块。\npython -m cProfile stonefile.py C语言扩展 。。。\n","permalink":"https://stoneepigraph.github.io/posts/python-cookbook/","title":"Python CookBook"},{"content":" 正则表达式 网络编程 因特网客户端编程 因特网客户端简介 文件传输 文件传输因特协议 在当下，HTTP,FTP,scp/rsync的应用仍然广泛。\nPython和FTP ftplib.FTP类 客户端FTP程序实例 #! /usr/bin/env python # coding: utf-8 import ftplib import os import socket HOST = 'ftp.mozilla.org' DIRN = 'pub/mozilla.org/webtools' FILE = 'bugzilla-LATEST.tar.gz' def main(): try: f = ftplib.FTP(HOST) except (socket.error, socket.gaierror) as e: print(\u0026quot;ERROR: can't reach '%s' \u0026quot; % HOST) return print(\u0026quot;*** Connected to host '%s'\u0026quot; % HOST) try: f.login() except ftplib.error_perm: print(\u0026quot;ERROR: can't login anonymously\u0026quot;) f.quit() return print(\u0026quot;*** Logged in as 'anonymous\u0026quot;) try: f.cwd(DIRN) except ftplib.error_perm: print(\u0026quot;ERROR: can't CD to '%s\u0026quot; % DIRN) f.quit() return print(\u0026quot;*** Change to '%s' folder\u0026quot; % DIRN ) try: f.retrbinary(\u0026quot;RETR %s\u0026quot; % FILE, open(FILE, 'wb').write()) except ftplib.error_perm: print(\u0026quot;ERROR: can't read file '%s'\u0026quot; % FILE) os.unlink(FILE) else: print(\u0026quot;*** Download '%s' to CWD\u0026quot; % FILE) f.quit() if __name__ == '__main__': main() Ftp的其他内容 命令行客户端程序 GUI客户端程序 Web浏览器 自定义应用程序 网络新闻 Usenet与新闻组 网络新闻传输协议 NNTP\nPython和NNTP 有一个nntplib库和一个需要实例化的nntplib.NNTP类\n电子邮件 电子邮件系统组件和协议 发送电子邮件 SMTP、ESMTP、LMTP MTA\n一些实现SMTP的MTA\n开源 Sendmail Postfix Exim qmail 商业 Microsoft Exchange Lotus Notes Domino Mail Server Python和SMTP 有一个smtplib模块和一个需要实例化的smtplib.SMTP类\nsmtplib.SMTP类方法 接收电子邮件 POP和IMAP Python和POP3 导入poplib并实例化poplib.POP3\n多线程编程 简介、动机 线程和进程 线程和Python 全局解释器锁 对Pyton虚拟机的访问是由*全局解释器锁（GIL）*控制的。在多线程环境中，Python虚拟机将按照正面所述折方式执行\n设置GIL 切换进一个线程去运行 执行正面的操作这一 指定数量的字节码指令 线程主动让出控制权（可以调用time.sleep(0)来完成） 把线程设置回睡眠状态（切换出线程） 解锁GIL 重复上述步骤 可查看Python/ceval.c文件\n退出线程 当一个线程完成函数的执行时，它就会退出。另外，还可以通过调用诸如thread.exit()之类的退出函数，或者sys.exit()之类的退出Python进程的标准方法，变或者抛出SystemExit异常，来使线程退出。 不过你不能直接“终止”一个线程。 主线程应该做一个好的管理者，负责了解每个单独的线程需要执行什么，每个派生的线程需要哪些数据或参数，这些线程执行守后会提供什么结果。这样，主线程就可以收集每个线程的相关介绍，然后汇兑成一个有意义的最终的结果。\n在Python中使用线程 Python虽然支持多线程编程，但是还需要取决于它所运行的操作系统。\n不使用线程的情况 ？？？\nPython的threading模块 避免使用thread\ntheading模块更加先进，有更好的线程支持 并且thead模块中的一些属性会和threading模块有冲突。 低级别的thread模块拥有的同步原语很少（实际上只有一个），而threading模块有很多。 thread对于进程何时退出没有控制。当主线程结束时，所有其他线程也都强制结束，不会发出警告或者进行适当的清理。 thread不支持守护线程。 thread模块 thread模块除了提供派生线程外，还提供了基本的同步数据结构，称为锁对象（lock object, 也叫原语锁、简单锁、互斥锁、互斥和二进制信号量）核心函数： start_new_thread() 它的参数包括函数（对象）、函数的参数以及可选的关键参数。 e.g.\n#! /usr/bin/env python import thread from time import sleep, ctime def loop0(): print('start loop 0 at : ', ctime()) sleep(4) print('loop 0 done at: ', ctime()) def loop1()： print('start loop 1 at: ', ctime()) sleep(2) print('loop 1 end at : ', ctime()) def main(): print('starting at: ', ctime()) thread.start_new_thread(loop0, ()) thread.start_new_thread(loop1, ()) sleep(6) print('all DONE at: ', ctime()) if __name__ == '__main__': main() start_new_thread()必须包含开始的两个参数， 即使要执行的函数不需要参数，也需要传递一个空元组。 sleep(6)的作用是防止主线程执行完成后导致两个子线程异常终止。可是这样肯定不是最好的办法，我们不能确定子函数需要多长时间执行。所以需要引入锁。 e.g.\n#！/usr/bin/env python3 # coding: utf-8 import thread from time import sleep, ctime loops = [4, 2] def loop(nloop, nsec, lock): print('start loop', nloop, ' at: ', ctime()) sleep(nsec) print('loop ', nloop, 'done at: ', ctime()) lock.release() def main(): print('start at: ', ctime()) locks = [] nloops = range(len(loops)) for i in nloops: lock = thread.allocate_lock() lock.acquire() locks.append(lock) for i in nloops: thread.start_new_thread(loop, (i, loops[i], locks[i])) for i in nloops: while locks[i].locked():pass print 'all DONE at: ', citme() if __name__ == '__main__': main() theading 模块 threading模块中所有可用对象的列表\n对象 描述 Thread 表示一个执行线程的对象 Lock 锁原语对旬（和thread模块中的锁一样) RLock 可重入锁对象，使单一线程可以（再次）获得已持有的锁（递归锁） Condition 条件变量对象，使得一个线程等待另一个线程满足特定的“条件”，比如改变状态或某个数据值 Event 条件变量的通用版本，任意数量的线程等待某个事件的发生，在该事件发生后所有线程将被激活 Semaphore 为线程间共享的有限资源提供了一个“计数器”，如果没有可用资源时会被阻塞 BoundedSemaphore 与Semaphore相似，不过它不允许超过初始值 Timer 与Thread相似，不过它要在运行前等待一段时间 Barrier 创建一个“障碍”，必须达到指定数量的线程后才可以继续 守护线程\n避免使用thread模块的另一个原因是该模块不支持守护线程。 threading模块支持守护线程，其工作方式是：守护线程一般是一个等待客户端请求服务的服务器，如果没有客户端请求，守护线程就是空闲的。如果把一个线程设置成守护线程，就表示这个线程是不重要的，进程退出时不需要等待这个线程执行完成。要将一个线程设置为守护 线程，需要 在启动线程之前执行如下赋值语句：\nthread.daemon = True\n同样，要检查线程的守护状态，也只需要检查这个值即可。\nThread类 Thread对象的属性\n属性 描述 name 线程名 ident 线程的标识符 daemon 布尔标志，表示这个线程是否是守护线程 Thread对象的方法\n方法 描述 *init*(group=None, target=None, name=None, args=(), kwargs={}, verbose=None, daemon=None) 实例化一个线程对象，需要有一个可调用的target，以及其参数args或kwargs.还可以传递name或group参数，不过后者还未实现。此外，verbose标志也是可以接受的。而daemon的值将会设定thread.daemon属性标志。 start() 开始执行该线程 run() 定义线程功能的方法（通常在子类中被应用开发者重写） join(timeout=None) 直至启动的线程终止之前一直挂起；除非给出了timeout(秒),否则会一直阻塞 is_alive() 布尔标志，表示这个线程是否还存活 创建线程的方法\n创建 Thread的实例 ，传给它一个函数 创建Thread的实例，传给它一个可调用的类实例 派生Thread的子类，并创建子类的实例 创建Thread的实例，传给它一个函数\n#! /usr/bin/env python import threading from time import sleep, ctime loops = [4, 2] def loop(nloop, nsec): print('start loop', nloop, ' at:', ctime()) sleep(nsec) print('loop ', nloop, 'done at:', ctime()) def main(): print('start at；', ctime()) threads = [] nloops = range(len(loops)) for i in nloops: t = threading.Thread(target=loop, args=(i, loops[i])) threads.append(t) for i in nloops: threads[i].start() for i in nloops: threads[i].join() print('all DONE at:', ctime()) if __name__ == '__main__': main() 创建Thread的实例，传给它一个可调用的类实例\n#! /usr/bin/env python import threading from time import sleep, ctime loops = [4, 2] class ThreadFunc(): def __init__(self, func, args, name=''): self.name = name self.func = func self.args = args def __call__(self): self.func(*self.args) def loop(nloop, nsec): print('start loop', nloop, ' at:', ctime()) sleep(nsec) print('loop ', nloop, 'done at:', ctime()) def main(): print('start at；', ctime()) threads = [] nloops = range(len(loops)) for i in nloops: t = threading.Thread(target=ThreadFunc(loop, (i, loops[i]), loop.__name__)) threads.append(t) for i in nloops: threads[i].start() for i in nloops: threads[i].join() print('all DONE at:', ctime()) if __name__ == '__main__': main() 派生Thread的子类，并创建子类的实例\n#! /usr/bin/env python import threading from time import sleep, ctime loops = [4, 2] class MyThread(threading.Thread): def __init__(self, func, args, name=''): threading.Thread.__init__(self) self.name = name self.func = func self.args = args def run(self): self.func(*self.args) def loop(nloop, nsec): print('start loop', nloop, ' at:', ctime()) sleep(nsec) print('loop ', nloop, 'done at:', ctime()) def main(): print('start at；', ctime()) threads = [] nloops = range(len(loops)) for i in nloops: t = MyThread(loop, (i, loops[i]), loop.__name__) threads.append(t) for i in nloops: threads[i].start() for i in nloops: threads[i].join() print('all DONE at:', ctime()) if __name__ == '__main__': main() threading 模块的其他函数 函数 描述 active_acount() 当前活动的Thread对象的个数 current_thread() 返回当前的Thread对象 enumerate() 返回当前活动的Thread对象列表 settrace(func) 为所有线程设置一个trace函数 setprofile(func) 为所有线程设置一个profile函数 stack_size(size=0) 返回新创建线程的栈大小；或为后续创建的线程设定栈的大小为size 单线程和多线程执行对比 多线程实践 引入线程 同步原语 锁/互斥信号量\n锁示例 锁有两种状态：\n锁定 未锁定 两个函数：\n获得锁: lock.acquire() 释放锁: lock.release() 使用上下文管理 2.5以后可以使用with语句，而不再调用锁的acquire()和release()而进一步简化代码。\n信号量 信号量是一个计数器，当资源消耗时递减，当资源释放时递增。你可以认为信号量代表它们的资源可用或不可用。 e.g.\n#! /usr/bin/env python # coding: utf-8 from atexit import register from random import randrange from threading import BoundedSemaphore, Lock, Thread from time import sleep, ctime lock = Lock() MAX = 5 candytray = BoundedSemaphore(MAX) def refill(): lock.acquire() print('Refilling candy...',) try: candytray.release() expect ValueError: print('full, skipping') else: print('OK') lock.release() def by(): lock.acquire() print('Buying candy...') if candytray.acquire(False): print('OK') else: print('empty, skipping') lock.release() def producer(loops): for i in xrange(loops): refill() sleep(randrange(3)) def consumer(loops): for i in xrange(loops): buy() sleep(randrange(3)) def _main(): print('starting at: ', ctime()) nloops = randrange(2, 6) print('The Candy Machine (full with %d bars)!' % MAX) Thread(target=consumer, args=(randrange( nloops, nlops+MAX+2),)).start() Thread(target=producer, args=(nloops,)).start() @register def _atexit(): print('all DONE at:', ctime()) if __name__ == '__main__': _main() 生产者-消费者问题和Queue/queue模块 常用属性\n属性 描述 queue(amxsize=0) 创建一个先入先出队列。如果给定最大值，则在队列没有空间时阻塞，否则为无限队列 lifoQueue(maxsize=0) 创建一个后入先出队列。如果给定最大值，则在队列没有空间时阻塞，否则为无限队列 priorityQueue(maxsize=0) 创建一个优先级队列。如果给定最大值，则在队列没有空间时阻塞，否则为无限队列 常用异常\n属性 描述 Empty 当对空队列调用get*()方法时抛出异常 Full 当对已满的队列调用put*()方法时抛出异常 常用方法\n属性 描述 qsize() 返回队列的大小（由于返回时队列的大小可能被其他线程修改，所以返回的是近似值） empty() 如果队列为空则返回True full() 如果队列已满则返回True put(item, block=True, timeout=None) 将item放入队列，如果block为True且timeout为None，则在有可用空间之前阻塞；如果timeout为正值，则最多阻塞timeout秒；如果block为False，则抛出Full异常 put_nowait(item) 和put(item, False)相同 get(block=True, timeout=None) 从队列中取得元素。如果给定了lock(非0)，则一直阻塞到有可用的元素为止 get_nowait() 和get(False)相同 task_done() 用于表示队列中的某个元素已执行完成，该方法会被正面的join()使用 join() 在队列中所有元素执行完毕并调用上面的task_done()信号之前，保持阻塞。 线程的替代方案 subprocess 模块 这是派生进程的主要替代方案，可以单纯地执行任务，或者通过标准文件（stdin, stdout, stderr)进行进程间通信。\nmultiprocessing模块 2.6引入，允许为多核或多CPU派生进程，其接口与threading模块相似。该模块同样也包括在共享任务的进程间传输数据的多种方式。\nconcurrent.futures模块 e.g.\nconcurrent.futures import ThreadPoolExecutor def __main(): print('At ', ctime(), ' on Amazon...') with ThreadPoolExecutor(3) as executor: for isbn in ISBs: executor.submit(_showRanking, isbn) print('all DONE at:', ctime()) e.g. 高级任务管理\n#! /usr/bin/env python from concurrent.futures improt ThreadPoolExecutor from re import compile from time improt ctime from urllib.request import urlopen as uopen REGEX = compile(b'#([\\d,]+) in Books ') AMZN = 'http://amazon.com/dp/' ISBNs = { '0135648956': 'Core Python Programming', '0135648956': 'Core Python Programming', '0135648956': 'Core Python Programming', } def getRanking(isbn): with uopen('{0}{1}' .format(AMZN, isbn)) as page: return str(REGEX.findall(page.read())[0], 'utf-8') def _main(): print('At', ctime(), ' on Amazon...') with ThreadPoolExecutor(3) as executor: for isbn, ranking in zip( ISBNs, executor.map(getRanking, ISBNs)): print('- %r ranked \u0026amp;s' % (ISBNs[isbn], ranking)) print('all DONE at: ', ctime()) ) GUI编程 数据库编程 简介 持久化存储 存储机制：文件，数据库系统，混合类型。\n数据库基本操作和SQL 底层存储数据库通常使用文件系统作为基本的持久化存储。 用户接口 SQL 数据库一个关系 数据库管理系统通常可以管理多个数据库 组件数据库存储可以抽象为一张表 SQL 数据库命令和查询操作是通过SQL语句提交给数据库的。 数据库和Python Python的DB-API 模块属性 DB-API标准要求必须提供下文列出的功能和属性\n属性 描述 apilevel 需要适配器兼容的DB-API版本，默认为‘1.0' threadsafety 本模块的线程安全级别。0：不支持线程安全，1：最小化线程安全支持，2：适度的线程安全支持，3：完整的线程安全支持 paramstyle 本模块的SQL语句参数风格 connect() Connect()函数 （多种异常） 数据库参数风格： 参数风格 描述 示例 numeric 数值位置风格 where name = :1 named 命名风格 where name = :name pyformat Python字典printf()格式转换 where name = %(name)s qmark 问号风格 where name = ? format ANSIC的printf()格式转换 where name = %s connect() connect()函数通过Connection对象访问数据库。兼容模块必须实现 connect()函数，该函数创建并返回一个Connection对象。 connect()函数属性： 参数 描述 user 用户名 password 密码 host 主机名 database 数据库名 dsn 数据源名 Connection对象 Connection对象方法：\n方法名 描述 close() 关闭数据库连接 commit() 提交当前事务 rollback() 取消当前事务 cursor() 使用该 连接创建（并返回）一个游标或类游标的对象 errorhandler(cxn, cur, errcls, errval) 作为给定连接的游标处理程序 Cursor对象 游标可以让用户提交数据库命令，并获得查询的结果行。 Cursor对象属性\n对象属性 描述 arraysize 使用fetchmany方法时，一次取出的结果行数，默认为1 connection 创建此游标的连接（可选） description 返回游标活动状态（7项无组）：(name, type_code, display_size, internal_size, precision, scale, null_ok)，只有name和type_code是必需的 lastrowid 上次修改行的行ID callproc(func [, args]) 调用存储过程 close() 关闭游标 execute(op [, args]) 执行数据库查询命令 executemany(op, args) 类似execute()和map()的结合 ，为给定的所有参数准备并执行数据库查询或命令 fetchone() 获取查询结果的下一行 fetchmany([size=cursor, arraysize]) 获取查询结果的下面size行 fetchall() 获取查询结果的所有行 *iter*() 为游标创建迭代器对象 messages 游标执行后从数据库中获得的消息列表（元组集合，可选） next() 被迭代器用于获取查询结果的下一行 nextset() 移动到下一个结果集 rownumber 当前结果集中游标 的索引 setinputsize(size) 设置允许的最大输入 大小 setoutputsize(size ) 设置大列获取的最大缓冲区大小 rowcount 上次execute*()方法处理或影响的行数 ORM 考虑对象而不是SQL 目前最知名的Python ORM是SQLAlchemy和SQLObject。\nSQLAlchemy常用方法： filter_by():将指定列的什作为关键字参数以获取查询结果。 filter()：与fliter_by()类似，不过更加灵活，还可以使用表达式。比如：query.filter_by(userid=1)与query.filter(User.userid ==1)相同 order_by() limit() offset() all() one() first() join() update() delete() 非关系数据库 Web客户端和服务器 Python Web客户端工具 urllib模块/包 urllib.request.urlopen() 打开一个给定的URL字符串表示的Web连接\nurlopen (urlstr, postQueryData=None)\n一旦连接成功，urlopen将会返回一个文件类型对象。 urlopen()文件类型对象的方法：\n方法 描述 f.read([bytes]) 从f中读出所有或bytes个字节 f.readline() 从f中读取一行 f.readlines() 从f中读出所有行，作为列表返回 f.close() 关闭f的URL连接 f.fileno() 返回f的文件句柄 f.info() 获得f的MIME头文件 f.geturl() 返回f的真正 urllib.request.urlretrieve() 用于下载完整的HTML，或对象文件。\nurlretrieve(url, filename=None, reporthook=None, data=None)\nquote()\nunquote()\nurlencode()\n\u0026hellip;\nWeb编程：CGI和WSGI CGI：Common Gateway Interface 通用网关掊 WSGI：Web Server Gateway Interface Web服务器网关接口\nWeb框架：Django 安装\npip install django\n创建项目\ndjango-admin.exe startproject project_name\n创建应用\npython ./manage.py startapp app_name\n创建POJO对象\n创建表\npython ./manage.py migrate\npython 应用shell 在Django中使用Python shell python ./manage.py shell\n安装应用 在settings.py的INSTALLED_APPS中添加app_name\nPython2与Python3的区别 print 在python2中它是一条语句 print \u0026hellip; 在python3中它成为了一个内置函数：print(\u0026rsquo;\u0026hellip;') input python2中使用raw_input() python3中使用input() exception python2:except Exception, instance python3:except Exception as instance ","permalink":"https://stoneepigraph.github.io/posts/python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B3/","title":"Python核心编程（3）"},{"content":" 构造过程抽象 程序设计的基本元素 基本表达式用于表示语言所关心的最简单的个体 组合的方法通过它们可以从较简单的东西出发构造出复合的元素 抽象的方法通过它们可以为复合对象命名，并将它们当作单元去操作。 命名环境 (define variable value) 组合式的求值 求值该组合式的各个子表达式。 将作为最左子表达式的值 的那个过程应用于相应的实际参数。 复合过程 包括：\n数和算术运算是基本的数据和过程 组合式的嵌套提供了一种组织起多个操作的方法 定义是一种受限的抽象手段，它为名字关联相应的值。 抽象过程的定义\n(define (funcName params) body) 过程应用的代换模型 为了求值一个组合式，解释器将对组合式的各个元素求值，而后将得到的那个过程应用于那些实际参数。\n应用序求值先求值参数而后应用 正则序求值指“完全展开而后紧约”的求值模型 条件表达式和谓词 条件表达式的一般形式\n(cond (p1 e1) (p2 e2) . . (pn en)) 受限形式\n(if predicate consequent alternative) (define (abs x) (if (\u0026lt; x 0) (- x) x)) 谓词\n(and e1 e2) (or e1 e2) (not e) 过程作为黑箱的抽象 局部名过程的意义应该不依赖于其作者为其形式参数所选用的名字 内部定义和块结构我们要允许一个过程里带有一些内部定义，使它们是局部于这一过程的。 (define (sqrt x) (define (good-enough? guess x) (\u0026lt; (abs (- (square guess) x)) 0.0001)) (define (improve guess x) (average guess (/ x guess))) (define (sqrt-iter guess x) (if (good-enough? guess x) guess (sqrt-iter (improve guess x) x))) (define (square x) (* x x)) (define (average x y) (/ (+ x y) 2)) (sqrt-iter 1.0 x)) (define (square x) (* x x)) (display (sqrt 8)) (newline) (display (square (sqrt 8))) (exit) 过程与它们所产生的计算 增长的阶 描述不同计算过程在消耗计算资源的速率上可能存在 的差异。一般来说，定义一个不变量，要求它在状态之间保持不变，这一技术是思考迭代算法设计问题时的一种非常强有力的方法。\n用高级函数作抽象 过程作为参数 用lambda构造过程 一般而言，lambda用与define同样的方式创建过程，除了不为有关过程提供名字\n(lambda (formal-parameters) body) e.g. (define (plus4 x) (+ x 4)) ;; 等价于 (define plus4 (lambda (x) (+ x 4))) 用let创建局部变量\nlet表达式的一般形式是\n(let ((var1 exp1) (var2 exp2) . . (varn expn)) body) 其实let表达式只是作为其基础的lambda表达式的语法外衣。 let表达式的特点\nlet使人能在尽可能接近其使用的地方创建局部变量约束。 变量的值是在let之外计算的。 过程作为一般性的方法 过程作为返回值 一般而言，程序设计语言总会对计算可能使用方式强加上某些限制。带有最少限制的元素被称为具有第一级的状态。第一级元素的某些“权利或者特权”包括：\n可以用变量命名 可以提供给过程作为参数 可以由过程作为结果返回 可以包含在数据结构中 构造数据抽象 层次数据和闭包性质 序对 (define x (cons 1 2)) (car x) \u0026gt; 1 (cdr x) \u0026gt; 2 序列 list\n;; 创建列表 (list 1 2 3 4 5) ;; 合并列表 (append oneList twoList) ;; 获取列表的长度 (length oneList) ;; 反转列表 (reverse oneList) ;; map 对列表所有数据执行指定函数 (map funcName listName) (list a1 a2 a3 ...) 等价于 (cons a1 (cons a2 (cons a3 (cons ...)))) ;; 返回序列的第一个元素 (car listName) ;; 返回序列除第一个剩下的元素 (cdr listName) 对表的映射\n​\tmap ​\t它有一个过程参数和一个表参数，返回将这一过程 应用于表中各个元素得到的结果形成的表。​\tnull？​\t用于检查参数是不是空表​\tpair? ​\t用于检查参数是否为序对。\n层次性结构 序列操作 filter 过滤一个序列，也就是选出其中满足某个给定谓词的元素。 符号数据 scheme的引号可以不闭合。\n基本过程 symbol? 判断变量是不是符号 eq? 以两个符号为参数，检查它们是否为同样的符号。 抽象数据的基本表示 Huffman树 抽象数据的多重表示 对于一个数据对象也可能存在多种有有的表示方式，而且我们也可能希望所设计的系统能处理多种表示形式。例如： 复数可以表示为实部和虚部（直角坐标系形式）和模和幅角（极坐标形式）。我们使用带标志的数据，操作时首先检查数据的参数标志，然后去调用处理该类型数据的适当过程。\n数据导向的程序设计和可加性 检查一个数据项的类型，并据此去调用某个适当过程称为基于类型的分派\n缺点： 每次增加一种新数据表示形式时，实现通用选择函数的人都必须修改他们的过程，而那些做独立表示的界面的人也必须修改其代码，以避免名字冲突问题。 带有通用型操作的系统 不同类型数据的组合 如果我们需要对两个或多个不同类型进行操作，我们可以如何处理？\n强制 类型的层次结构\n塔类型，可以将所有的数据都转换到高层。\n层次结构的不足\n类型不可能总是塔形的，会有各种复杂的情况。\n模块化、对象和状态 赋值和局部状态 局部状态变量 我们可以使用set!这个特殊形式给变量赋值。\n(set! \u0026lt;name\u0026gt; \u0026lt;new-value\u0026gt;) 可以使用begin对多个表达式顺序求值，并把最后一个表达式的值做为整个begin的返回。 (begin \u0026lt;exp1\u0026gt; \u0026lt;exp2\u0026gt; \u0026hellip; \u0026lt;expx\u0026gt;)\n引入赋值的代价 本书前部分中，不用任何赋值的程序设计，我们称为函数式程序设计。 引入赋值使我们不能再对程序使用代换模型做解释了,抛弃了引用透明性. 与函数式程序设计相对应的,广泛采用同仁的程序设计被称为命令式程序设计.\n求值的环境模型 一个环境就是框架的一个序列,每个框架是包含着一些约束的表格(可能为空), 这些约束将一些变量名字关联于对应的值(在一个框架里,任何变量至多只能有一个约束). 每个框架还包含着一个指针,指向这一框架的外围环境.如果由于当前讨论的目的将相应的框架看作是全局的,那么它将没有外围环境.一个变量相对于某个特定环境的值,也就是在这一环境中,包含着该变量的第一个框架里这个变量的约束值.如果在序列中并不存在这一变量的约束,那c和我们就说这个变量 在特定环境中是无约束的.\n求值规则 如果要对一个组合表达式求值\n求什这一组合式里的各个子表达式. 将去处符子表达式的值应用于去处对象子表达式的值. 局部过程 环境模型已经解释清楚了以局部过程定义作为程序模块化的有用技术中的两个关键性质:\n局部过程的名字不会与包容它们的过程 之外的名字互相干扰,这是因为这些局部过程名都是在该过程运行时创建的框架里约束的,而不是在全局环境里约束的. 局部过程只需将包含着它们的过程的形参作为自由变量,就可以访问该过程的实际参数.这是因为对于局部过程体的求值所在的环境是外围过程求值所在的环境的下属. 用变动数据做模拟 变动的表结构 修改序列的方法\nset-car! (set-car! consObj obj) set-cdr! (set-cdr! consObj obj) append! (append! consObj1 consObj2) 共享和相等\n我们可以使用eq?检查两个对象是否是同一个对象.\n队列的表示 可以使用make-queue创建队列并记录它的头序对和尾序对的指针,当头指针为空那么序队为空,如果要添加元素只需要改变尾序队和尾序队对应的指针,需要删除元素只需要修改头指针为第二个序队.\n表格的表示 数字电路的模拟器 并发: 时间是一个本质问题 元语言抽象 寄存器机器里的抽象 Q? scheme里的闭包。 2.2 SICP Video 学习语言的第一步 primitive elements 确认这门语言的主要元素有哪些？ means of combination 如何将这些元素组合在一起？ means of abstraction 抽象的方法是什么 ？ Lisp lisp由组合式组成 combination build with operator and operands ","permalink":"https://stoneepigraph.github.io/posts/sicp/","title":"SICP"},{"content":" 移动光标 h j k l { 移动到上一段 }: 移动到下一段 搜索 f加上你想在本行光标往后搜索的字母 在想要搜索的word上按* / 移动页面 zz将光标所在行移动到屏幕中间 zt： 将光标所在行移动到行首 ab: 将光标所在行移动到行尾 选择 v: 进入visual 模式 V: 进入visual line模式 操作 y: 复制选中的内容 yy: 复制一整行 p： 在光标后边粘贴 P: 在光标前边粘贴 u: 撤消上一步操作 U：撤消光标落在此行后的所有修改 .：重做上一步， c - r : 重作上一步, 重做上一步撤消的内容 n. 重做N次上一步 \u0026ldquo;ay: 将内容放到a暂存区 \u0026ldquo;ap: 将a暂存区的内容粘贴到当前 d： 删除选中的内容 D：删除光标到行尾的内容 11.dd: 删除当前行内容\nc: 删除选中内容后进入插入模式 C：删除光标到行尾的内容并进入插入模式 r：替换光标的内容为下一次输入的内容 \u0026gt;\u0026gt;: 将当前行向右缩排 shiftwidth 个字符 \u0026lt;\u0026lt;: 将当前行向左缩排 shiftwidth 个字符 =： 将选中的代码做自动缩排 多视窗 使用:e filename 打开一个新的文件 :tabe filename 新开一个tab gt: 移动到下一个tab gT: 移动到上一个tab :new 开一个新的水平视窗 c - w w： 移动到下一个视窗 :vnew: 开一个垂直视窗 vim -p: 以tabe方式打开多个文件 vim -o 以水平分隔方式打开多个文件 vim -O 以垂直方式打开多个文件 :ls： 查看当前开了哪些文件 :bN: 切换到第N个buffer c - 6: 切换到上一个buffer :bn 切换到下一个buffer :b filename 切换到指定的buffer :bd: 关闭当前buffer :tabe ba：将所有的文件以tab形式打开 C - v 进入 visual block模式 viw: 选中当前光标所在的单词 vaw： 选中当前光标所在的单词（大） vit: 选择tag内的内容 vat: 选择当前tag整个内容 v}： 选中当前到段尾 vi\u0026rdquo;: 选中双引号之间的内容 vi\u0026rdquo;: 选择双引号连还双引号的内容 di\u0026quot;: 删除双引号之间的内容,其中双引号可以替换成单引号，括号等 vip: 选中当前段落 yip: 复制当前段落 dip: 删除当前段落 vNw: 选中之后的N个单词 ^: 移动光标到行首，去除空格 0： 移动光标到行乎，含空格 :h key-notation: 查看key的的一些说明 常用设置 set nu set cursorline set noswapfile set hlsearch set ignorecase set incsearch set softtabstop=2 set shiftwidth=2 set expandtab 9 set showtabline=2\nset splitbelow set splitright syntax on colorscheme darkblue filetype on filetype indent on filetype plugin on :h vimfiles 查看vim的配置文件帮助 常用参数 -d 以diff方式打开vim ","permalink":"https://stoneepigraph.github.io/posts/vim/","title":"VIM"},{"content":" Stream Stream的创建方式 通过Collection系列集合提供 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); Stream\u0026lt;String\u0026gt; stream1 = list.stream(); 通过Arrays中的静态方法获取数组流 String[] emps = new String[10]; Stream\u0026lt;String\u0026gt; stream2 = Arrays.stream(emps); 通过Stream类中的静态方法of() Stream\u0026lt;String\u0026gt; stream3 = Stream.of(\u0026quot;aa\u0026quot;, \u0026quot;bb\u0026quot;, \u0026quot;cc\u0026quot;); 创建无限流 迭代 Stream\u0026lt;Integer\u0026gt; stream4 = Stream.iterate(0, x -\u0026gt; x + 2); 生成 Stream.generate(() -\u0026gt; Math.random()) 中间操作 筛选与切片 filter stream.filter(Predicate) limit stream.filter(long) skip stream.skip(long) distinct 通过hashcode(),equals()进行去重 stream.distinct() 映射 map 将元素转换成其他形式或提取信息。map中的Function本身也会返回一个流。 map(Function) flatMap 会整合Function本身返回的流。 flatMap(Function) 排序 sorted() 自然排序 stream.sorted() sorted(Comparator) 定制排序，指定Comparator stream.sorted(Comparator) 终止操作 查找与匹配 allMatch 检查是否匹配所有元素 stream.allMatch() anyMatch 检查是否至少匹配一个元素 nonMatch 检查是否没有匹配所有元素 findFisrt() 返回第一个元素 findAny 返回当前流中的任意元素 count 返回流中的元素的个数 max(Comparator) 返回流中的最大值 min(Comparator) 返回流中的最小值 归约 reduce(T, BinaryOperator) 将流中的元素反复结合起来，得到一个新值。 Stream.of(1,2,3,4,5).reduce(0, (x, y) -\u0026gt; x + y) 收集 collect(Collector) 将流转换为其他形式,包括转换，分组，分区等 Stream.of(\u0026quot;11\u0026quot;, \u0026quot;aa\u0026quot;, \u0026quot;bb\u0026quot;).collect(Collectors.toSet()); Stream.of(\u0026quot;11\u0026quot;, \u0026quot;aa\u0026quot;, \u0026quot;bb\u0026quot;).collect(Collectors.coutning()); ... 并行流与串行流 了解使用Fork/Join框架 Stream可以使用parallel()与sequential()切换并行流与顺序流。\n特点 惰性求值 内部迭代 ","permalink":"https://stoneepigraph.github.io/posts/language/java/stream/","title":"Java Stream简单了解"},{"content":" 企业平台 用户名密码错误企业平台账号为备案编号去掉修备的12位数字, 忘记密码联系企业所属修管科重置密码. 下载企业平台群文件有最新的企业平台安装包 企业平台提示网络异常或者老版本的(参数不是字符串) 确认一下电脑的internet Explorer浏览器能不能正常访问: https://weixiu.bjysgl.cn/bjvmpsf/f/ 正常情况下确认一下internet Explorer浏览器能不能正常上网就可以,如果能正常上网企业平台还是提示网络有问题,那么试一下上边儿的地址. 企业平台提示网络异常 确认一下是不是XP系统,企业平台已经不再支持XP系统了 确认一下internet Explorer浏览器能不能正常访问: https://weixiu.bjysgl.cn/bjvmpsf/f/ 无法访问,核实一下internet选项里的TLS1.2是不是勾选了, 现在企业平台最低要求TLS1.2(所以XP系统无法正常访问了,还有部分电脑默认是没选择TLS1.2的) 还无法访问,需要核实一下云服务商是不是对企业的外网IP做了封禁 无法上传附件核实一下internet选项里的TLS1.2是不是勾选了 打印合格证的时候提示未指定的错误去QQ群文件下载最新的企业平台安装包重新安装 企业找不到自己的备案编号让企业自己去这个地址https://weixiu.bjysgl.cn/bjvmpsf/f/ 查询备案编号 在这个网址查询不到企业的原因？ 确认企业是不是备案成功了 在这个页面查询时只输入企业名称，要么一定要跟备案的企业名称一称，要么只输入确认的几个字 登录企业平台提示账号已锁定让企业联系所属修管科, 一般是修管科将企业列入经营地异常会导致这种情况. 自动采集接口提示账号已锁定让企业去技术支持群下载最新的企业平台重新安装 登录企业平台提示未绑定MAC地址让企业从技术支持群的群文件里获取获取MAC地址的工具和操作视频,获取到MAC地址后上报给企业所属的修管科 企业说联系过修管科了,修管科也给绑定了MAC地址,可是还是登录不上去. 让企业发一下获取MAC地址工具结果截图, 登录企业平台露出登录账号和报错信息的截图和企业的备案编号三样东西给咱们,去系统里核对是否是绑定成功了. 企业要修管科的联系方式群文件有一个叫\u0026quot;本市道路运输管理部门联系电话\u0026quot;的文档, 咱们只有修管科这一个联系方式. 企业平台提示\u0026quot;下载错误,请联系管理员\u0026quot; 直接从群文件下载最新的企业平台安装包,重新安装. 企业平台被杀毒软件误杀技术支持群里有\u0026quot;企业被杀毒软件误杀的解决办法\u0026quot;文档. 企业录入维修纪录时无法选择维修接待员/质保员/维修人员人员是是按在职或兼职岗位在企业平台已经录入的人员列表里查询的 维修接待对应售后服务部下的维修接待员 质检员对应售后服务部的质量检验员 维修人员对应售后服务部下的机修技师,电气维修技师等 企业录入维修纪录时点击保存后一直转圈,未提示\u0026quot;保存成功\u0026quot; 这种情况有可能是网络问题,有可能是企业录入的日期不符合规范(还未修复),还有可能是维修配件里带有英文的逗号(最新版本已修复,不会再有这个问题). 维修纪录提示车牌号错误这种情况有可能是特殊的车牌号或者企业录入错误,让企业提供一下行驶证,我去核对一下. 维修纪录里车牌号码不能选择别的省的车牌车牌字头的下拉框是可以直接输入的.直接录入就可以. 合格证无法打印让企业确认一下Internet Explorer浏览器能不能正常打印内容. 如果正常再找我们. 如果不正常就是打印机的默认设置有问题了. 企业登记信息上报未通过需要重新上报您可在“综合查询-行管通知查询”，查看在最上方的\u0026quot;机动车维修经营登记信息审核结果通知书\u0026quot;，点击附件名称，下载通知书，查看审核未通过原因 企业登记审核结果通知书里提示企业缺少对应的配件及人员, 企业说企业本身就没这些人员或者设备 告诉企业登记信息的核对结果是按企业的开业条件去审核的. 提示质量检验员未上报驾驶证的,按企业的经营范围,给质量检验员上报驾驶证就可以了. 提示人员学历或职称不达标的,给对应的人员上传对应的学历 企业维修设备有些设备数量无法修改无法修改的设备可以多次点\u0026quot;添加\u0026quot;按钮,添加多条 企业登记信息上报时提示\u0026quot;环保措施或管理制度数据是否上报不完整\u0026quot; 确认一下管理制度里带星的是不是都上传了文件. 人员录入提示人员在其他企业在职 让员工联系上家企业办理离职 如果联系不到上家企业或者上家企业已经不经营了,那么联系企业所属修管科, 让修管科联系咱们办理离职 维修管理制度，环保制度上传格式问题 PDF, DOC,JPG,PNG 无法上传时需要修改选择文件类型 企业已经录入维修接待员,可还是无法选择维修接待人员 人员是否已录入 确认一下网络是否正常，首页是不是能正常获取数据，如果不能的话，确认一下网络是否正常，在internet选项里添加一下TLS1.2的支持。 环评是否上传环评现在不要求必传,如果做过了可以上传环评结果,没做过就可以不传了. 新车不需要录入环保维修项目跟环保确认过，有微信的聊天纪录。新车不会查询环保维修项目。 新车有临牌的录入临牌，没有的录入京Z00000 车辆的VIN码为16位怎么处理目前环检不合格的车辆是不验证车牌号和VIN的有效性的,只要关联上就行. 非环检不合格的车辆补0就可以了. 企业维修职位中无洗车工怎么处理目前没有洗车式的职位，可以在售后服务部随意选一个岗位录入。 行业管理平台-\u0026gt;修管科/修管处 企业录入了维修纪录了,可环检不合格数据还是关联成了备案企业治理未报信息 确认一下车牌号和VIN码是否一致 确认一个维修纪录是否是在接收到环检不合格数据后打印的合格证,并且是在复检数据接收前. 综合管理平台 用户名密码错误 默认用户名为企业备案编号去掉\u0026quot;修备\u0026quot;剩下的12位数字, 默认密码为WeiXiu@备案编号后门位. 忘记密码联系企业所属修管科重置密码 企业在本月27日到下月10日之间备案的企业是不同步的, 需要10日以后再尝试登录. 登录提示账号锁定无操作半小时后自动解锁 无法上报修管科汇总了当月/季/半年/年报后企业无法再次上报 上报错误,需要打回修改修管科的联系修管处打回, 企业的联系所属修管科打回 各类企业都上报哪些报表一类:月报,年报二类:季报,年报三类:半年报 ","permalink":"https://stoneepigraph.github.io/posts/%E4%BF%AE%E7%AE%A1%E6%97%A5%E5%B8%B8fq/","title":"修管日常FQ"},{"content":" Rust基础 数据类型 说明 Rust不会自动进行隐式类型转换。\nRust的整数类型都实现了From\u0026lt;T\u0026gt;和Into\u0026lt;T\u0026gt;trait, 使得我们可以在它们之间进行转换。From\u0026lt;T\u0026gt;trait包含from()方法，Into\u0026lt;T\u0026gt;trait包含into()方法。类型通过实现这些trait来表达它将被如何转换为另一个类型。\nString 和 \u0026amp;str \u0026amp;str 是一个指向字符串片段的不可变引用 String是一个可变字符串缓冲区 对于String类型来说，应该倾向于使用\u0026amp;str,而不是\u0026amp;String.\nString String可以看作由三个变量所组成的结构体，第一个变量为指向一块堆上连续内存的指针，第二个变量为这块内存里已经使用的总大小。第三个变量为这块内存的总长度capacity。 String在new的时候从堆里申请内存，在drop的时候释放内存。 String内部的指向的连续内存可以看作为u8的数组，String的使用接口确保了内部存储的确实为合法的UTF-8编码的字节。 \u0026amp;str \u0026amp;str是对String的一种借用形式，被称为字符串切片。 由于\u0026amp;str的特殊性让其与普通的引用区分开，这种携带了元数据的特殊引用也被称为胖指针。 ＆str非常有用，它能够引用String类型的多个不同子字符串而无需复制，避免复制。 元组 数组 let 变量名称:[数据类型;数组长度] = [默认值;数组长度] let 变量名称:[数据类型;数组长度] = [数据值1,数据值2...] 做为参数\n可以进行值传递也可以进行引用传递.值传递方法内的修改不会影响方法外的数据.引用传递会同步修改.\n集合 分类 迭代器\n分类\niter() 返回一个只读可重入迭代器,迭代器元素的类型为\u0026amp;T into_iter() 返回一个只读不可重入迭代器,迭代器元素的类型为T inter_mut() 返回一个可修改可重入迭代器,迭代器元素的类型为\u0026amp;mut T 类型别名 说明\n类型别名仅仅是别名,只是为了让可读性更好,并不是全新的类型 类型别名无法实现为外部类型实现外部特征等功能 newtype 为什么要使用newtype\n自定义类型可以让我们给出更有意义和可主读性的类型名 对于某些场景,只有newtype可以很好的解决\n为外部类型实现外部特征 危险期内部类型的细节 Sized和不定长类型DST 动态大小类型DST\n编译器无法在编译期间得知该类型值的大小,只有到了程序运行时,才能动态获知. 正因为编译器无法在编译期获知类型大小,若你试图在代码中直接使用DST类型,将无法通过编译,所以DST类型只能保存在堆上,在栈上存一个引用类型. Rust中常见的DST类型有: str, [T], dyn Trait, 它们都无法单独被使用,必须要通过引用或者Box来间接使用\n变量 rust里的变量默认是不可变的，如需需要声明可变变量，需要添加mut声明在变量名的前边。\n\u0026amp; \u0026amp;放在参数前边表明变量是引用类型。\n常量 常量与变量的区别 关键字是const而不是let 定义常量必须指明类型，不能省略 定义常量时变量的命名规则一般是全部大写 常量可以在任意作用域进行定义，其生命周期贯穿整个程序的生命周期。编译时编译器会尽可能将其内联到代码中，所以在不同地方对同一常量的引用并不能保证引用到相同的内存地址 常量的赋值只能是常量表达式/数学表达式，也就是说必须是在编译期就能计算出的值，如果需要在运行时才能得出结果的值比如函数，则不能赋值给常量表达式 对于变量出现重复的定义（绑定）会发生变量遮盖，后面定义的变量会遮住前面定义的变量，常量则不允许出现重复的定义 静态变量 静态变量与常量的区别 静态变量不会被内联，在整个程序中，静态变量只有一个实例，所有的引用都会指向相同一个地址 存储在静态变量中的值必须要实现Sync trait 全局变量 类型 编译期初始化的全局变量，const创建常量，static创建静态变量，Atomic创建原子类型 运行期初始化的全局变量，lazy_static用于懒初始化，Box::leak利用内存泄漏将一个变量的生命周期变为\u0026rsquo;static 错误处理 组合器 or()\n表达式按照顺序求值,任何一个表达式的结果是Some或Ok,则该值会立即返回\nand()\n若两个表达式的值都是Some或Ok,则第二个表达式中的值被返回.\nor_else() and_then() Option.filter()\n对Option进行过滤\nmap()\n可以将Some或Ok中的值映射为另一个\nmap_err()\n将Err中的值进行改变\nmap_or()\n在map()的基础上提供了一个默认值\nmap_or_else()\n与map_or()类似,不过是通过闭包提供默认值\nok_or()\n将Option类型转换为Result类型,ok_or一个默认的Err参数\nok_or_else()\n与ok_or()类似,不过是接受一个闭包作为Err参数\n自定义错误类型 最简单的错误\n#[derive(Debug)] struct AppError; impl fmt::Display for AppError { fn fmt(\u0026amp;self, f: \u0026amp;mut Formatter\u0026lt;'_\u0026gt;) -\u0026gt; fmt::Result { write!(f, \u0026quot;An Error Occurred, Please Try Again!\u0026quot;) } } fn produce_error() -\u0026gt; Result\u0026lt;(), AppError\u0026gt; { Err(AppError) } 归一化不同的错误类型 实现归一化的三种方式\n使用特征对象Box\u0026lt;dyn Error\u0026gt; 自定义错误类型 使用thiserror #[derive(thiserror::Error, Debug)] enum MyError { #[error(\u0026quot;Environment variable not found\u0026quot;)] EnvironmentVariableNotFound(#[from] std::env::VarError), #[error(transparent)] IOError(#[from] std::io::Error) } fn render() -\u0026gt; Result\u0026lt;String, MyError\u0026gt; { let file = std::env::var(\u0026quot;MARKDOWN\u0026quot;)?; // let source = read_to_string(file)?; Ok(file) } 处理未知异常 fun_name().expect(\u0026quot;error happen\u0026quot;); 结构体 语法 struct StructName { file_name: file_type, ... } let struct_var = StructName { file_name: filed_value, ... } println!(\u0026quot;{}\u0026quot;, struct_var.file_name); exp:\nfn main() { println!(\u0026quot;Hello, world!\u0026quot;); let rec = Rectangle { length: 64.1, width: 32.3 }; let rec2 = Rectangle { length: 32.2, width: 21.1 }; let area1 = area(\u0026amp;rec); println!(\u0026quot;rec area: {}\u0026quot;, area1); println!(\u0026quot;{:?}\u0026quot;, rec2); println!(\u0026quot;rec and rec2 area sub: {}\u0026quot;, rec.area_sub(rec2)); } #[derive(Debug)] struct Rectangle { length: f64, width: f64, } impl Rectangle { // 实例方法 fn area_sub(\u0026amp;self, rec2: Rectangle) -\u0026gt; f64 { return self.length * self.width - rec2.length * rec2.width; } // 静态方法 fn get_instance(length: f64, width: f64) -\u0026gt; Rectangle { Rectangle(length, width) } } // 函数 fn area(rec: \u0026amp;Rectangle) -\u0026gt; f64 { return rec.length * rec.width; } 范型结构体 stuct GenericPoint\u0026lt;T\u0026gt; { x: T, y: T, } impl \u0026lt;T: std::fmt::Debug\u0026gt; GenericPoint\u0026lt;T\u0026gt; { fn print_point(\u0026amp;self) { println!(\u0026quot;x: {:?}\u0026quot;, x) } } 元组结构体 // 实例化一个元组结构体 let pair = (String::from(\u0026quot;名称\u0026quot;), 18) // 访问元组结构体中的字段 println!(\u0026quot;pair 包含{:?} and {:?}\u0026quot;, pair.0, pair.1); // 解构一个元组结构体 let (name, age) = pair 枚举 enum 枚举关键字允许创建一个从数个不同取值中选其一的枚举类型, 任何一个在struct中合法的取值在enum中也合法. 在日常生活中很常见.比如:1年有12个月.\nfn main() { let up = Move::Up; let down = Move2::Down(1.1, 2.2); println!(\u0026quot;up: {:?}, down: {:?}\u0026quot;, up, down) } #[derive(Debug)] enum Move { Up, Down, Left, Right } #[derive(Debug)] enum Move2 { Up(f64, f64), Down(f64, f64), Left(f64, f64), Right(f64, f64) } #[derive(Debug)] enum Move3 { Up {x: f64, y: f64}, Down {x: f64, y: f64}, Left {x: f64, y: f64}, Right {x: f64, y: f64}, } #[derive(Debug)] enum Light { On = 1, Off = 0, } 范型枚举 enum GenericPoint\u0026lt;T\u0026gt; { x(T, T), Y(T, T) } 模式匹配 if if condition { } else if condition {} else {} match 模式匹配, 使用关键字match对一个值进行模式匹配.进行模式匹配时,会从上至下依次进行比较,并选定一个匹配成功的结果.\nmatch key { pattern =\u0026gt; expression, pattern1 | pattern2 =\u0026gt; expression1, _ =\u0026gt; other expression, } 模式匹配的语法糖\n|\n或语法\n..\n范围\n_\n通配符\n其他用法\n解构枚举 解构结构体 解构数组 匹配守卫\n匹配时,可以向模式中添加\u0026quot;守卫\u0026quot;, 这是一个任意布尔表达式,如果模式匹配,就会执行该表达式. 如果该表达式失败,系统不会考虑原始match中的其他分支.\n#[rustfmt::skip] fn main() { let pair = (2, -2); println!(\u0026quot;Tell me about {pair:?}\u0026quot;); match pair { (x, y) if x == y =\u0026gt; println!(\u0026quot;These are twins\u0026quot;), (x, y) if x + y == 0 =\u0026gt; println!(\u0026quot;Antimatter, kaboom!\u0026quot;), (x, _) if x % 2 == 1 =\u0026gt; println!(\u0026quot;The first one is odd\u0026quot;), _ =\u0026gt; println!(\u0026quot;No correlation...\u0026quot;), } } 函数 说明 如果函数没有return语句,那么rust使用函数的最后一句语句的结果做的返回值,并且数据类型要保持一致. 传参\n基础类型值传递 mut\n值传递,函数内外各自保存了相同的值,互不影响\n\u0026amp;mut\n引用传递,把当前变量的内在地址传递给函数.\n复合类型传参 函数重载\n不支持重载\n每个函数都只有一种实现 始终接受固定个数的形参 始终接受一组形参类型 不支持提供默认值 实参的数量在所有调用的地方都是一样的。 有时可以用宏作为替代 范型函数 语法 if let 能让你根据某个值是否与模式相匹配来执行不同的代码.\nlet str:Option\u0026lt;i32\u0026gt; = None; let flag = false; if let Some(i) = str { println!(\u0026quot;Matched{:??}\u0026quot;, i); } else if flag { println!(\u0026quot;不匹配\u0026quot;); } else { prinln!(\u0026quot;默认分支\u0026quot;); } 1.65后的 let-else\n#[test] fn second_word_upper_test() { let str = \u0026quot;foo bar\u0026quot;; assert_eq!(\u0026quot;BAR\u0026quot;.to_string(), let_test::second_word_to_upper(str).unwrap()) } pub fn second_word_to_upper(s: \u0026amp;str) -\u0026gt; Option\u0026lt;String\u0026gt; { let mut it = s.split(\u0026quot; \u0026quot;); let (Some(_), Some(item)) = (it.next(), it.next()) else { return None; }; Some(item.to_uppercase()) } while let let mut num = Some(0); while let Some(i) = num { if i \u0026gt; 9 { println!(\u0026quot;{}, quit!\u0026quot;, i); num = None; } else { prinln!(\u0026quot;i is {:?} Try again\u0026quot;, i); num = Some(i + 1); } } 范型函数 语法 fn func_name\u0026lt;T\u0026gt;(params: T) -\u0026gt; T { params } fn func_name\u0026lt;T, V\u0026gt;(x: T, y: V) -\u0026gt; T { x } trait 基本语法 fn main() { let rec = Rectangle{ length: 4.5, width: 2.4, }; println!(\u0026quot;rec, length: {}, width: {}, area: {} \u0026quot;, rec.length, rec.width, rec.area()) } trait Method { fn area(\u0026amp;self) -\u0026gt; f64; fn perimeter(\u0026amp;self) -\u0026gt; f64; } struct Rectangle { length: f64, width: f64, } impl Method for Rectangle { fn area(\u0026amp;self) -\u0026gt; f64 { self.length * self.width } fn perimeter(\u0026amp;self) -\u0026gt; f64 { (self.length + self.width) * 2.0 } } struct Circle { radius: f64, } impl Method for Circle { fn area(\u0026amp;self) -\u0026gt; f64 { std::f64::consts::PI * self.radius.powf(2.0) } fn perimeter(\u0026amp;self) -\u0026gt; f64 { std::f64::consts::PI * self.radius * 2.0 } } 链式方法调用 方法本身返回实例本身\n闭包 基础语法 let add = |a: i32, b: i32| -\u0026gt; i32 {a + b} let add2 = | a, b | a + b; Fn, FnMut, FnOnce 三者特性\nFnOnce 只能调用一次，一旦调用，Closure将丧失所有权。 FnMut 能调用多次，每次调用Closure的内部状态会变化。 Fn 能多次调用，每次调用Closure不变。 如何区分\n如果是不可变引用的方式捕获的，那肯定是Fn 如果是可变引用捕获的，可能是FnMut,也可能是Fn, 得再看闭包行为 如果闭包行为只是“不可变引用”式的使用捕获变量，那还是Fn（就退化成不可变引用捕获了） 如果闭包行为改变了捕获变量，那就是FnMut 如果是所有权转移捕获的，可能是FnOnce, 也可能是FnMut,也可能是Fn 如果捕获的是复制语义的变量，是Fn 如果捕获的是移动主义的变量，再看闭包行为 如果闭包行为没有消费转移走所有权，那就还是Fn/FnMut 如果闭包行为消费转移走了所有权，那才是FnOnce tips rust编译器会在第一次使用闭包时自动推断闭包的参数和返回值的类型 如果闭包两次调用传参类型不一致会报错。 所有权和移动 在rust中第个资源只能有一个所有者，并非所有的变更都有资源．\n内存 １．栈 后进先出，类型大小是固定的，如i32 ２．堆 编译时大小未知或者不确定，用户自己管理．\nlet a = 32; let b = a; println!(\u0026quot;{}, {}\u0026quot;, a, b); let arr1 = vec![\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;, \u0026quot;d\u0026quot;]; // 所有权已经发生转移了 let arr2 = arr1; // println!(\u0026quot;{}\u0026quot;, arr1); // 会报错 println!(\u0026quot;{:?}\u0026quot;, arr2); 所有权转移 所有权转移只会发生在堆上分配的资源. 值在賳值或做以参数传递,从函数返回的时候也会移动所有权\n借用 borrow \u0026amp;变量名 从一个函数中的变量传递给另外一个函数作为参数暂时使用.函数离开后将所有权返回给当初传递给他的变量.\n可变引用 \u0026amp;mut 变量名 定义时候和使用时候都得使用\u0026amp;mut\n切片 切片是指向一段连续内存的指针.在Rust中,连续内存中能够存储的数据结构:数组,字符串,向量.切片可以和它们一起使用. 切片也使用数字索引访问数据.下标索引从0开始. slice可以指向数组中的一部分.越界下标会引发致命错误. 切片是运行时才能确定的,并不像数组那样编译时就能确定.\n测试 常用说明 #[cfg(test)]\n标注测试模块\n#[test]\n标测试方法\n#[ignore]\n忽略指定的测试\n#[should_panic(excepted = \u0026ldquo;xxx\u0026rdquo;)]\n测试方法是否报指定的panic\ncargo test test_func_name\n运行指定测试\n不安全的Rust 不安全的代码通常内容很少而且与其他代码隔离,其正确性也应得到仔细记录.这类代码通常封闭在安全的抽象中. 不安全的Rust提供了五种新功能:\n解引用原始指针 访问或修改可变的静态变量 访问union字段 调用unsafe函数,包括extern函数 实现unsafe trait 并发 多线程编程的风险 竞态条件(race conditions), 多个线程以非一致性的顺序同时访问数据资源 死锁(deadlocks), 两个纯种都想使用某个资源,但是又都在等待对方释放资源后才能使用,结果无法继续执行 一些因为多纯种导致的很隐晦的BUG,难以复现和解决 一些线程方法 创建线程\nthread::spawn(|| {}); 让线程休眠\nthread::sleep(Duration::from_millis(1));\n让当前线程阻塞\nhandle.join().unwrap();\n线程屏障(Barrier) 在Rust中,可以使用Barrier让多个线程都执行到某个点后,才继续一起往后执行\nlet mut handles = Vec::with_capacity(6); let barrier = Arc::new(Barrier::new(6)); for _ in 0..6 { let b = barrier.clone(); handles.push(thread::spawn(move || { println!(\u0026quot;before wait\u0026quot;); b.wait(); println!(\u0026quot;after wait\u0026quot;); })); } for handle in handles { handle.join().unwrap(); } thread_local 使用thread_local宏可以初始化线程局部变量,然后在纯种内部使用该变量的with方法获取变量值\nthread_local!(static FOO: RefCell\u0026lt;u32\u0026gt; = RefCell::new(1)); FOO.with(|f| { assert_eq!(*f.borrow(), 1); *f.borrow_mut() = 2; assert_eq!(*f.borrow(), 2); }); let t = thread::spawn(move || { FOO.with(|f| { assert_eq!(*f.borrow(), 1); *f.borrow_mut() = 3; assert_eq!(*f.borrow(), 3); }); }); t.join().unwrap(); FOO.with(|f| { assert_eq!(*f.borrow(), 2); }); 线程同步 共享内存\n特点\n共享内存相对消息传递能节省多次内存拷贝的成本 共享内存的实现简洁的多 共享内存的锁竞争更多 互斥锁 Mutex\nMutex让多个并发线程的访问同一个值变成了排队访问: 同一时间,只允许一个线程访问该值\n多线程中使用mutex\nlet counter = Arc::new(Mutex::new(0)); let mut handles = vec![]; for _ in 0..10 { let counter = Arc::clone(\u0026amp;counter); let handle = thread::spawn(move || { let mut num = counter.lock().unwrap(); *num += 1; }); handles.push(handle); } for handle in handles { handle.join().unwrap(); } println!(\u0026quot;Result: {}\u0026quot;, *counter.lock().unwrap()); 常用方法\nmutex.lock()\n向mutex申请一个锁,该方法会阻塞当前线程,直到获取到锁,方法也有可能报错,例如当前正在持有锁的线程panic了.在这种情况下,其它线程不可能再获得锁,因此lock方法会返回一个错误.\n注意\n在使用前必须先获取锁 在数据使用完成后,必须及时的释放锁 死锁\nlock\n下边代码会产生死锁\nuse lazy_static::lazy_static; lazy_static! { static ref MUTEX1: Mutex\u0026lt;i64\u0026gt; = Mutex::new(0); static ref MUTEX2: Mutex\u0026lt;i64\u0026gt; = Mutex::new(0); } fn main() { let mut children = vec![]; for i_thread in 0..2 { children.push(thread::spawn(move || { if i_thread % 2 == 0 { let guard: MutexGuard\u0026lt;i64\u0026gt; = MUTEX1.lock().unwrap(); println!(\u0026quot;线程{}锁住了MUTEX1,接着准备去锁MUTEX2!\u0026quot;, i_thread); sleep(Duration::from_secs(2)); let guard = MUTEX2.lock().unwrap(); } else { let _guard = MUTEX2.lock().unwrap(); sleep(Duration::from_secs(2)); let _guard = MUTEX1.lock().unwrap(); println!(\u0026quot;线程{}锁住了MUTEX2,准备去锁MUTEX1\u0026quot;, i_thread); } })); } for child in children { let _ = child.join(); } println!(\u0026quot;死锁没有发生\u0026quot;); } try_lock()\n把上边的代码中的lock()改成try_lock()则不会产生死锁 与lock方法不同, try_lock()会尝试获取一次锁,如果无法获取锁会返回一个错误,因此不会发生阻塞\n读写锁 RwLock\nMutex会对每次读写都进行回销,但某些时候,我们需要大量的并发读, Mutex就无法满足需求了,此时我们就可以使用RwLock RwLock在使用上和Mutex区别不大,只有在多个读的情况下不阻塞程序,其他如读写,写读,写写情况下均会对后获取锁的操作进行阻塞.\n例子\nlet lock = RwLock::new(5); { let r1 = lock.read().unwrap(); let r2 = lock.read().unwrap(); assert_eq!(*r1, 5); assert_eq!(*r2, 5); } { let mut w = lock.write().unwrap(); *w += 1; assert_eq!(*w, 6); // 以下代码会阻塞发生死锁, 因为读和写不允许同时存在 // 写锁W直到该语句块结束才被释放,因此下面的读锁依然处于w的作用域中 let r1 = lock.read(); println!(\u0026quot;{:?}\u0026quot;, r1); }// 写锁在此处被drop Tips\n同时允许多个读,但最多只能有一个写 读和写不能同时存在 读可以使用read, try_read, 写write, try_write, 在实际项目中, try_xx会安全的多. 条件变量 Condvar\n例子\nlet flag = Arc::new(Mutex::new(false)); let cond = Arc::new(Condvar::new()); let cflag = flag.clone(); let ccond = cond.clone(); let handle1 = thread::spawn(move || { let mut lock = cflag.lock().unwrap(); let mut counter = 0; while counter \u0026lt; 3 { while !*lock { // wait方法会接收一个MutexGuard\u0026lt;'a, T\u0026gt;, 且它会自动地暂时释放这个锁, 使用其它线程可以拿到锁并进行数据更新 // 同时当前线程在此处会被阻塞,直到被其它地方notify后,它会将原本的MutexGuard\u0026lt;'a, T\u0026gt;还给我们,即重新获取到了锁,同时唤醒了此线程 lock = ccond.wait(lock).unwrap(); } *lock = false; counter += 1; println!(\u0026quot;inner counter: {}\u0026quot;, counter); } }); let mut counter = 0; loop { sleep(Duration::from_millis(1000)); *flag.lock().unwrap() = true; counter += 1; if counter \u0026gt; 3 { break; } println!(\u0026quot;outside counter: {}\u0026quot;, counter); cond.notify_one(); } handle1.join().unwrap(); println!(\u0026quot;{:?}\u0026quot;, flag); 信号量 Semaphore\n推荐使用tokio提供的Semaphore\n例子\n创建一个容量为3的信号量,当正在执行的任务超过3时,剩下的任务需要等等正在执行任务完成并减少信号量到3以内时,才能继续执行.\nlet semaphore = Arc::new(Semaphore::new(3)); let mut join_handles = Vec::new(); for _ in 0..5 { let permit = semaphore.clone().acquire_owned().await.unwrap(); join_handles.push(tokio::spawn(async move { println!(\u0026quot;todo...\u0026quot;); sleep(Duration::from_secs(1)); drop(permit); })); } for handle in join_handles { handle.await.unwrap(); } Atomic原子类型与内存顺序\nRust1.34版本后,就正式支持原子类型.原子指的是一系列不可被CPU上下文交换的机器指令,这些指令组合在一起就形成了原子操作.在某个CPU核心开始运行原子操作时,会先暂停其它CPU内核对内存的操作,以保证原子操作不会被其它CPU内核所干扰. 由于原子操作是通过指令提供的支持,因此它的性能相比锁和消息传递会好很多.相比较于则言,原子类型不需要开发者处理回销和释放锁的问题,同时支持修改,读取等操作,还具备较高的并发性能. 原子类型是无锁类型,但是无锁不代表无需等等,因为原子类型内部使用了CAS循环,当大量的冲突发生时,该等待还是得等待.\n内存顺序 Ordering::\n内存顺序是指CPU在访问内存时的顺序, 该顺序可能受以下因素的影响:\n代码中的先后顺序 编译器优化导致在编译阶段发生改变(内存重排序recordering) 运行阶段因CPU的缓存机制导致顺序被打乱 成员\nRelaxed 最宽松的规则,它对编译器和CPU不做任何限制,可以乱序 Release 设定内在屏障(Memory barrier),保证它之前的操作永远在它之前,但是它后面的操作可能被重排到它前面 Acquire 设定内存屏障,保证在它之后的访问永远在它之后,但是它之前的操作却有可能被重排到它后面,往往和Release在不同线程中联合使用 AcqRel 是Acquire和Release的结合,同时拥有它们俩提供的保证.比如你要对一个atomic自增1,同时希望该操作之前和之后的读取或定入操作不会被重新排序 SeqCst 顺序一致性 SeqCst就像是AcqRel的加强版,它不管原子操作是属于读取还是写入的操作,只要某个线程有用到SeqCst的原子操作,线程中该SeqCst操作前的数据操作绝对不会被重新排在该SeqCst操作之后,且该SeqCst操作后的数据操作也绝对不会被重新排在SeqCst操作前. 多线程中使用Atomic\n在多线程环境中使用Atomic需要配合Arc\n例子\nlet spinlock = Arc::new(AtomicUsize::new(1)); let spinlock_clone = Arc::clone(\u0026amp;spinlock); let thread = thread::spawn(move || { spinlock_clone.store(0, Ordering::SeqCst); }); while spinlock.load(Ordering::SeqCst) != 0 { hint::spin_loop(); } if let Err(panic) = thread.join() { println!(\u0026quot;THread had an error: {:?}\u0026quot;, panic); } Atomic不能替代锁\n对于复杂的场景下,锁的使用简单粗暴,不容易有坑 std::sync::atomic包中公提供了数值类型的原子操作:AtomicBool, AtomicIsize, AtomicUsize, AtomicI8, AtomicU16等,而锁可以应用于各种类型 在有些情况下,必须使用锁来,配合例如使用Mutex配合Condvar 应用场景\n无锁数据结构 全局变量,例如全局自增ID 跨线程计数器,例如可以用于统计指标 消息传递\n特点\n需要可靠和简单的(简单不等于简洁)实现时 需要模拟现实世界,例如用消息去通知某个目标执行相应的操作时 需要一个任务处理流水线(管道)时 线程间的消息传递\n多发送者,单接收者\n标准库提供了通道std::sync::mpsc, 其中mpsc是multiple producer, sinle consumer的缩写\nlet (tx, rx) = mpsc::channel(); let t1 = tx.clone(); let thread1 = thread::spawn(move || { t1.send(1).unwrap(); }); let t2 = tx.clone(); let thread2 = thread::spawn(move || { t2.clone().send(2).unwrap(); }); thread1.join().unwrap(); thread2.join().unwrap(); println!(\u0026quot;receive {}\u0026quot;, rx.recv().unwrap()); println!(\u0026quot;try receive {}\u0026quot;, rx.try_recv().unwrap()); println!(\u0026quot;try receive {}\u0026quot;, rx.try_recv().unwrap()); 使用for循环处理\nthread::spawn(move || { let vals = vec![ String::from(\u0026quot;hi\u0026quot;), String::from(\u0026quot;from\u0026quot;), String::from(\u0026quot;the\u0026quot;), String::from(\u0026quot;thread\u0026quot;), ]; for val in vals { tx.send(val).unwrap(); thread::sleep(Duration::from_secs(1)); } }); for receive in rx { println!(\u0026quot;Got {}\u0026quot;, receive); } 消息通道\nrust通道(Channel)包含两个部分:Sender\u0026lt;T\u0026gt;和Receiver\u0026lt;T\u0026gt;.这两个部分通过通道进行连接,但你只能看到端点.\nuse std::sync::mpsc; fn main() { let (tx, rx) = mpsc::channel(); tx.send(10).unwrap(); tx.send(20).unwrap(); println!(\u0026quot;Received: {:?}\u0026quot;, rx.recv()); println!(\u0026quot;Received: {:?}\u0026quot;, rx.recv()); let tx2 = tx.clone(); tx2.send(30).unwrap(); println!(\u0026quot;Received: {:?}\u0026quot;, rx.recv()); } 异步通道\nmpsc::channel();\n同步通道\nmpsc::sync_channel(0); 同步通道发送消息是阻塞的,只有在消息被接收后才解除阻塞, 其中的0表示无阻塞往通道中发送的消息条数\n范围线程 常规线程不能从它们所处的环境中借用数据:\nuse std::thread; fn foo() { let s = String::from(\u0026quot;Hello\u0026quot;); thread::spawn(|| { println!(\u0026quot;Length: {}\u0026quot;, s.len()); }); } fn main() { foo(); } 不过范围线程可以实现此目的\nuse std::thread; fn main() { let s = String::from(\u0026quot;Hello\u0026quot;); thread::scope(|scope| { scope.spawn(|| { println!(\u0026quot;Length: {}\u0026quot;, s.len()); }); }); } Send和Sync Send: 如果跨线程边界移动T是安全的,则类型T为Send.\n如果将T值移动到另一个线程是安全的,则类型T为Send.将所有权转移到另一个线程的影响是,\u0026ldquo;析构函数\u0026quot;将在檅应线程中运行.因此,问题在于你何时可以在一个线程中分配某个值,然后在另一个线程中取消分配该值.\nSync: 如果跨线程边界移动\u0026amp;T是安全的,则类型T为Sync.\n如果同时从多个线程访问T值是安全的,则类型T为Sync. 当且公当\u0026amp;T为Sned时,T为Sync.\n常见类型\nSend + Sync\n你遇到的类型大都属于 Send + Sync：\ni8、f32、bool、char、\u0026amp;str… (T1, T2)、[T; N]、\u0026amp;[T]、struct { x: T }… String、Option\u0026lt;T\u0026gt;、Vec\u0026lt;T\u0026gt;、Box\u0026lt;T\u0026gt;… Arc\u0026lt;T\u0026gt;：明确通过原子引用计数实现线程安全。 Mutex\u0026lt;T\u0026gt;：明确通过内部锁定实现线程安全。 AtomicBool、AtomicU8…：使用特殊的原子指令。 当类型参数为 Send + Sync 时，泛型类型通常 为 Send + Sync。\nSend + !Sync\n这些类型可以移动到其他线程,但它们不是线程安全的.这通常是由内部可变性造成的.\nmpsc::Sender\u0026lt;T\u0026gt; mpsc::Receiver\u0026lt;T\u0026gt; Cell\u0026lt;T\u0026gt; RefCell\u0026lt;T\u0026gt; !Send + Sync\n这些类型是线程安全的,但它们不能移动到另一个线程\nMutexGuard\u0026lt;T\u0026gt;: 使用操作系统级别的原语(必须在创建这些原语的纯种上取消分配) !Send + !Sync\n这些类型不是线程安全的,不能移动到其他线程\nRc\u0026lt;T\u0026gt;: 每个Rc\u0026lt;T\u0026gt;都具有对RcBox\u0026lt;T\u0026gt;的引用,其中包含非原子引用计数. *const T, *mut T: Rust会假定原始指针可能在并发方面有行后列的注意事项. 实现Send和Sync的类型\n在Rust中,几乎所有类型都默认实现了Send和Sync,而且由于这两个特征是可以自动派生的特征(通过derive派生),意味着一个复合类型(例如结构体),只要它内部的所有成员都实现了Send或者Sync,那么它就自动实现了Send或Sync\nRust中未实现Send和Sync的\n裸指针两都都没实现，因为它本身就没有任何安全保证 UnsafeCell不是Sync,因此Cell和RefCell也不是 Rc两者都没实现（因为内部的引用计数不是线程安全的） 共享状态\nRust使用类型系统来强制同步共享数据. 这主要通过两种类型实现:\nArc\u0026lt;T\u0026gt;: 对T进行原子计数,用于处理线程之间的共享,并负责在最后一个引用被丢弃时取消分配T. Arc\u0026lt;T\u0026gt;允许通过Arc::clone()实现共享只读权限. use std::thread; use std::sync::Arc; fn main() { let v = Arc::new(vec![10, 20, 30]); let mut handles = Vec::new(); for _ in 1..5 { let v = Arc::clone(\u0026amp;v); handles.push(thread::spawn(move || { let thread_id = thread::current().id(); println!(\u0026quot;{thread_id:?}: {v:?}\u0026quot;); })); } handles.into_iter().for_each(|h| h.join().unwrap()); println!(\u0026quot;v: {v:?}\u0026quot;); } Mutex\u0026lt;T\u0026gt;: 确保对T值的互斥访问. Mutex\u0026lt;T\u0026gt;能确保互斥,并允许对只读接口后面的T进行可变访问. use std::sync::Mutex; fn main() { let v = Mutex::new(vec![10, 20, 30]); println!(\u0026quot;v: {:?}\u0026quot;, v.lock().unwrap()); { let mut guard = v.lock().unwrap(); guard.push(40); } println!(\u0026quot;v: {:?}\u0026quot;, v.lock().unwrap()); } Asnyc编程 特征\nOS线程\n它最简单,也无需改变任何编程模型(业务/代码逻辑),因此非常适合作为语言的原生并发模型,\n事件驱动(Event driven) 协程(Coroutines) actor模型 async/await async: Rust vs 其它语言\nFuture在Rust中是惰性的\n只有在被轮询时才会运行\nAsync在Rust中使用开销是零\n只有你能看到的代码才有性能损耗\nRust没有内置异常调用所必需的运行时\nRust社区生态中已经提供了运行时实现,例如tokio\n运行时同时支持单线程和多线程 Rust: async vs 多线程\n有大量IO任务需要并发运行时,选async模型 有部分IO任务需要并发运行时,选多纯种,如果想降低线程创建和销毁的开销,可以使用线程池 有大量CPU密集任务需要并行运行时,例如并行计算,选多纯种模型,且让纯种数等于或者稍大于CPU核心数 无所谓时,统一选多线程 完整使用async异步编程,你需要依赖以下特性和外部库\n所必须的先特征(例如Future),类型和函数,由标准库提供实现 关键字async/await由RUST语言提供,并进行了编译器层面的支持 众多实用的类型,宏和函数由官方开发的futures包提供(不是标准库),它们可以用于任何async应用中 async代码的执行,IO操作,任务创建和调度等等复杂功能由社区的async运行时提供.例如tokio和async-std Future\nFuture是一个能产出值的异步计算（值可能是空）\nPin和Unpin\n在Rust中,所有的类型可以分为两类\n类型的值可以在内在中安全地被移动 自引用类型 将固定信的Future变为Unpin\nBox::pin, 创建一个Pin\u0026lt;Box\u0026lt;T\u0026gt;\u0026gt; pin_utils::pin_mut!, 创建一个Pin\u0026lt;\u0026amp;mut T\u0026gt; Tips\n若T: Unpin(Rust类型的默认实现)，那么Pin\u0026lt;\u0026lsquo;a, T\u0026gt;跟\u0026amp;\u0026lsquo;a mut T完全相同，也就是Pin将没有任何效果，该移动还是照常移动 绝大多数标准库类型都实现了Unpin,事实上，对于Rust中你能遇到的绝大多数类型，该结论依然成立，其中一个例外就是:async/await生成的Future没有实现Unpin 你可以通过以下方法为自己类型添加!Unpin约束：\n使用文中提到的std::marker::PhantomPinned 使用nightly版本下的feature flag 可以将值到栈上，也可以固定到堆上\n将!Unpin值固定到栈上需要使用unsfae 将!Unpin值固定到堆上无需要unsafe,可以通过Box::pin来简单的实现 将固定类型T: !Unpin时，你需要保证数据从被固定到被Drop这段时期内，其内存不会变得非法或者被重用 async/.await和Stream流处理\nasync/.await\nasync/.await是Rust语法的一部分，它在遇到阻塞操作时（例如IO）会让出当前线程的所有权而不是阻塞当前线程，这样就允许当前线程继续去执行其它代码，最终实现并发。 async是懒惰的，直到被执行器poll或者.await后才会开始运行，其中后者最常用的运行Future的方法。 async fn 函数如果拥有引用类型的参数，那它返回的Future的生命周期就会被这些参数的生命周期所限制。 async允许我们使用move关键字来将环境中变量的所有权转移支语句块内，就像闭包那样，好处是你不再发愁该如何解决借用生命周期的问题，坏处就是无法跟其它代码实现对变量的共享。 全使用多线程Future执行器（executor）时，Future可能会在线程间被移动，因此async语句块中的变量必须要能在线程间传递。至于Future会在线程间移动的原因是：它内部的任何.await都可能导致它被切换到一个新线程上去执行。类似的原因，在.await时使用普通的锁也不安全，例如Mutex.原因是，它可能会导致线程池被锁：当一个任务获取锁A后，若它将线程的控制权还给执行器，然后执行器又调度运行另一个任务，该任务也去深度获取了锁A,结果当前线程会直接卡死，最终降入死锁中。因为为了避免这种情况的发生，我们需要使用futures包下的锁futures::lock来替代Mutex完成任务。\nstream流处理\n关于Stream的一个常见例子是消息通道(futures包中的)的消费者Receiver.每次有消息从Send端发送后，它都可以接收到一个Some(val)值，一旦Send端关闭(drop)，且消息通道中没有消息后，它会接收到一个None值。\n迭代和并发\n跟迭代器类似，我们也可以迭代一个Stream。例如使用map, filter, fold方法，以及它们的遇到错误提前返回的版本： try_map, try_filter, try_fold. 但是跟迭代器又有所不同，for循环无法在这里使用，但是命令式风格的循环while let 是可以使用的，同时还可以使用next和try_next方法。\n使用join!和select!同时运行多个Future\njoin!\n它允许我们同时等待多个不同Future的完成,且可以并发地运行这些Future\ntry_join!\n在某一个Future报错后就立即停止所有Future的执行.\nselect!\njoin!只有等所有Future结束后,才能集中处理结果,如果你想同时等待多个Future,且任何一个Future结束后,都可以立即被处理,可以考虑使用futures::select!\n生命周期 生命周期消除规则 每一个引用参数都会获得独自的生命周期 若只有一个输入生命周期(函数参数中只有一个引用类型),那么该生命周期会被赋给所有的输出生命周期 若存在多个输入生命周期,且其中一个是\u0026amp;self或\u0026amp;mut self,则\u0026amp;self的生命周期被赋给所有的输出生命周期 注释 在 Rust 中，注释分为三个主要类型：代码注释、文档注释、包和模块注释，每个注释类型都拥有两种形式：行注释和块注释\n注释类型 代码注释\n行注释 // 块注释 * \u0026hellip;. * 文档注释\n文档行注释 /\n注意\n文档注释需要位于lib类型的包中,例如src/lib.rs中 文档注释可以使用markdown语法,例如# Example的标题,以及代码块高亮 被注释的对象需要使用pub对外可见 文档块注释 ** \u0026hellip; * 包和模块注释\n行注释 //! 块注释 *! \u0026hellip; * 查看文档 cargo doc \u0026ndash;open 文档测试 例子\n正常的单元测试\n/// `add_one` 将指定值加1 /// /// # Examples11 /// /// ``` /// let arg = 5; /// let answer = world_hello::compute::add_one(arg); /// /// assert_eq!(6, answer); /// ``` pub fn add_one(x: i32) -\u0026gt; i32 { x + 1 } 会panic的单元测试\n/// # Panics /// /// The function panics if the second argument is zero. /// /// ```rust,should_panic /// // panics on division by zero /// world_hello::compute::div(10, 0); /// ``` 保留测试,隐藏文档\n在某些时候，我们希望保留文档测试的功能，但是又要将某些测试用例的内容从文档中隐藏起来：\n/// ``` /// # // 使用#开头的行会在文档中被隐藏起来，但是依然会在文档测试中运行 /// # fn try_main() -\u0026gt; Result\u0026lt;(), String\u0026gt; { /// let res = world_hello::compute::try_div(10, 0)?; /// # Ok(()) // returning from try_main /// # } /// # fn main() { /// # try_main().unwrap(); /// # /// # } /// ``` pub fn try_div(a: i32, b: i32) -\u0026gt; Result\u0026lt;i32, String\u0026gt; { if b == 0 { Err(String::from(\u0026quot;Divide-by-zero\u0026quot;)) } else { Ok(a / b) } } 文档注释中的代码跳转 跳转到标准库\n/// `add_one` 返回一个[`Option`]类型 pub fn add_one(x: i32) -\u0026gt; Option\u0026lt;i32\u0026gt; { Some(x + 1) } 还可以使用路径的方式跳转\nuse std::sync::mpsc::Receiver; /// [`Receiver\u0026lt;T\u0026gt;`] [`std::future`]. /// /// [`std::future::Future`] [`Self::recv()`]. pub struct AsyncReceiver\u0026lt;T\u0026gt; { sender: Receiver\u0026lt;T\u0026gt;, } impl\u0026lt;T\u0026gt; AsyncReceiver\u0026lt;T\u0026gt; { pub async fn recv() -\u0026gt; T { unimplemented!() } } 同名项的跳转\n/// 跳转到结构体 [`Foo`](struct@Foo) pub struct Bar; /// 跳转到同名函数 [`Foo`](fn@Foo) pub struct Foo {} /// 跳转到同名宏 [`foo!`] pub fn Foo() {} #[macro_export] macro_rules! foo { () =\u0026gt; {} } 文档搜索别名 Rust 文档支持搜索功能，我们可以为自己的类型定义几个别名，以实现更好的搜索展现，当别名命中时，搜索结果会被放在第一位\n#[doc(alias = \u0026quot;x\u0026quot;)] #[doc(alias = \u0026quot;big\u0026quot;)] pub struct BigX; #[doc(alias(\u0026quot;y\u0026quot;, \u0026quot;big\u0026quot;))] pub struct BigY; 智能指针 指针是一个包含了内存地址的变量,该内存地址引用或者指向了另外的数据 智能指针则是一个复杂的家伙:通过比引用更复杂的数据结构,包含比引用更多的信息,例如f元数据,当前长度,最大可用长度等. 引用和智能指针的另一个不同在于前者仅仅是借用了数据,而后者往往可以拥有它们指向的数据,然后再为其它人提供服务. 智能指针往往是基于结构体实现,它与我们自定义的结构体最大的区别在于它实现了Deref和Drop特征\nDeref可以让智能指针像引用那样工作,这样你就可以写出同时支持智能指针和引用的代码,例如 *T 三种Deref转换 T: Deref\u0026lt;Target=U\u0026gt; 可以将\u0026amp;T转换成\u0026amp;U T: DerefMut\u0026lt;Target=U\u0026gt; 可以将\u0026amp;mut T转换成\u0026amp;mut U 要实现DerefMut必须要先实现Deref特征 T: Deref\u0026lt;Target=U\u0026gt; 可以将\u0026amp;mut T转换成\u0026amp;U Drop允许你指定智能指针超出作用域后自动执行的代码,例如做一些数据收尾工作 Tips Drop特征中的drop方法借用了目标的可变引用,而不是拿走了所有权 结构体中每个字段都有自己的Drop Drop顺序 变量级别,按照逆序的方式 结构体内部,按照顺序的方式 Rust自动为几乎所有的类型都实现了Drop特征,因此就算你不手动为结构体实现Drop,它依然后调用默认实现的drop函数,同时再调用每个字段的drop方法. 手动回收 当使用智能指针来管理锁的时候,你可能希望提前释放这个,锁然后让其它代码能及时获得,锁此时就需要提前去手动drop(obj) 互斥的Copy和Drop 我们无法为一个类型同时实现Copyu和Drop特征.因为实现了Copy的特征会被编译器隐式的复制,因此非常难以预测析构函数执行的时间和频率. 常见的智能指针 Box\u0026lt;T\u0026gt; 可以将值分配到堆上\nBox是最简单的封闭,除了将值存储在堆上外,并没有其它性能上的损耗,因此Box相比其它智能指针,功能较为单一,可以在以下场景中使用它\n特意的将数据分配在堆上 数据较大时,又不想在转移所有权时进行数据拷贝 类型的大小在编译期无法确定,但是我们又需要固定大小的类型时 特征对象,用于说明对象实现了一个特征,而不是某个特定的类型 常用函数\nBox::leak\n它可以消费掉Box并强制目标值从内存中泄漏,将一个运行期的值转为\u0026rsquo;static. 例如,你可以把一个String类型变一个\u0026rsquo;static生命周期的\u0026amp;str类型.\nRc\u0026lt;T\u0026gt; 引用计数类型,允许多所有权存在\nreference counting 引用计数,通过记录一个数据被引用的次数来确定该数据是否正在被使用.当引用次数归零时,就代表该数据不再被使用,因此可以被清理释放.\n使用\nRc:new() 创建智能指针Rc Rc:clone() 克隆智能指针\n复制智能指针并增加了引用计数,并没有克隆底层数据\nRc::strong_count() 获取引用计数的值 Tips\nRc\u0026lt;T\u0026gt;是指向底层数据的不可变引用,如果需要修改数据,那么单独使用Rc\u0026lt;T\u0026gt;无法满足我们的需求. 需要配合RefCell或者互斥锁Mutex 一旦最后一个拥有者消失,则资源会自动被回收,这个生命周期是经编译期就确定下来的. Rc只能用于同一线程内部,想要用于线程之间的对象共享,你需要使用Arc Rc\u0026lt;T\u0026gt;是一个智能指针,实现了Deref特征,因此你无需先解开Rc指针,再使用里边的T,而是可以直接使用T Arc\u0026lt;T\u0026gt; 原子化的Rc\u0026lt;T\u0026gt;\nTips\nArc虽然可以带来纯种安全,但是会伴随着性能损耗 Arc和Rc拥有完全一样的API Ref\u0026lt;T\u0026gt;和RefMut 允许将借用规则检查从编译期移动到运行期进行 Cell和RefCell\nRust提供的Cell和RefCell用于内部可变化,可以在拥有不可变引用的同时修改目标数据, Cell和RefCell在功能上没有区别,区别在于Cell\u0026lt;T\u0026gt;适用于T实现Copy的情况, 当非要使用内部可变性时,首选Cell,只有你的类型没有实现Copy时,才去选择RefCell RefCell用于你确信代码是正确的,而编译器却发生了误判的情况.总之,当你确信编译器误报但不知道该如何解决时,或者你有一个引用类型,需要被四处使用和修改然后导致借用关系难以管理时,都可以优先考虑使用RefCell\nRefCell总结\n与Cell用于可Copy的值不同,RefCell用于引用 RefCell只是将借用规则从编译期推迟到程序运行期,并不能帮你绕过这个规则 RefCell适用于编译期误报或者一个引用被在多处代码使用,修改以至于难于管理借用关系时 使用RefCell时,违背借用规则会导致运行期的panic Weak\nWeak非常类似于Rc,但是与Rc持有所有权不同,Weak不持有所有权,它仅仅保存一份指向数据的弱引用,如果你想要访问数据,需要通过Weak指针的upgrade方法获取类型为Option\u0026lt;Rc\u0026lt;T\u0026gt;\u0026gt;的值,如果值存在就返回Some,不存在就返回None.\n特点\n可访问,但没有所有权,不增加引用计数,因此不会影响被引用值的释放回收 可由Rc\u0026lt;T\u0026gt;调用downgrade方法转换成Weak\u0026lt;T\u0026gt; Weak\u0026lt;T\u0026gt;可使用upgrade方法转换成Option\u0026lt;Rc\u0026lt;T\u0026gt;\u0026gt;,如果资源已经被释放,则Option的值是None 常用于解决循环引用的问题 Tips 在表达式中智能指针不能隐匿的解引用 unsafe unsafe赋予我们的5种能力 解引用裸指引\n裸指针又称原生指针，在功能上跟引用类似，同时它也需要地注明可变性。但是又和引用有所不同，其中*const T 表示不可变裸指针， *mut T表示可变裸指针。\n裸指针与引用和智能指针的区别\n可以绕过Rust的借用规则，可以同时拥有一个数据的可变、不可变指针，甚至还能拥有多个可变的指针 并不能保证指向合法的内存 可以是null 没有实现任何自动的回收(drop) 创建裸指针\n基于引用创建裸指针\n创建裸指针是安全的行为，而解引用裸指针才是不安全的行为。\nlet mut num = 5; let r1 = \u0026amp;num as *const i32; let r2 = *mut num as *mut i32; unsafe { println!(\u0026quot;r1 is： {}\u0026quot;, *r1); } 基于内存地址创建裸指针\nlet address = 0x012345usize; let r = address as *const i32; fn get_memory_location() -\u0026gt; (usize, usize) { let string = \u0026quot;Hello world!\u0026quot;; let pointer = string.as_ptr() as usize; let length = string.len(); (pointer, length) } fn get_str_at_location(pointer: usize, length: usize) -\u0026gt; \u0026amp;'static str { unsafe { from_utf8_unchecked(from_raw_parts(pointer as *const u8, length)) } } fn main() { let (pointer, length) = get_memory_location(); let message = get_str_at_location(pointer, length); println!( \u0026quot;The {} bytes as 0x{:X} stored: {}\u0026quot;, length, pointer, message ); let message = get_str_at_location(1000, 10); println!(\u0026quot;{:?}\u0026quot;, message); } 基于智能指针创建裸指针\nlet a: Box\u0026lt;i32\u0026gt; = Box::new(10); //需要先解引用a let b: *const i32 = \u0026amp;*a; // 使用into_raw来创建 let c: *const i32 = Box::into_raw(a); 解引用裸指针\n使用*可以对裸指针进行解引用， 由于该指针的内存安全性并没有任何保证，因此我们需要使用unsafe来包裹引用的逻辑（unsafe诗句块的范围一定要尽可能的小）\nlet a = 1; let b: *const i32 = \u0026amp;a as *const i32; let c: *const i32 = \u0026amp;a; unsafe { println!(\u0026quot;{}\u0026quot;, *c); } 在上边代码，除了使用as来的转换，我们还使用了隐匿的转换方式let c: *const i32 = *a;。在实际使用中，我们建议使用as来转换。\n调用一个unsafe或外部的函数 访问或修改一个可变的静态变量 实现一个unsafe特征\n之所以会有unsafe的特征，是因为该特征至少有一个方法包含有编译器无法验证的内容。\n例\nunsafe trait Foo {} unsafe impl Foo for i32 {} fn main() {} 通过unsafe impl的使用，我们告诉编译器：相应的正确性由我们自己来保证。\n访问union中的字段\n它主要用于跟C代码进行交互，访问union的字段是不安全的，因为Rust无法保证当前存储在union实例中的数据类型。\n#[repr(C)] union MyUnion { f1: u32, f2: f32, } 调用unsafe函数或方法 用安全抽象包裹unsafe代码 一个函数包含了unsafe代码不代表我们需要将整个函数都定义为unsafe fn.\n一些实用工具 rust-bindgen\n自动生成在Rust中访问C的代码\ncbindgen\n自动生成提供给C访问的代码\ncxx\n提供跟C++代码交互\nMiri\n可以生成Rust的中间层表示MIR， 可以通过rustup component add miri来安装它，并通过cargo miri来使用， 同时还可以使用cargo miri test来运行测试代码。\nclippy Prusti 内联汇编 Rust提供了asm!宏，可以让大家在Rust代码中嵌入汇编代码\n基本用法\nuse std::arch::asm; let x: u64 unsafe { asm!(\u0026quot;mov {}, 5\u0026quot;, out(reg) x); } assert_eq!(x, 5); 显示指定寄存器\nuse std::arch::asm; let cmd = 0xd1; unsafe { asm!(\u0026quot;out 0x64, eax\u0026quot;, in(\u0026quot;eax\u0026quot;) cmd); } 上面的例子调用out指定将cmd变量的值输出到0x64内存地址中。由于out指令只接收eax和它的子寄存器，因此我们需要使用eax来指定特定的寄存器。\nFFI foreign function interface 可以用来与其它语言进行交互\n一个例子 extern \u0026quot;C\u0026quot; { fn abs(input: i32) -\u0026gt; i32; } fn main() { unsafe { println!(\u0026quot;Absolute value of -3 according to C: {}\u0026quot;, abs(-3)); } } C语言的代码定义在了extern代码块中，而extern必须使用unsafe才能进行调用，原因在于其它语言的代码并不会强制执行Rust的规则，因此Rust无法对这些代码进行检查，最终还是要靠开发者自己来保证代码的正确性和程序的安全性。\nABI 在extern \u0026ldquo;C\u0026quot;代码块中，我们列出了想要调用的外部函数的签名。其中”C\u0026quot;定义了外部函数所使用的应用二进制ABI（Application Binary Interface）：ABI定义了如何在汇编层面来调用该函数。在所有ABI中， C语言是最常见的。\n在其它语言中调用Rust函数 我们可以使用extern来创建一个接口，其它语言可以通过该接口来调用相关的Rust函数。\n例子\n#[no_mangle] pub extern \u0026quot;C\u0026quot; fn call_from_c() { println!(\u0026quot;Just called a Rust funnction from C!\u0026quot;); } 上面的代码可以让call_from_c函数被C语言的代码调用，当然，前提是将其编译成一个共享库，然后链接到C语言中。\n#[no_mangle]\n它用于告诉Rust编译器：不要乱改函数的名称。\n宏 分类 声明式宏 declarative macros (macro_rules!)\n声明式宏允许我们写出类似match的代码.match表达式是一个控制结构,其接收一个表达式,然后将表达式的结果与多个模式进行匹配,一旦匹配了某个模式,则该模式相关联的代码将被执行:\nmatch target { 模式1=\u0026gt; 表达式1, 模式2 =\u0026gt; { 语句1; 语句2; 表达式2 }, _ =\u0026gt; 表达式3 } 而宏也是将一个值跟对应的模式进行匹配,且该模式会与特定的代码相关联.但与match不同的是,宏里的值是一段Rust源代码(字面量),模式用于这段源代码的结构相比较,一旦匹配,传入宏的那段源代码将被模式的代码所替换,最终实现宏展开.值得注意的是,所有的这些都是在编译期发生,并没有运行期的性能损耗.\nWAITING 简单结构\n#[macro_export] macro_rules! vec { ( $( $x:expr ),* ) =\u0026gt; { { let mut temp_vec = Vec::new(); $( temp_vec.push($x); )* temp_vec } }; } #[macro_export]\n这个注释将宏进行了导出,这样其它的包就可以将该宏引入到当前作用域中,然后才能使用.\nmacro_rules!\n宏定义,需要注意的是宏的名称是vec,而不是vec!,后者的感叹号只在调用时才需要.\n结构\nvec的定义结构跟match表达式很像,但这里我们只有一个分支,其中包含一个模式( $( $x:expr ),* ),跟模式相关联的代码就在=\u0026gt;之后.一旦模式成功匹配,那这段相关联的代码就会替换传入的源代码.\n( $( $x:expr ),* )\n首先,我们使用圆括号将整个宏模式包裹其中.紧随基后的是$(),跟括号中的模式相匹配的值(传入的Rust源代码)会被捕获,然后用于代码替换.在这里,模式$x:expr会匹配任何Rust表达式并给予该模式一个名称:$x. \\(()之后的逗号说明在\\)()所匹配的代码的后面会有一个可选的逗号分隔符,紧随逗号之后的*说明*之前的模式会被匹配零次或任意多次(类似正则表达式).\n过程宏 procedural macros\n从形式上来看,过程宏跟函数较为想像,但过程宏是使用源代码作为输入参数,基于代码进行一系列操作后,再输出一段全新的代码.注意,过程宏中的derive宏输出的代码并不会替换之前的代码,这一点与声明宏有很大的不同!\n分类\n#[derive] 派生宏 可以为目标结构体或枚举派生指定的代码 类属性宏（Attribute-like macro）,用于为目标添加自定义的属性 类函数宏（Function-like macro）, 看上支就像是调用函数 用过程宏为属性标记生成代码\n当创建过程宏时,它的定义必须要放入一个独立的包中,且包的类型也是特殊的,这么做的原因相当复杂. 宏所在的包名自然也有要求,必须以derive为后缀,对于hello_macro宏而言,饭锅就应该是hello_macro_derive.在之前创建的hello_mac项目根目录下,运行如下命令,会创建一个单独的Lib包\ncargo new hello_macro_derive --lib 在主项目中引入hello_macro_derive\n将hello_macro_derive发布到crates.io或github [dependencies] hello_macro_derive = \u0026quot;0.0.1\u0026quot; 使用相对路径引入本地化方式 [dependencies] hello_macro_derive = { path = \u0026quot;../hello_macro/hello_macro_derive\u0026quot; } 定义过程宏\n在Cargo.toml中添加如下内容, 其中syn和quote依赖包都是定义过程宏所必须的,同时,还需要在[lib]中将过程宏的开关开启: proc-macro = true [lib] proc-macro = true [dependencies] syn = \u0026quot;1.0\u0026quot; quote = \u0026quot;1.0\u0026quot; 在 hello_macro_derive/src/lib.rs 中添加如下代码 extern crate proc_macro; use proc_macro::{TokenStream, TokenTree}; #[proc_macro_derive(HelloMacro)] pub fn hello_macro_derive(input: TokenStream) -\u0026gt; TokenStream { // 基于input构建ast语法树 let ast::DeriveInput = syn::parse(input).unwrap(); // 构建牲实现代码 impl_hello_macro(\u0026amp;ast) } 对于约大多数过程宏而言,这段代码往往只在impl_hello_macro(\u0026amp;ast)中的实现有所区别,对于其它部分基本就是一致的,如包的引入,宏函数的签名,语法树构建等. proc_macro包是Rust自带的,它包含了相关的编译器API,可以用于读取和操作Rust源代码. 由于我们为hello_macro_derive函数标记了#[proc_macro_derive(HelloMacro)],当用户使用#[derive(HelloMacro)]标记了他的类型后,hello_macro_derive函数就将被调用. syn将字符串形式的Rust代码解析为一个AST要的数据结构,该数据结构可以在随后的impl_hello_macro函数中进行操作.最后操作的结果又会被quote包转换回Rust代码. 展开宏\n我们可以使用cargo-expand工具\n宏与函数的区别 元编程\n从根本上讲,宏是通过一种代码来生成另一种代码\n可变参数\n宏可以拥有可变参数\n宏展开\n由于宏会被展开成其它代码,且这个展开过程是发生在编译器对代码进行解释之前.因此,宏可以为指定的类型实现某个牲tus:先将宏展开成实现特征的代码后,再被编译.\n宏的缺点 实现相比函数来说会更加复杂,再加上宏的语法更为复杂,最终导致定义宏的代码相当地难读,也难以理解和维护.\ncargo 创建新项目 cargo new project_name 运行项目 cargo run 检查项目 cargo test 打包项目 snap cargo build release cargo build --release Tips 修改源 修改~/.cargo/config文件，添加如下内容 [source.crates-io] registry = \u0026quot;https://github.com/rust-lang/crates.io-index\u0026quot; # 指定镜像replace-with = 'ustc' # 如：tuna、sjtu、ustc，或者 rustcc # 注：以下源配置一个即可，无需全部 # 中国科学技术大学[source.ustc] registry = \u0026quot;https://mirrors.ustc.edu.cn/crates.io-index\u0026quot; # 上海交通大学[source.sjtu] registry = \u0026quot;https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index/\u0026quot; # 清华大学[source.tuna] registry = \u0026quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git\u0026quot; # rustcc社区[source.rustcc] registry = \u0026quot;https://code.aliyun.com/rustcc/crates.io-index.git\u0026quot; 学习路线 这下边是用ChatGPT生成的^_^ 如果你想要学习 Rust 编程语言，以下是一个可能的学习路线： 了解 Rust 的基础知识和语法：可以从 Rust 官方文档中的《The Rust Programming Language》（https://doc.rust-lang.org/book/%EF%BC%89%E5%BC%80%E5%A7%8B%E5%85%A5%E6%89%8B%E3%80%82%E8%AF%A5%E4%B9%A6%E6%98%AF Rust 官方提供的入门教程，适合没有编程经验的初学者。该教程包括 Rust 的基础语法、所有权系统、生命周期等基本概念，并提供了许多实例帮助你理解这些概念。 掌握 Rust 的高级特性：在掌握 Rust 的基本语法后，可以深入学习 Rust 的高级特性，如泛型、trait、闭包、模块化等等。Rust 官方文档的《Rust By Example》（https://doc.rust-lang.org/stable/rust-by-example/%EF%BC%89%E6%98%AF%E4%B8%80%E4%B8%AA%E5%BE%88%E5%A5%BD%E7%9A%84%E9%80%89%E6%8B%A9%EF%BC%8C%E5%AE%83%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%B0%E5%AF%8C%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%B8%AE%E5%8A%A9%E4%BD%A0%E5%AD%A6%E4%B9%A0 Rust 的高级特性。 学习 Rust 的异步编程：Rust 的异步编程是 Rust 语言的一个重要特性。在学习异步编程前，需要了解 Rust 中的 Future、async、await 等异步编程的基本概念。Rust 官方文档的《Asynchronous Programming in Rust》（https://rust-lang.github.io/async-book/%EF%BC%89%E6%98%AF%E4%B8%80%E4%B8%AA%E5%BE%88%E5%A5%BD%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90。 练习编写 Rust 项目：通过编写 Rust 项目来加深对 Rust 的理解和掌握技能。你可以选择一些 Rust 项目，如 Rust 实现的 HTTP 服务器（https://github.com/hyperium/hyper%EF%BC%89%E3%80%81%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%EF%BC%88https://github.com/google/xi-editor%EF%BC%89%E7%AD%89%E7%AD%89%E3%80%82%E5%9C%A8%E5%AE%9E%E8%B7%B5%E4%B8%AD%EF%BC%8C%E4%BD%A0%E4%BC%9A%E5%8F%91%E7%8E%B0 Rust 的生命周期、所有权系统等特性对于编写高质量的代码非常有帮助。 总之，学习 Rust 需要一定的时间和耐心，但是如果你认真学习，掌握 Rust 的基本概念和特性，你将能够编写高效、安全、可靠的代码。\n如果你想学习 Rust，以下是一些学习路线的建议： 先学习 Rust 的基础知识，包括 Rust 的语法、数据类型、函数、模块、所有权等概念。可以通过 Rust 官方文档或 Rustlings 等在线教程来学习。 熟悉 Rust 的语法，包括基本数据类型、控制结构、函数和模块等。可以从官方文档的 The Rust Programming Language（TRPL）开始学习。 Rust 的所有权和借用系统，这是 Rust 最显著的特点之一。可以查阅官方文档中关于所有权和借用的章节。 学习 Rust 的标准库，了解 Rust 的常用数据结构和算法。可以通过 Rust 官方文档或 Rust by Example 等在线教程来学习。 学习 Rust 的标准库和附加库，Rust 以安全、高效和可靠著称，拥有丰富的生态系统。可以通过官方文档中的 Rust by Example 和 Rust Cookbook 来学习 Rust 库的用法。 学习 Rust 的异步编程，了解 Rust 的异步编程模型和 Futures。可以通过 Rust 官方文档或 Tokio 等在线教程来学习。 学习 Rust 的并发编程，Rust 通过内置的线程安全机制和安全的多线程 API 提供了强大的并发支持。可以查阅官方文档中的 Rust for Systems Programming 和 Rust async book 学习 Rust 的并发编程。 学习 Rust 的系统编程，了解 Rust 如何与操作系统进行交互。可以通过 Rust 官方文档或 Rust 系统编程等在线教程来学习。 学习 Rust 的 Web 开发，了解 Rust 如何用于 Web 开发。可以通过 Rust 官方文档或 Rocket 等在线教程来学习。 学习 Rust 生态系统中的一些库和框架，例如 Rocket、Actix、Tokio、Diesel 等。这些库和框架可以帮助开发者快速构建复杂的应用程序，提高生产效率和代码质量。 探索 Rust 的应用场景，并使用 Rust 开发一些实际应用。例如系统级编程、Web 后端、数据库访问、网络编程等等。 ","permalink":"https://stoneepigraph.github.io/posts/rust%E7%AC%94%E8%AE%B0/","title":"Rust笔记"},{"content":" ELisp 快捷键 格式化区域代码： C - M - \\ 执行代码： C - x C - e 相当于 eval-last-sexp\n执行代码并将执行结果放到光标处： C - u C - x C - e 查找更多信息 查询函数信息： C - h f 查询变量信息： C - h v 查询快捷键信息： C - h k 使用正则表达式查询函数名： M - x apropos 数据类型 内建 内建的Emacs数据类型称为primitive types, 包括整数、浮点数、cons、符号（symbol)、字符串、向量(vector)、散列表(hash-table)、subr(内建函数， 比如cons, if, and)、byte-code function, 和其它特殊类型， 例如缓冲区(buffer)\n数字 Emacs的数字分为整数和浮点数。1.属于整数\n整数\n一般来说最小范围是在-2**28 ~ 2**28-1.\n(message \u0026quot;%s\u0026quot; most-positive-fixnum) ;\u0026quot;2305843009213693951\u0026quot; (message \u0026quot;%s\u0026quot; most-negative-fixnum) ;\u0026quot;-2305843009213693952\u0026quot; 测试函数\n(integerp 1.) ; t (integerp 1.0) ;nil (floatp 1.) ;nil (floatp -0.0e+NaN) ;t (numberp 1) ;t 娄的比较\n(= 1.0 1) ;t (eql 1.0 1) ;nil 数的转换\ntruncate 转换面靠近0的整数 floor 转换成最接近的不比本身大的整数 celling 转换成最接近的不比本身小的整数 round 四舍五入的整数，换句话说和它的差绝对值最小的整数 数的运算\n作为除法时，两个操作数都是整数，结果就是整数，如果其中有浮点数，结果就自动转换成浮点数。\n* / 常用函数\nabs sqrt exp expt log 三角函数\nsin cos tan asin acos atan 字符和 字符串 在emacs里字符串是有序的字符数组，和C语言的字符串数组不同，Emacs的字符串可以容纳任何字符，包括\\0。 构成字符串的字符其实就是一个整数。一个字符‘A’就是一个整数65。可以使用?A获取字符对应的数字。 对于标点来说，也可以用同样的语法，但最好在前面加上转义符\\。 对于控制 字符 可以用多种表示方式比如C-i ?\\^I ?\\^i ?\\C-I ?\\C-i 对于修饰字符meta键可以使用\\M- ?\\M-A 测试函数\n对于字符串测试使用stringp，没有charp，因为字符就是整数。\n;; string-or-null-p当对象是一个字符串或nil时返回t (string-or-null-p nil) ; t (string-or-null-p \u0026quot;null\u0026quot;) ; t 字符串比较\n;; char-equal是比较两个字符是否相等，它在case-fold-search变量是t时是忽略大小写的。 (char-equal ?A ?a) ; t ;; 字符串比较使用string=或string-equal (string= \u0026quot;A\u0026quot; \u0026quot;a\u0026quot;) ;; 按字典顺序比较两个字符串 (string\u0026lt; \u0026quot;a\u0026quot; \u0026quot;A\u0026quot;) ;; nil 它是string-less的别名 转换函数\nchar-to-string string-to-char number-to-string 只能转换10进制的数字。如果需要输出八进制或者十六进制，可以使用format函数。 string-to-number 可以设置字符串的进制，可以从2到16 concat 可以把一个字符构成的列表或者微量转换成字符串。 vconcat 可以把一个字符串转换成一个向量 append 可以把一个字符串转换成一个列表。 downcase upcase capitalize 可以使字符串中单词的第一个字符大写。 upcase-initials 只使第一个单词的第一个字符大写。 格式化字符串\nformat 查找和替换\nstring-match 从指定的位置对字符串进行正则表达式匹配，如果匹配成功返回匹配的起点. 注意第一个参数是正则表达式。如果想处理非正则，可以使用regexp-quote函数预处理一下。 (string-match \u0026quot;12\u0026quot; \u0026quot;3412\u0026quot;) ; 2 (string-match \u0026quot;12\u0026quot; \u0026quot;134\u0026quot;) ; nil (string-match \u0026quot;2*\u0026quot; \u0026quot;123232*123\u0026quot;) ; 0 (string-match (regexp-quote \u0026quot;2*\u0026quot;) \u0026quot;123232*123\u0026quot;) ; 5 replace-match (let ((str \u0026quot;01234567890123456789\u0026quot;)) (string-match \u0026quot;34\u0026quot; str) (princ (replace-match \u0026quot;x\u0026quot; nil nil str 0)) (princ \u0026quot;\\n\u0026quot;) (princ str)) 把字符串按分隔符分解\n可以使用split-string\n(split-string \u0026quot;key = val\u0026quot; \u0026quot;\\\\s-*=\\\\s-*\u0026quot;) ; (\u0026quot;key\u0026quot; = \u0026quot;val\u0026quot;) Cons Cell 和列表 测试函数\n(consp '(1 2)) ;t (consp '(1 . (2 . nil))) ;t (consp nil) ;nil (listp '(1 . 2)) ;t (listp '(1 . (2 . nil))) ;t (listp nil) ;t (null '()) ;t 构造函数\n(cons 1 2) (cons 1 '()) 相关函数\n注意, 以n打头的函数都要慎用\n(setq foo '(a b)) (cons 'x foo) (print foo) ; (a b) (push 'x foo) (print foo) ; (x a b) 生成列表\nlist (list 1 2 3) list与‘(quote)的葂是，quote是把参数直接返回而不进行求值，而list和cons是对参数求值后再生成一个列表或者cons cell。 添加元素\n在列表前边新增元素 (cons 'a '(b c)) ;(a b c) 在列表后边添加元素， 一般来说append的参数都要是列表，但是最后一个参数可以不是列表，但是这样得到的结果就不再是一个真列表了。如果再进行append操作就会产生一个错误。 (append '(a b) 'c) ;(a b . c) 不是真列表 (append '(a b) '(c)) ;(a b c) append的参数不限于列表，还可以是字符串或者向量。相当于把一个字符串转换成一个字符列表，向量转换成一个列表。 (append [a b] \u0026quot;cd\u0026quot; nil) ; (a b 99 100) (append [a b] \u0026quot;cd\u0026quot;) ;(a b . \u0026quot;cd\u0026quot;) 获取列表索引为N的元素\n(nth 3 '(0 1 2 3 4 5 6 7 8 9)) ; 3 获取列表索引为N后的列表\n(nthcdr 2 '(0 1 2 3 4 5 6 7 8)) ;(2 3 4 5 6 7 8) 获取列表倒数n个长度的列表\n(last '(1 2 3 4 5 6 7) 3) ;;(5 6 7) 获取除了倒数n个元素的列表\n(butlast '(1 2 3 4 5 6 7 8) 4) ;(1 2 3 4) 改变头元素或改变后续元素\n(setq foo '(a b c)) (setcar foo 'x) (print foo) (setcdr foo '(y z)) (print foo) 移除列表的头元素并返回\n(setq foo '(a b)) (pop foo) ;(a) (print foo) ;(b) 重排列表\n(setq foo '(a b c d)) (reverse foo) ;(d c b a) (nreverse foo) (foo) ;(a) 排序列表\n(setq foo '(3 2 541 5 2 34 2 34 34)) (sort foo '\u0026lt;) ;; (2 2 2 3 5 34 34 34 541) 把列表当集合用 把列表当关联表\n列表实现的关联表有一个专门的名字叫association list. 在Emacs Lisp里是有hashtable的,可是hashtable没有列表丰富的函数,只有一个maphash函数可以遍历列表. 在Emacs Lisp的association list中关键字是放在元素的car部分,与它对应的数据放在这个元素的cdr部分.根据比较方法的不同有assq和assoc两个函数,它们分别 对应查找使用eq和equal两种方法.\n(assoc \u0026quot;a\u0026quot; '((\u0026quot;a\u0026quot; 97) (\u0026quot;b\u0026quot; 98))) ; =\u0026gt; (\u0026quot;a\u0026quot; 97) (assq 'a '((a . 97) (b . 98))) ; =\u0026gt; (a . 97) ;; 通常我们只需要查找对应的数据，所以一般来说都要用 cdr 来得到对应的数据： (cdr (assoc \u0026quot;a\u0026quot; '((\u0026quot;a\u0026quot; 97) (\u0026quot;b\u0026quot; 98)))) ; =\u0026gt; (97) (cdr (assq 'a '((a . 97) (b . 98)))) ; =\u0026gt; 97 ;; assoc-default 可以进一步完成这样的操作 (assoc-default \u0026quot;a\u0026quot; '((\u0026quot;a\u0026quot; 97) (\u0026quot;b\u0026quot; 98))) ; =\u0026gt; (97) 如果查找用的键值（key）对应的数据也可以作为一个键值的话，还可以用 rassoc 和 rassq来根据数据查找键值：\n(rassoc '(97) '((\u0026quot;a\u0026quot; 97) (\u0026quot;b\u0026quot; 98))) ; =\u0026gt; (\u0026quot;a\u0026quot; 97) (rassq '97 '((a . 97) (b . 98))) ; =\u0026gt; (a . 97) 把列表当树 遍历列表\n遍历列表最常用的函数就是 mapc 和 mapcar 了。它们的第一个参数都是一个函数，这个函数只接受一个参数，每次处理一个列表里的元素。这两个函数唯一的差别是前者返回的还是输入的列表，而 mapcar 返回的函数返回值构成的列表： (mapc '1+ '(1 2 3)) ; =\u0026gt; (1 2 3) (mapcar '1+ '(1 2 3)) ; =\u0026gt; (2 3 4) dolist (dolist (var list [result]) body...) TODO 将列表按指定分隔符合并成一个字符串\n可以使用mapconcat,\n(mapconcat 'identity '(\u0026quot;a\u0026quot; \u0026quot;b\u0026quot; \u0026quot;c\u0026quot;) \u0026quot;\\t\u0026quot;) ;\u0026quot;a\tb\tc\u0026quot; ;; identity是一个特殊的函数,它会直接返回参数. 数组和序列 序列是列表和数组的统称,也就是说列表和数组都是序列.它们的共性是内部的元素都是有序的.elisp里的数组包括字符串、向量、char-table和布尔向量。它们关系如下所示：\nsequence list Array Vector String char-table Bool-vector 数组\n数组的特性\n数组内的元素都对应一个下标，第一个元素的下标是0.数组内的元素可以在常数时间内访问。 数组在创建之后就无法改变它的长度。 数组是自求值的。 数组里的元素都可以用aref来访问，用aset设置。 数组的相关函数\nfillarray： 填充数组使用filearray可以把整个数组用某个元素填充 (fillarray (make-vector 3 'a) 6) ;[6 6 6] aref: 访问数组 aset：修改数组 向量\n向量可以看成是一种通用的数组，它的元素可以是任意的对象。\n创建向量\nvector (vector 'foo 23 [bar baz] \u0026quot;react\u0026quot;) ;[foo 23 [bar baz] \u0026quot;react\u0026quot;] make-vector 使用make-vector可以生成元素相同的向量 (make-vector 9 'a) ;[a a a a a a a a a] vconcat: 可以把多个序列连接成一个微量。但是这个序列必须是真列表。这也是把列表转换成向量的方法。 (vconcat [A B C] \u0026quot;aa\u0026quot; '(foo (6 7))) ; =\u0026gt; [A B C 97 97 foo (6 7)] 字符串\n字符串是一种特殊的数组，它的元素只能是字符。\n测试函数\n测试一个对象是否是一个序列。 (sequencep '()) ;t 测试一个对象是否是数组 (arrayp '()) ;nil (arrayp '[]) ;t vectorp、char-table-p和bool-vector-p分别测试对象是否是向量、char-table、bool-vector。 通用函数\n获取序列的长度\nlength可以得到序列的长度，但这个函数只对真列表有效。对于一个点列表和环形列表这个函数就不适用了。点列表会两难参数类型不对的错误，而环形列表就会陷入死循环。\n(length '(1 2 3)) ;3 (safe-length '(a . b)) ;1 复制\ncopy-sequence： 复制序列 真与假 非nil和() 即为真\n符号 符号是有名字的对象。\n函数 基本函数： car： 取列表的第一个元素，非破坏性。 cdr：取列表中除第一个元素个的剩下的元素，非破坏性。 cons：将一个新元素插入到一个列表的开始处，第一个参数为一个元素，第二个元素为一个列表。 consp: 判断参数是不是一个列表, 空列表返回nil listp: 判断参数是不是一个列表, 空列表返回t null: 判断参数是不是nil, 空列表返回t atom: 判断参数是不是一个原子, 空列表也是原子 append: takes any number of lists and makes a new list by concatenating the top-level elements of all the lists. 将任意数量的列表中的顶级子元素连接成一个新的列表 reverse: takes a list and makes a new list by reversing its top-level elements. 通过颠倒参数列表的顶级元素来生成一个新的元素. nreverse: 破坏性的reverse length：取一个列表的长度 nthcdr: 重复的取列表的cdr，非破坏性， 第一个参数为次数，第二个参数为一个列表。 nth: 返回列表的第几个元素. (nth n var) assoc: setcar: 将一个列表的car设置成为一个新值，破坏性 setcdr：将一个列表的cdr设置为一个新值， 破坏性 progn: 使其每一个参量被逐一求值并返回最后一个参量的值。 prog1: 与progn类似。不同之处在于prog1函数依次对它的参量求值并将其第一个参量的值作为整个表达式的值返回。 concat: 将新文本的字符串连接到老文件之前。 substring: 将第一个参数（字符串）截取按第二个和第三个字符串之间的内容。 message： 给用户发送消息。 if: 对函数的第一个参量求值，如果这个值是“真”，则对第二个参量求什；否则，如果有第三个参量的话就对第三个参量求值。 equal，eq: 测试两个对象是否相同。如果两个对象有相似的结构和内容，equal则返回“真”，如果两个参量确实是完全相同的对象，则另一个函数eq返回“真”。 buffer-name: 它将缓冲区的名字以一个字符串的形式返回。 buffer-file-name: 它返回缓冲区正在访问的文件的名字。 current-buffer: 返回Emacs中当前缓冲区的名字。 other-buffer: 返回最近选择过的缓冲区。 set-buffer: 将Emacs的注意力切换到另外一个运行程序的缓冲区。不改变当前窗口正在显示的内容。 buffer-size: 返回当前缓冲区中的字符数。 point: 返回当前光标位置对应的值。 point-min: 返回当前缓冲区中位点的最小可能值。 point-max: 返回当前缓冲区中位点的最大可能值。 eobp: End of buffer P，当位点处于这个缓冲区末尾时，这个函数返回“真”。 looking-at: 当紧跟在位点之后的文本与传递给looking-at函数作为其参量的正则表达式匹配时，函数返回“真”。 or: 逐一对每一个参量求值，并返回第一个非空值。如果所有参量的值都是nil就返回nil。 and: 逐一对每一个参量求值，如果有一个参量的值是nil, 则返回nil。 not: 取反。 \u0026amp;optional: 在函数定义中用于指出一个参量是可选参量。 \u0026amp;rest: 聚合剩下的所有参数成一个集合到当前参数.必须为参数列表的最后一个参数 collect up any remaining arguments into a list and assign it to the last parameter forward-line: 将光标移动到下一行的行首，如果其参量大于1,则移动多行。 erase-buffer: 删除当前缓冲区的全部内容。 bufferp: 如果其参量是一个缓冲区则返回“真”，否则返回“假”。 pp: 格式化输出内容。 破坏性函数 nconc: 定义函数 定义函数的模板\n(defun function-name (arguments...) \u0026quot;optional-documentation...\u0026quot; (interactive argument-passing-info) ; optional body..) 参数\n可选参量\n如果一个参量跟在\u0026amp;optional这个关键词后面，则当调用这个函数时就不一定传送一个值给这个参量。\ninteractive\n使函数成为交互式函数\nargument-passing-info\n\u0026ldquo;p\u0026rdquo; : 表示要传送一个前缀参量给这个函数，并将它的值用于函数参量 \u0026ldquo;r\u0026rdquo; : 表示将位点所在区域的开始值和结束值做为函数的两个参量 \u0026ldquo;B\u0026rdquo; : 表示用缓冲区的名称作为函数的参量， 允许使用不存在的缓冲区 \u0026ldquo;b\u0026rdquo; : 表示用缓冲区的名称作为函数的参量， 如果缓冲区不存在，你将收到一条错误消息 \u0026ldquo;f\u0026rdquo; : 一个已经存在的文件的名字 \u0026ldquo;*\u0026rdquo; : 用于缓冲区是一个只读缓冲区的情况， 指如果函数被一个只读缓冲区调用，一条消息将打印在回显区，终端将发出蜂鸣或者闪亮一下。 使用两个以上的参量\n两个部分之间使用\\n分隔开\n(defun name-of-function (buffer start end) \u0026quot;documentation\u0026quot; (interactive \u0026quot;BAppend to buffer: \\nr\u0026quot;) body-of-function) 永久安装代码\n可以将定义的函数放到.emacs或.emacs.d/init.el， 也可以放到load函数的目录\n特殊表\n常用特殊表\nset: 将第二参数赋值给第一个参数。\nsetq: 将第二个参数赋值给第一个参数，与set的区别是，第一个参数不需要加单引号。\ndefvar: 给一个变量赋值，与setq函数相似，但它只对无值的变量赋值。另外,使用defvar可以为变量提供文档字符串,当 变量是在文中定义的话, C-h v后能给出变量定义的位置.\ndefun: 定义函数。最多可以有五个部分： 函数名，传送给函数的参量的模板，文档，一个可选的交互函数声明以及函数体。例：\n(defun back-to-indentation () \u0026quot;Point to first visible character on line.\u0026quot; (interactive) (beginning-of-line 1) (skip-chars-forward \u0026quot; \\t\u0026quot;) ) interactive: 向Lisp解释器声明这个函数可以被交互地使用。这个特殊表可以用一个字符串，分成一个部分或几个部分，依次传送信息到这个函数的参数。这些部分也可以告诉Lisp解释器提示这些信息。字符串的每一个部分用换行符（\\n）分开。其中常用到的控制字符是：\nb: 一个已经存在的缓冲区的名字。 f: 一个已经存在的文件的名称。 p: 数字前缀参量。 r: 位点和标记，作为两个数字参量，小的在前面。 let: 声明在let表达式主体中使用的变量列表并给它们赋初始值，初始值要么是nil,要么是一个指定的值。然后对let表达式主体的其他表达式求值并返回最后一个表达式的值。在let表达式主体中，Lisp解释器看一到被绑定在let表达式之外的同名变量的值。\nlet*: 与let类似，let*表达式中，变量列表中后面的变量可以使用前面变量已经由Emacs设置的值。\nwhile:while循环将包含三个部分：\n一个真假测试表达式。 一个求值表达式。 一个表达式。 递归：一个递归函数通常包含一个条件表达式，这个条件表达式有三个部分：\n一个真假测试 函数名 一个表达式。 模板：\n(defun name-of-recursive-function (argument-list) \u0026quot;documentation...\u0026quot; body... (if do-again-test (name-of-recursive-function next-step-expression)) ) let\n创建函数内的局部变量例：\n(let ((variable1 value) (variable2 value) ...) body...) let*\n与let类似.let*表达式中，变量列表中后面的变量可以使用前面变量已经由emacs设置的值。\nif\n(if (true-or-false-test) (action-to-carry-out-if-test-is-true)) (if (true-or-false-test) (action-to-carry-out-if-the-test-returns-true) (action-to-carry-out-if-the-test-returns-false)) cond\nif为cond的特殊形式\n(cond (first-true-or-false-test first-consequent) (second-true-or-false-test second-consequent) (third-true-or-false-test third-consequent) ...) 当Lisp解释器对cond表达式求值时，它先计算cond表达式主体当中的一系列表达式中的第一个表达式的第一个元素，如果这个真假测试表达式返回nil，则这个表达式的其余部分就被忽略，而下一个表达式中的真假测试被求值，如果有一个表达式的真假测试结果不是nil,则那个表达式的后续部分就被求值。后续部分可以是一个表达式也可以是多个表达式。如果后续表达式是多个表达式组成的，则这些表达式被依次求值，并且最后一个表达式的值被返回。如果这 个表达式只有真假测试表达式而没有后续表达式，真假测试表达式的值就作为结果返回。\nsave-excursion\n这个函数将当前的位点和标记保存起来，执行函数体，然后，如果位点和标记发生改变就将位点和标记恢复成原来的值。这个特殊表的主要目的是使用户避免位点和标记的不必要移动。\n代码模板\n(save-excursion body...) save-restriction\n跟踪变窄开启的部分\n如果同时使用save-secursion和save-restriction时（并且是一个紧接着另一个使用时），应当在外层使用save-excursion.如果采用了相反的次序，就会在调用save-excursion之后无法记录缓冲区中变窄开启的标记。\n(save-excursion (save-restriction body...)) save-match-data\n保存之前的搜索结果,不想因为我们的函数修改了全局的匹配数据.\ndefvar\n给一个变量赋值， 与setq类似。\n(defvar var value \u0026quot;Documentation \u0026quot;) 不同之处：\n它只对无值的变量赋值 它有一个文档字符串 常用函数 将人能读懂的代码转换成字节编码： byte-compile-file 将两个或更多的字符串连接： (concat \u0026ldquo;one str \u0026quot; \u0026ldquo;two str\u0026rdquo;) 截取字符串 (substring \u0026ldquo;str\u0026rdquo; startNum endNum)3 在回显区打印消息 (message \u0026ldquo;This is a message in buffer %s\u0026rdquo; (buffer-name) ) 给一个变量赋值\n(set \u0026lsquo;oneList \u0026lsquo;(this is a list)) (setq oneList \u0026lsquo;(this is a list)\ntwoList \u0026lsquo;(this another list))\n判断相等，判断两个对象有相似的结构和内容： (equals var1 var2) 判断相等，判断两个对象完全相同的对象： (eq obj1 obj2) 设置标记： C - SPC set-mark-command 将光标移动到位点处： C - x C - x exchange-point-and-mark 移动光标的函数\n将光标移动到缓冲区的开始位置： beginning-of-buffer M - \u0026lt; 逻辑函数\nand和or具有短路性质.\nor\n很多人喜欢在表达式短时,用or代替unless or经常用于设置函数的缺省值\n(or name (setq name \u0026quot;Emacser\u0026quot;)) not and\n很多人喜欢在表达式短时,用and代替when and经常用于用于参数检查\n(and (\u0026gt;= n 0) (= (/ n (sqrt n)) (sqrt n))) 将一个由(interactive \u0026ldquo;p\u0026rdquo;)产生的未加工的前缀参量转换成一个数值： (prefix-numeric-value arg) 打印字符串： (print msg) 在位点处插入字符串: (insert \u0026ldquo;message\u0026rdquo;) 将文件名转换成文件的绝对的长路径形式： (expand-file-name file-name) 对列表进行排序： (sort list-variable ‘\u0026lt;) 构建文件列表： (directory-files \u0026ldquo;.\u0026rdquo; t \u0026ldquo;\\\\.el$\u0026rdquo;)\n第一个参数是要遍历的目录 第二个参数如果非空则返回目录中文件的绝对路径 第三个参量是一个可选项， 如果它包含一个颪表达式，则只能路径名与颪表达式匹配的文件被返回 将第一个参量应用到苦命参量上： (apply \u0026lsquo;funcName params) mapcar\n它依次使用第二个参量中的每一个元素调用第一个参量，第二个参量必须是一个列表。\n(mapcar '1+ '(1 2 3)) (2 3 4) 查找与指定内容相关的内容： M - x appropos RET document RET 向前过滤指定字符移动光标: (skip-chars-forward \u0026ldquo;\u0026rdquo;) 向后过滤指定字符移动光标: (skip-chars-backed \u0026ldquo;\u0026rdquo;) return a character\u0026rsquo;s syntax code as another character: (char-syntax ?\\n) 将字符转字符串: (char-to-string \u0026ldquo;c\u0026rdquo;) 判断cursor是否在当前Buffer的开始: (bobp) lambda ((lambda (arg) (/ arg 50)) 100) 其中后边的100是传递给lambda的参量arg的实际值\ndefadvice creates a new piece of advice, its first argument is the (unquoted) name of the existing function being advised.Next comes a specially formatted list.\nprogn\n每一个参量被逐一求值并反回最后一个参量的值。因为if后只能求一条语句的值,可以使用progn把所有想要执行的语句包起来成一条语句.\n变量 let 当同一个变量名既是全局变量也是局部变量，或者用let多层绑定，只有最里层的那个变量是有效的，用setq改变的也只是了里层的变量，而不影响外层的变量。另外需要注意一点的是局部变量的绑定不能超过一定的层数，也就是说，你不能把foo用let绑定最多max-specpdl-size层。\n(message \u0026quot;%d\u0026quot; max-specpdl-size) 循环和递归 while 对第一个参量求值，并测试这个返回值，如果第一个参量的求值结果是“假”，则Lisp解释器跳过这个表达式的其余部分，如果第一个参量的求值结果是“真”，则Lisp解释器就继续对这个表达式的主体求值，然后再次测试while的第一个参量。\n(while true-or-false-test body...) 常用循环方式\n使用空列表做结束 使用固定次数做循环 使用减量计数器做循环 递归 递归函数就是自己调用自己的函数。一个递归函数通常包含一个条件表达式，这个条件表达式有三个部分：\n一个真假测试， 它决定函数是否继续调用自身 函数名 一个表达式，它在函数被重复求值正确的次数之后使条件表达式返回“假”值 正则 相关规则 .: matches any single character except newline. Backslash: followed by a magic character, matches that character literally. []: A set of characters inside square brackets matches any one of the enclosed characters. the syntax of square brackets in regular expressions has its own \u0026ldquo;subsyntax\u0026rdquo; as follows: a range of consecutive characters, such as abcd, can be abbreviated a-d. Any number of such ranges can be included. if the first character is a caret(^), then the expression matches any character not appearing inside the square brackets. To include a right-square-bracket, it must be the first character in the set. to include a hyphen: it must appear where it can\u0026rsquo;t be interpreted as part of a range.So [a-e-z] matches a, b,c,d,e,-, or z. to include a caret(^): it must appear someplace other than as the first character in the set. Other characters that are normally \u0026ldquo;magic\u0026rdquo; in regexps, such as \u0026ldquo;*\u0026rdquo; and \u0026ldquo;.\u0026rdquo; are not magic inside square brackets. 在正则表达式中通常具有魔术的字符,比如*和.在[]里不具备魔术. a regexp x may have one of the following suffixes: *: zero or more +: one or more ?: zero or one ^x: matches x is beginning of a line. x$: matches x is end of a line. two regualr expressions x and y separated by \\I : match whatever x matches or whatever y matches. so hello\\Igoodbye matches hello or goodbye. a regular expression x enclosed in escaped parentheses: \\(and\\): matches whatever x matches. This can be used for grouping complicated expressions. So \\(ab\\)+matches ab, abab, ababab, and son on. Also \\(ab\\Icd\\)ef matches abef or cdef. As a side effect, any text matched by a parenthesized subexpression is called a submatch and is memorzized in a numbered register.Submatches are numbered from 1 through 9 by counting occurrences of \\( in a regexp from left to right. Backslash followed by a digit n matches the same text matched by the nth parenthesized subexpression from earlier in the same regexp. So the expression \\(a+b\\)\\1 matches abab, aabaab, and aaabaaab, but not abaab. The empty string can be matched in a wide variety of ways. \\\u0026rsquo;: matches the empty string that\u0026rsquo;s at the beginning of the buffer. \\ \u0026lsquo;: matches the empty string that\u0026rsquo;s at the end of the buffer. \u0026lsquo;=: matches the empty string that\u0026rsquo;s at the current location of point. \\b: matches the empty string that\u0026rsquo;s at the beginning or end of a word. \\B: matches the empty string that\u0026rsquo;s anywhere but at the beginning or end of a word. \\\u0026lt;: matches the empty string at the beginning of a word only. \\\u0026gt;: matches the empty string at the end of a word only. 相关函数 regexp-quote\nwhich understands regexp syntax and can turn a possibly-magic string into the corresponding non-magic one. 它个函数可以将一个包含魔术字符的字符串转为没有魔术字符的字符串.\nre-search-forward\n查询一个正则表达式，如果查询成功，它就紧接在最后的目标字符后面设置位点。如果查询是朝向进行的，就在第一个目标字符之前设置位点。\n(re-search-forward \u0026quot;regular-expression\u0026quot; ;;第一参量是正则表达式 limit-of-search ;; 第二个参量是可选的， 它限制函数查询的范围；它是在缓冲区中指定一个位置的约束值 what-to-do-if-search-fails ;; 第三个参量是可选的， 它告诉函数如果对查询失败做出响应： 如果第三个参量是nil， 函数在查询失败时产生一个错误消息；如果第三个参量是其他值，函数在查询失败时返回nil， 查询成功时返回t repeat-count) ;; 第四个参量也是可选的，它是一个重复计数。一个负的重复计数使re-search-forward函数向后查询。 replace-match\n(replace-match new-string ;; new string to insert preserve-case ;; preserve alphabetic case in new-string literal ;; set t means 'treat new-string literally.' if it's nil, then replacematch interprets new-string according to some special syntax rules. base-string ;; nil means 'Modify the current buffer', If this were a string, then replace-match would perform the replacement in the string instead of in a buffer. subexpression ;; is a digit means \u0026quot;Rplace submatch n\u0026quot; ) forward-paragraph\n函数将位点朝前移动到段落末尾。它一般绑定到M - }上。\n缓冲区 缓冲区名称： (buffer-name) 缓冲区所属文件名称： (buffer-file-name) 获取缓冲区本身： (current-buffer) 返回最近使用过的缓冲区： (other-buffer) 切换缓冲区： (switch-to-buffer (other-buffer)) 将计算机的注意力切换到另一个不同的缓冲区： (set-buffer (other-buffer)) 获取当前缓冲区的大小： (buffer-size) 光标在这个缓冲区中当前点位的字符计数： (point) 当前缓冲区中位点的最小可能值： (point-min) 当前缓冲区中位点的最大可能值： (point-max) 在光标当前位置设置一个标记： (push-mark) 将光标放到某处： (goto-char (point-min)): 将光标放到缓冲区的开始处 全选当前缓冲区： (mark-whole-buffer) C -x h 从当前缓冲区中拷贝一个域到一个指定缓冲区： (append-to-buffer buffer start end) 从一个缓冲区提取一个部分作为一个字符串： (insert-buffer-substring buffer start end) 找到存放某个函数或者变量的源代码的文件，并切换到这个缓冲区， 将位点置于相应函数或者变量的开始处： (find-tag) M - . 将另外一个缓冲区的内容拷贝到当前缓冲区： (insert-buffer) 判断参量是一个缓冲区还是一个缓冲区的名称： (bufferp buffer) 将光标移动到缓冲区的十分之几： (beginning-of-buffer) C - u {1 - 10} M - \u0026lt; 光标移动到下一行的行首： (forward-line) 删除当前缓冲区的全部内容： (erase-buffer) 显示光标所在的行： (what-line) 将光标当前位置与出现特定字符的下一个位置之间的这一区域中的文本剪切掉放到Kill环： zap-to-char M - z 删除文档的一部分, 并放到Kill环中： (kill-region beg end) 将区域中的文本复制一份到kill环中： (copy-region-as-kill beg end $optional REGION) 删除一个区域的内容： (delete-region start end) 变窄与增宽 剪切和存储文本 C -y 可以从Kill环中取出第一个元素插入到当前的缓冲区中如果C - y命令后紧跟一个M - y命令，则不是第一个元素而是第二个元素被插入到当前缓冲区中。连续的M - y命令则使第三个元素或第四个元素等代替第二个元素而被插入到当前缓冲区中。\nKill环 Kill环是文本字符串的一个列表。\nkill-ring\n指向Kill环\nkill-ring-yank-pointer\n指向Kill环的第二个字符串\nkill-ring-max\nkill环的最大容量\nDEFUN 参数 第一部分是Lisp中的函数名 第二部分是C语言中的函数名 第三部分是C常数结构名 第四部分和第五部分指定了函数中允许的参量数目的最小值与最大值 第六部分类似Lisp函数中interactive说明之后的参量。 第七部分是文档字符串 defsubst when function definitions are very short, it\u0026rsquo;s usually a goods idea to turn them into inlinefunctions using defsubst instead of defun.\ndrawbacks\nthat the inline function is duplicated everywhere it\u0026rsquo;s used, which can increase memory requirements. If the inline function definition changes, the old definition will still be \u0026ldquo;frozen\u0026rdquo; into compiled files that use it . Lisp File Loading the Files Finding Lisp Files\nEmacs can load files based on full path names: Emacs可以基于全路径加载文件. Emacs can load files based on a files\u0026rsquo;s base name, Emacs find it among the directories in the loadpath: Emacs可以基于一个基础文件名去加载文件,Emacs会去loadpath指定的目录去找这个文件. Interactive Loading 交互式加载\nload-file\ndoes not search load-path uses the normal filename-prompting mechanisms. 会有正常的文件名提示.\nload-library\ncan find library in the load-path It does not use filename-prompting and completion.\nProgrammatic Loading 编程式加载\nExplicit loading 显示式载\n(load \u0026quot;filename or absolute file\u0026quot;) Conditional loading\nrequire and provide\ngive a way to make sure it only gets loaded once instead of n times.\n(provide 'lib-name) (require 'lib-name) (require 'lib-name \u0026quot;lib-name\u0026quot;) ;; means if the lib-name feature is not yet present , load lib-name(use load, which searches load-path) ;; if the filename is the \u0026quot;string equivalent\u0026quot; of the feature name, then the filename can be omitted and will be inferred from the feature name. ;; so can use (require 'lib-name) instead of (require 'lib-name \u0026quot;lib-name\u0026quot;) autoloading\nwith autoloading, you can arrange to defer loading a file until it\u0026rsquo;s needed that is , until you call one of its functions. 使用autoload, 你可以在使用动指定模块的指定函数时才会自动加载这个模块.\n(autoload 'insert-date \u0026quot;timestamp\u0026quot; \u0026quot;docstring\u0026quot;) ;; insert-date : 函数名 ;; timestamp: 模块名 ;; docstring: 函数说明. compiling the File\nThere are serveral ways to byte-compile files. The most straightforward ways are\nFrom within Emacs: Execute M-x byte-compile-file RET filename.el RET From the Unix shell: Run Emacs -batch -f batch-byte-compilefile.el eval-after-load\nIf you\u0026rsquo;d like to defer the execution of some code until a particular file has been loaded, eval-after-load is the way to do it. So\n(eval-after-load \u0026quot;dired\u0026quot; (defun dired-sort-toggle ())) Emacs 一些函数 (seq-default key value)\n在缓冲区中设置值，而不是为变量设置它自己的局部值。\n(global-set-key \u0026ldquo;\\C -c w\u0026rdquo; \u0026lsquo;funcname)\n设置全局性的绑定键\n(global-unset-key (kbd \u0026ldquo;C - c\u0026rdquo;))\n取消全局绑定键\n(setq load-path (cons \u0026ldquo;~/.emacs/config\u0026rdquo; load-path))\n将~/.emacs/config目录添加到加载目录列表中。\n(setq debug-on-error t)\n这个表达式使Emacs在它下一次遇到一个错误的时候进入调试器。\nM - x debug-on-entry RET triangle-bugged RET\n当你调用一个函数的时候进入调度器， 按d前进， 按q退出\nM - x cancel-debug-on-entry RET triangle-deubgged RET\n退出Debug调试器\n(debug)\n当代码运行到这一行的时候进入调试器\n(next-error): 下一个错误 C - x ` (transpose-chars ARG): 切换两个字 C - t (org-transpose-words): 切换两个单词 M - t (transpose-lines ARG): 切换两行 C - x C - t (transpose-sentences): 切换两个句子的位置 (transpose-paragraphs): 切换两个段落的位置。 切换单词的大小写\n(capitalize-word): 把单词的首字母改为大写： ESC c (upcase-word): 把单词的字母全部改为大写： ESC u (downcase-word): 把单词的字母全部改为小写： ESC l 中止与撤消\n(keyboard-quit): 放弃当前命令： C - g (advertised-undo): 撤消上一次编辑（可重复使用）: C - x u (undo): 撤消上一次编辑： C - _ 或 C - / (revert-buffer): 把缓冲区恢复到上𥪐对文件进行存盘时的状态。 Major Mode Major mode Skeleton\nChoose a name .The name for our mode is quip create a file called name.el to contain the code for the mode. Define a variable called name-mode-hook. This will contain the user\u0026rsquo;s hook functions to execute when entering the mode. (defvar quip-mode-hook nil \u0026quot;*List of functions to call when entering Quip mode.*\u0026quot;) If appropriate, define a mode-specific keymap . Put it in a variable called name-mode-up. Create a mode\u0026rsquo;s keymap like this: (defvar name-mode-map nil \u0026quot;Keymap for name major mode.\u0026quot;) (if name-mode-map nil (setq name-mode-map (make-keymap)) (define-key name-mode-map keysequence command) ...) instead of make-keymap, youi could use make-sparse-keymap, which is better suited to keymaps that contain only a few keybindings. If appropriate, define a mode-specific syntax table. Put it in a variable named name-mode-syntax-table. If appropriate, define a mode-specific abbrev table. Put it in a variable named name-mode-abbrev-table. Define a command named name-mode. This is the major mode command, and it tabkes no arguments(unlike a minor mode command, which takes one optional argument). When executed, it should cause the current buffer to enter name-mode by performing the following steps: It must call kill-all-local-variables, which removes the definitions for all buffer-local variables. This effectively turns off whatever modes, major and minor, were previously active. (kill-all-local-variables) It must set the variable marjor-mode to name-mode. (setq major-mode 'quip-mode) It must set the variable mode-name to a shor string describing the mode, to be used in the buffer\u0026rsquo;s mode line (setq mode-name \u0026ldquo;Quip\u0026rdquo;) It must install the mode-specific keymap, if any, by calling use-local-map on name-mode-map. It must run the user\u0026rsquo;s hook functions by calling run-hooks on namemode-hook. (run-hooks 'quip-mode-hook) It must \u0026ldquo;provide\u0026rdquo; the feature implemented by this mode by calling provide on name. (provide 'quip) ; allows users to (require 'quip) define-derived-mode\n从一个模式推导一个新模式。\n(define-derived-mode new-mode old-mode mode-line-string docstring body1 body2 ...) 宏 相关函数 macroexpand\n宏展开\nTips 宏与函数的区别\n函数不会修改外部变量的值，而宏会把传进去的参数做一个宏展开，会修改外部变量。\n` Backquote\n`引用的S表达式里如果使用了,符号会展开,符号关联的S表达式。\n,@varname: 将参数中的最外层括号去掉。将参数拼接到代码中\n(defmacro limited-save-excursion (\u0026amp;rest subexprs) \u0026quot;Like save-excursion, but only restores point. \u0026quot; '(let ((roig-point (point))) ,@subexprs (goto-char orig-point)) ) make-symbol\n创建符号，\nunwind-protect\n它可以在出现错误或使用throw时进行一些清理操作\n(defmacro limited-save-excusion (\u0026amp;rest subexprs) \u0026quot;Like save-excursion, but only restores point.\u0026quot; (let ((orig-point-symbol (make-symbol \u0026quot;orig-point\u0026quot;))) '(let ((,orig-point-symbol (point))) (unwind-protect (progn ,@subexprs) (goto-char ,orig-point-symbol))))) 库 use-package :init\n会在require之前执行\n:config\n会在require之后执行， 里边如果有多条语句，可以使用(progn)包起来。\n:commands\n当我们调用一个命令的时候才加载对应的包\n:bind\n修改按键绑定\n","permalink":"https://stoneepigraph.github.io/posts/emacslisp/","title":"Emacs Lisp"},{"content":" 类的加载,连接与初始化 加载 指的是将类的.class文件中的二进制数据读入到内存当中,将其放在运行时数据区的方法区内,然后在内存中创建一个java.lang.Class对象.\n类的加载方式 从本地系统中直接加载 从网络下载.class 从zip, jar等归档中加载.class文件 从专有数据库中提取.class文件 将Java源文件动态的编译为.class文件 连接 验证确保被加载的类的正确性 准备为类的静态变量分配内存,并将其初始化为默认值 解析把类中的符号引用转换为直接引用 类的使用 主动使用 创建类的实例 访问某个类或接口的静态变量或对静态变量赋值 访问类的静态方法 反射 初始化一个类的子类 Java虚拟机启动时被标明为启动类的类 JDK1.7开始提供的动态语言支持：java.lang.invoke.MethodHandler实例的解析结果REF_getStatic, REF_PUTsTATIC, REF_invokeStatic句柄对应的类没有初始化，则初始化。 被动使用 初始化 所有的Java虚拟机实现必须在每个类或接口被Java程序\u0026quot;首次主动使用\u0026quot;时才进行初始化.\n注意 当一个常量的值并非编译期间可以确定的,那么其值就不会被放到调用类的常量池中,这时在程序运行时,会导致主动使用这个常量所在的类,显然会导致这个类被初始化. 主动使用的方式 创建类的实例 访问某个类或接口的静态变量,或者对该静态变量赋值 调用类的静态方法 反射如Class.forName(\u0026ldquo;com.path.ClassName\u0026rdquo;) 初始化一个类的子类 Java虚拟机启动时被标明为启动类的类 JDK1.7开始提供的动态语言支持. 虚拟机参数 Tips 说明 -XX:+\u0026lt;option\u0026gt;, 表示开启option选项 -XX:-\u0026lt;option\u0026gt;, 表示关闭option选项 -XX:\u0026lt;option\u0026gt;=\u0026lt;value\u0026gt;, 表示将option选项的值设置为value 参数 \u0026ndash;XX:+TraceClassLoading: 用于追踪类的加载信息并打印出来. -Xss1M: 设置最大调用深度，防止栈举出。StackOverflowError。 -XX:MaxTenuringThreshold: 指定新征伐对象经过多少次回收后进入老年代，默认为15次。 -XX:PretenureSizeThreshold: 指定对象的大小超过在指定的大小之后，直接晋升老年代。 TLAB -XX:+UseTLBA: 使用TLAB, 默认开启。 -XX:+TLABSize: 设置TLAB大小 -XX:TLABRefillWasteFraction：设置维护进入TLAB空间的单个对象大小，他是一个比例值，默认为64,即如果对象大于整个空间的1/64,则在堆创建对象。 -XX:+printTLAB：查看TLAB。 -XX:ResizeTLAB: 自调整TLABRefillWasteFraction阀值。 垃圾收集器 -XX：UseSerialGC： 使用串行垃圾回收器。 -XX:+useParNewGC: 新生代使用ParNew回收器。老年代使用串行回收器。 -XX:parallelGCThreads： 指定Parnew收集器的线程数。 ParallelGC -XX:MaxGCPauseMills: 设置最大垃圾收集停顿时间。 -XX：GCTimeRatio： 设置吞量大小，它是一个0到100之间的整数，默认为100。 -XX:UseAdaptiveSizePolicy: 打开自适应模式。 CMS -XX:+UseConcMarkSweepGC -XX:ConcGCThreads:设置并发线程数量。 虚拟机调优策略 JVM参数调优主要设置堆内存，主要让GC不要去频繁回收垃圾，减少对老年代的回收。配置时让-Xms与-Xmx一致。\n初始内存和最大内存越大，吞量就大，初始内存与最大内一致。 并行回收比串行回收吞量要大，多核多线程吞吐。 垃圾回收机制次数越少，说明性能越高。 垃圾回收算法 Q 为什么新生代和老年代使用不一样的压缩算法。 主要回收算法 引用计数算法 问题\n无法处理交叉引用的情况 复制算法 一般在新生代使用\n标记清除算法 一般老年代才会使用问题：\n内存碎片问题。 标记压缩算法 一般在老年代使用， 是标记清除算法的升级。\n分代算法 根据对象的特点把内存分成N块，而后根据每个内存的特点使用不同的算法。对于新生代和老年代来说，新生代回收频率很高，但是每次回收消耗时间很短，而对老年代回收频率较低，但每次消耗时间较长，所以应当尽量减少老年代的回收。\n分区算法 JDK1.7新增的算法。主要是将整个内存分为N个独立空间，每个小空间都可以独立使用，这样细粒度的控制一次回收多少个小空间，而不是对整个内存空间进行GC，从而提升性能，并减少GC的停顿时间。\n内存分区 程序计数器指向当前线程正在执行的字节码指令的地址 栈/虚拟机栈存储当前线程运行方法所需要的数据、指令、返回地址。以栈帧（局部变量表，操作数栈，动态链接，出口。。。）为单位。 本地方法栈 方法区类信息，常量，静态变量，JIT JDK1.8以前还有永久代。 堆堆分为新生代和老年代。新生代分为eden区，s0区，s1区（hotSpot比例为8：1：1）。新生区与老年区的大小一般比例是1比2或者1比3 TLAB Thread Local Allocation Buffer 即线程本地分配缓存，线程专用的个内存分配区域，是为了加速对象分配而生的。每一个线程都会产生一个TLAB，该线程独享的工作区域。 对象创建 对象创建流程 尝试栈上分配。 尝试TLAB区 是否满足进入老年代 eden分配。 垃圾收集器 分类 串行回收器 并行回收器 CMS Concurrent Mark Sweep 并发标记清除回收器。 -XX：CMSInitiatingOccupancyFraction默认为68,即当老年代的空间使用率达到68%的时候，会执行CMS回收。 G1 助记符 ldc 表示将int, float或是String类型的常量值从常量池中推送到栈顶. bipush 表示将单字节(-128~127)的常量推送至栈顶. sipush 表示将一个短整型常量值(-32768~32767)推送至栈顶. iconst_1 表示将一个int类型1推送至栈顶. (iconst_m1 ~ iconst_5) anewarray 表示创建一个引用类型的(如类,接口,数组)数组,并将其引用值压入栈顶. newarray 表示创建一个指定的原始类型(如float, int, char等)数组,并将其引用值压入栈顶 JVM监控工具 jps 查询java进程的一些基本信息，比如PID\njvisualvm jconsole jcmd jmc 一个界面的大成功能\njhat 分析堆转储文件\njmap 使用jmap命令生成dump文件 java -dump:live, format=b,file=filepath\\filename.hprof pid\r问题 内存溢出与内存泄露 内存泄露：对象已经没有被应用程序使用，但是垃圾回收器没办法移除它们，因为还在被引用着。内存溢出：需要的内存比支持的内存要多。\n垃圾回收线程频繁使用的缺点 垃圾回收执行时所有的其他线程都会暂停，会影响程序效率。\n","permalink":"https://stoneepigraph.github.io/posts/jvm/","title":"JVM简述"},{"content":" 入门 模板 + 数据模型 = 输出 数据模型 数据模型的基本结构是树状的. 标量用于存储单一的值.这种类型的值可以是字符串,数字,日期/时间或者布尔值 哈希表是一种存储变量及其相关且有唯一标识名称的容器 序列是存储有序变量的容器.存储的变量可以通过数字索引来检索,索引通常从0开始. 值域 start..end: 包含结尾的值域 start..\u0026lt;end或者start..!end: 不包含结尾的值域 start..*length: 限定长度的值域. start..: 无右边界值域. 注意\n值域表达式本身没有方括号 可以在..的两侧编写自述表达式而不需要圆括号 .., ..\u0026lt;, ..!, ..*是去处符,所以它们中间不能有空格. 无右边界值域的定义大小是2147483647 值域并不存储它们包含的数字. 哈希表 像连接字符串那样,也可以使用加号的方式来连接哈希表.如果两个哈希表含有键相同的项,那么在加号右侧的哈希表中的项优先. 模板 插值: ${paramsName} FTL标签 FTL标签与HTML标签有一些相似之处,这些标签的名称以#开头, 用户自定义的FTL标签则需要使用@来代替#. 注释注释使用\u0026lt;#\u0026ndash; and \u0026ndash;\u0026gt; 来标识 其它任何不是FTL标签,插值或注释的内容被视为静态文本,这些东西不会被FreeMarker所解析, 会被按照原样输出来. 基本指令 IF指令 \u0026lt;#if condition\u0026gt; \u0026lt;/#if\u0026gt; \u0026lt;#if condition\u0026gt; if statement \u0026lt;#elseif condition\u0026gt; elseif statement \u0026lt;#else\u0026gt; else statement \u0026lt;/#if\u0026gt; list指令展示列表内容 基本 \u0026lt;ul\u0026gt; \u0026lt;#list listObj as obj\u0026gt; \u0026lt;li\u0026gt;${ojb} \u0026lt;/#list\u0026gt; \u0026lt;/ul\u0026gt; 如果列表为空的话,整个列表都不展示 \u0026lt;#list listObj\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;#items as obj\u0026gt; \u0026lt;li\u0026gt;${obj} \u0026lt;/ul\u0026gt; \u0026lt;/#list\u0026gt; 如果列表为空的话展示一些其它信息 \u0026lt;#list listObj\u0026gt; \u0026lt;p\u0026gt; ListDesc: \u0026lt;ul\u0026gt; \u0026lt;#items as obj\u0026gt; \u0026lt;li\u0026gt;${obj}\u0026lt;#sep\u0026gt;septarator\u0026lt;/#sep\u0026gt; \u0026lt;/#items\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;#else\u0026gt; \u0026lt;p\u0026gt; list is empty. \u0026lt;/#list\u0026gt; include指令使用include指令, 我们可以在模板中插入其他文件的内容. 比如: 版权信息. \u0026lt;#include \u0026quot;filePath\u0026quot;\u0026gt; 联合使用指令 在页面中,指令间可以很容易地相互嵌套.\n内建函数 内建函数可以链式操作.\nuser?html 给出user的HTML转义版本 user?upper_case: 给出user值的大写版本 user?cap_first: 给出user的首字母大写版本 user?length: 给出user值中字符的数量 user?size: 给出user序列中项目的企业 如果在\u0026lt;#list animals as animal\u0026gt;和对应的\u0026lt;/#list\u0026gt;标签中 animal?index: 给出了在animals中基于0开始的animal的索引值 animal?counter: 也像index, 但是给出的是基于1的索引值 animal?item_parity: 基于当前计数的奇偶性,给出字符串\u0026quot;odd\u0026quot;或\u0026quot;even\u0026quot; 一些内奸函数需要参数来指定行为 animal.protected?string(\u0026ldquo;Y\u0026rdquo;, \u0026ldquo;N\u0026rdquo;): 基于animal.protected的布尔值来返回字符串\u0026quot;Y\u0026quot;或者\u0026quot;N\u0026quot; animal?item_cycle(\u0026rsquo;lightRow\u0026rsquo;, \u0026lsquo;darkRow\u0026rsquo;): 是之前item_parity更为常用的变形形式 animals.join(\u0026quot;, \u0026ldquo;): 通过连接所有项, 将列表转换为字符串,在每个项目之间插入参数分隔符. user?starts_with(\u0026ldquo;J\u0026rdquo;): 根据user的首字母是否是\u0026quot;J\u0026quot;返回布尔值true或false 处理不存在的变量 通过在变量名后面跟着一个叹号和默认值, 例 \u0026lt;h1\u0026gt; Welcome ${user!\u0026quot;visitor\u0026quot;}\u0026lt;h1\u0026gt; 通过在变量名后面放置??来询问一个变量是否存在.将它和if指定合并,那么如果user变量不存在的话将会忽略整个问题语句, 例: \u0026lt;#if user??\u0026gt;\u0026lt;h1\u0026gt;Welcome ${user}\u0026lt;/h1\u0026gt;\u0026lt;/#if\u0026gt; 其它 自定义指令 ","permalink":"https://stoneepigraph.github.io/posts/freemarker/","title":"FreeMarker入门"},{"content":" 规则 mtk 过滤整个文件夹 *.zip 过滤所有.zip文件 /mtk/do.c 过滤某个具体文件 !*.zip 反忽略 !/mtk/one.txt反忽略 *.a # 忽略所有 .a 结尾的文件 !lib.a # 但 lib.a 除外 /TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO build/ # 忽略 build/ 目录下的所有文件 doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt ","permalink":"https://stoneepigraph.github.io/posts/git/gitignore/","title":"Gitignore"},{"content":" Git常用命令 新建代码库 在当前目录新建一个Git代码库 \u0026gt; git init\n新建一个目录，将其初始化为Git代码库 \u0026gt; git init [Project_name]\n下载一个项目和它的整个代码历史 \u0026gt; git clone [url]\n配置 添加指定文件到暂存区 \u0026gt; git add [fileName] \u0026hellip;\n添加当前目录的所有的文档到暂存区 \u0026gt; git add .\n删除工作区文件，并且将这次删除放入暂存区 \u0026gt; git rm [fileName] \u0026hellip;\n停止追踪指定文件，但该文件会保留在工作区 \u0026gt; git rm \u0026ndash;cached [filename] 改名文件，并且将这个改名放入暂存区 \u0026gt; git mv [file-original] [file-renamed] 全局配置忽略Linux与Windows回车的类型 git config --global core.autocrlf true\r代码提交 提交暂存区到仓库区 \u0026gt; git commit -m [Message] 提交暂存区的指定文件到仓库区 \u0026gt; git commit [file1] [file2] \u0026hellip; -m [message] 提交工作区自上次commit之后的变化，直接到仓库区 \u0026gt; git commit -a 提交时显示所有diff信息 \u0026gt; git commit -v 使用一次新的commit, 替代上一次提交，如果代码没有变化，则用来改写上一次commit的提交信息 \u0026gt; git commit \u0026ndash;amend -m [message] 重做上一次commit, 并包括指定文件的新变化 \u0026gt; git commit \u0026ndash;amend \u0026hellip; 分支 列出所有本地分支 \u0026gt; git branch\n列出所有远程分支 \u0026gt; git branch -r 列出所有本地分支和远程分支 \u0026gt; git branch -a 新建一个分支，但依然停留在当前分支 \u0026gt; git branch [branch_name]\n新建一个分支，并切换到该分支 \u0026gt; git checkout -b [branch_name] 新建一个分支，指向指定的commit \u0026gt; git branch [branch_name] [commit_id]\n新建一个分支，与指定的远程分支建立追踪关系 \u0026gt; git branch \u0026ndash;track [branch_name] [remote_branch] 切换到指定分支，并更新工作区 \u0026gt; git checkout [branch_name]\n建立追踪关系，在现有分支与指定远程分支之间 \u0026gt; git branch \u0026ndash;set-upstream [branch_name] [remote-branch] 合并指定分支到当前分支 \u0026gt; git merge [branch_name]\n选择一个commit,合并到当前分支 \u0026gt; git cherry-pick [commit] 删除分支 \u0026gt; git branch -d [branch_name] 删除远程分支 \u0026gt; git push origin \u0026ndash;delete \u0026gt; git branch -dr 列出所有tag \u0026gt; git tag\n新建一个Tag在当前commit \u0026gt; git tag [tag_name]\n查看tag信息 \u0026gt; git show [tag_name]\n提交指定Tag \u0026gt; git push [remote] [tag]\n提交所有Tag \u0026gt; git push [remote] \u0026ndash;tags 新建一个分支，指向某个Tag \u0026gt; git checkout -b [branch_name] [tag_name] 查看信息 显示有变更的文件 \u0026gt; git status\n显示当前分支的版本历史 \u0026gt; git log\n显示commit历史，以及每次commit发生变更的文件 \u0026gt; git log \u0026ndash;stat 显示某个文件的版本历史，包括文件改名 \u0026gt; git log \u0026ndash;follow [file] \u0026gt; git whatchanged [file]\n显示指定文件相关的每一次diff \u0026gt; git log -p [file] 显示指定文件是什么人在什么时候修改过 \u0026gt; git blame [file_name]\n显示暂存区和工作区的差异 \u0026gt; git diff\n显示暂存区和上一个commit的差异 \u0026gt; git diff \u0026ndash;cached [] 显示工作区与当前分支最新commit之间的差异 \u0026gt; git diff HEAD\n显示两次提交之间的差异 \u0026gt; git diff [first_branch] \u0026hellip; [second_branch]\n显示某次提交的元数据和内容变化 \u0026gt; git show [commit]\n显示某次提交发生变化的文件 \u0026gt; git show \u0026ndash;name-only [commit] 显示某次提交旱，某个文件的内容 \u0026gt; git show [commit]:[fileName]\n显示当前分支的最近几次提交 \u0026gt; git reflog\n查看哪些文件在某个提交commit中有变更 git whatchanged 远程同步 下载远程仓库的所有变动 \u0026gt; git fetch [remote]\n显示所有远程仓库 \u0026gt; git remote -v 显示某个远程仓库的信息 \u0026gt; git remote show [remote]\n增加一个新的远程仓库，并命名 \u0026gt; git remote add [shornamt] [url]\n取回远程仓库的变化，并与本地分支合并 \u0026gt; git pull [remote] [branch]\n上传本地指定分支到远程仓库 \u0026gt; git push [remote] [branch]\n强行推送当前分支到远程仓库，即使有冲突 \u0026gt; git push [remote] \u0026ndash;force 推送所有分支到远程仓库 \u0026gt; git push [remote] \u0026ndash;all 撤消 恢复暂存区的指定文件到工作区 \u0026gt; git checkout [filename]\n恢复某个commit的指定文件到工作区 \u0026gt; git checkout [commit] [file]\n恢复上一个commit的所有文件到工作区 \u0026gt; git checout .\n重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 \u0026gt; git reset [file]\n重置暂存区与工作区， 与上一次commit保持一致 \u0026gt; git reset \u0026ndash;hard 重置当前分支 的指针 为指定 commit, 同时重置暂存区，但工作区不变 \u0026gt; git reset [commit]\n重置当前分支 的HEAD为指定commit,同时重置暂存区和工作区，与指定commit一致 \u0026gt; git reset \u0026ndash;hard [commit] 重置当前HEAD为指定commit， 但保持 暂存区和工作区不变 \u0026gt; git reset \u0026ndash;keep [commit] 新建一个commit，用来撤消指定的commit,后者的所有变化 都将被前者抵消，并且 应用到当前分支 \u0026gt; git revert [commit]\n其他 生成一个可供发布的压缩包 git archiv 备份当前工作区的修改 git stash 备份当前工作区的修改及新增 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容 git stash pop 显示Git栈内的所有备份 git stash list 清空Git栈 git stash clear Other git init # 初始化本地git仓库（创建新仓库） git config \u0026ndash;global user.name \u0026ldquo;xxx\u0026rdquo; # 配置用户名 git config \u0026ndash;global user.email \u0026ldquo;xxx@xxx.com\u0026rdquo; # 配置邮件 git config \u0026ndash;global color.ui true # git status等命令自动着色 git config \u0026ndash;global color.status auto git config \u0026ndash;global color.diff auto git config \u0026ndash;global color.branch auto git config \u0026ndash;global color.interactive auto git clone git+ssh://git@192.168.53.168/VT.git # clone远程仓库 git status # 查看当前版本状态（是否修改） git add xyz # 添加xyz文件至index git add . # 增加当前子目录下所有更改过的文件至index git commit -m \u0026lsquo;xxx\u0026rsquo; # 提交 git commit \u0026ndash;amend -m \u0026lsquo;xxx\u0026rsquo; # 合并上一次提交（用于反复修改） git commit -am \u0026lsquo;xxx\u0026rsquo; # 将add和commit合为一步 git rm xxx # 删除index中的文件 git rm -r * # 递归删除 git log # 显示提交日志 git log -1 # 显示1行日志 -n为n行 git log -5 git log \u0026ndash;stat # 显示提交日志及相关变动文件 git log -p -m git log \u0026ndash;online \u0026ndash;since=\u0026ldquo;2022-01-01\u0026rdquo; \u0026ndash;until=\u0026ldquo;2022-12-01\u0026rdquo; \u0026ndash;author=\u0026ldquo;WhatsUpeng\u0026rdquo; # 查看WhatsUpeng在2022-01-02至2022-12-01的所有的提交纪录。 git show dfb02e6e4f2f7b573337763e5c0013802e392818 # 显示某个提交的详细内容 git show dfb02 # 可只用commitid的前几位 git show HEAD # 显示HEAD提交日志 git show HEAD^ # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本 git tag # 显示已存在的tag git tag -a v2.0 -m \u0026lsquo;xxx\u0026rsquo; # 增加v2.0的tag git show v2.0 # 显示v2.0的日志及详细内容 git log v2.0 # 显示v2.0的日志 git diff # 显示所有未添加至index的变更 git diff \u0026ndash;cached # 显示所有已添加index但还未commit的变更 git diff HEAD^ # 比较与上一个版本的差异 git diff HEAD \u0026ndash; ./lib # 比较与HEAD版本lib目录的差异 git diff origin/master..master # 比较远程分支master上有本地分支master上没有的 git diff origin/master..master \u0026ndash;stat # 只显示差异的文件，不显示具体内容 git remote add origin git+ssh://git@192.168.53.168/VT.git # 增加远程定义（用于push/pull/fetch） git branch # 显示本地分支 git branch \u0026ndash;contains 50089 # 显示包含提交50089的分支 git branch -a # 显示所有分支 git branch -r # 显示所有原创分支 git branch \u0026ndash;merged # 显示所有已合并到当前分支的分支 git branch \u0026ndash;no-merged # 显示所有未合并到当前分支的分支 git branch -m master master_copy # 本地分支改名 git checkout -b master_copy # 从当前分支创建新分支master_copy并检出 git checkout -b master master_copy # 上面的完整版 git checkout features/performance # 检出已存在的features/performance分支 git checkout \u0026ndash;track hotfixes/BJVEP933 # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支 git checkout v2.0 # 检出版本v2.0 git checkout -b devel origin/develop # 从远程分支develop创建新本地分支devel并检出 git checkout \u0026ndash; README # 检出head版本的README文件（可用于修改错误回退） git merge origin/master # 合并远程master分支至当前分支 git cherry-pick ff44785404a8e # 合并提交ff44785404a8e的修改 git push origin master # 将当前分支push到远程master分支 git push origin :hotfixes/BJVEP933 # 删除远程仓库的hotfixes/BJVEP933分支 git push \u0026ndash;tags # 把所有tag推送到远程仓库 git fetch # 获取所有远程分支（不更新本地分支，另需merge） git fetch \u0026ndash;prune # 获取所有原创分支并清除服务器上已删掉的分支 git pull origin master # 获取远程分支master并merge到当前分支 git mv README README2 # 重命名文件README为README2 git reset \u0026ndash;hard HEAD # 将当前版本重置为HEAD（通常用于merge失败回退） git rebase git branch -d hotfixes/BJVEP933 # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支） git rebase -i HEADn # 合并前n次提交为一次提交 git branch -D hotfixes/BJVEP933 # 强制删除分支hotfixes/BJVEP933 git ls-files # 列出git index包含的文件 git show-branch # 图示当前分支历史 git show-branch \u0026ndash;all # 图示所有分支历史 git whatchanged # 显示提交历史对应的文件修改 git revert dfb02e6e4f2f7b573337763e5c0013802e392818 # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818 git ls-tree HEAD # 内部命令：显示某个git对象 git rev-parse v2.0 # 内部命令：显示某个ref对于的SHA1 HASH git reflog # 显示所有提交，包括孤立节点 git show HEAD@{5} git show master@{yesterday} # 显示master分支昨天的状态 git log \u0026ndash;pretty=format:\u0026rsquo;%h %s\u0026rsquo; \u0026ndash;graph # 图示提交日志 git show HEAD3 git show -s \u0026ndash;pretty=raw 2be7fcb476 git stash # 暂存当前修改，将所有至为HEAD状态 git stash list # 查看所有暂存 git stash show -p stash@{0} # 参考第一次暂存 git stash apply stash@{0} # 应用第一次暂存 git grep \u0026ldquo;delete from\u0026rdquo; # 文件中搜索文本“delete from” git grep -e \u0026lsquo;#define\u0026rsquo; \u0026ndash;and -e SORT_DIRENT git gc git fsck git config \u0026ndash;global core.autocrlf input\t# 在LInux下忽略Winodws与Linux的换行符的不同\nTips 忽略文件Mode的配置 git config --add core.filemode false\r常用问题处理 push相关 ! [remote rejected] master -\u0026gt; master (shallow update not allowed) 原因\n因为使用git clone时使用了\u0026ndash;depth \u0026lt;number\u0026gt;复制本地版本。这样的克隆将限制你不能将它捈新的存储库。 解决\n如果想把它推入到新的存储库，需要从旧存储库中拉取所有深度 git fetch --unshallow oldOrigin\r","permalink":"https://stoneepigraph.github.io/posts/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","title":"Git常用命令"},{"content":" Maven库： http://repo2.maven.org/maven2/\nMaven依赖查询： http://mvnrepository.com/\nMaven常用命令： 创建Maven的普通java项目： mvn archetype:create -DgroupId=packageName -DartifactId=projectName 创建Maven的Web项目： ​ mvn archetype:create ​ -DgroupId=packageName ​ -DartifactId=webappName ​ -DarchetypeArtifactId=maven-archetype-webapp\n编译源代码： mvn compile 编译测试代码：mvn test-compile 运行测试：mvn test 产生site：mvn site 打包：mvn package 在本地Repository中安装jar：mvn install 清除产生的项目：mvn clean 生成eclipse项目：mvn eclipse:eclipse 生成idea项目：mvn idea:idea 组合使用goal命令，如只打包不测试：mvn -Dtest package 编译测试的内容：mvn test-compile 只打jar包: mvn jar:jar 只测试而不编译，也不测试编译：mvn test -skipping compile -skipping test-compile ​ ( -skipping 的灵活运用，当然也可以用于其他组合命令)\n清除eclipse的一些系统设置:mvn eclipse:clean ps：一 般使用情况是这样，首先通过cvs或svn下载代码到本机，然后执行mvn eclipse:eclipse生成ecllipse项目文件，然后导入到eclipse就行了；修改代码后执行mvn compile或mvn test检验，也可以下载eclipse的maven插件。 mvn -version/-v 显示版本信息 mvn archetype:generate 创建mvn项目 mvn archetype:create -DgroupId=com.oreilly -DartifactId=my-app 创建mvn项目 mvn package 生成target目录，编译、测试代码，生成测试报告，生成jar/war文件 mvn jetty:run 运行项目于jetty上, mvn compile 编译 mvn test 编译并测试 mvn clean 清空生成的文件 mvn site 生成项目相关信息的网站 mvn -Dwtpversion=1.0 eclipse:eclipse 生成Wtp插件的Web项目 mvn -Dwtpversion=1.0 eclipse:clean 清除Eclipse项目的配置信息(Web项目) mvn eclipse:eclipse 将项目转化为Eclipse项目在应用程序用使用多个存储库\n\u0026lt;repositories\u0026gt; ​ \u0026lt;repository\u0026gt; ​ \u0026lt;id\u0026gt;Ibiblio\u0026lt;/id\u0026gt; ​ \u0026lt;name\u0026gt;Ibiblio\u0026lt;/name\u0026gt; ​ \u0026lt;url\u0026gt;http://www.ibiblio.org/maven/\u0026lt;/url\u0026gt; ​ \u0026lt;/repository\u0026gt; ​ \u0026lt;repository\u0026gt; ​ \u0026lt;id\u0026gt;PlanetMirror\u0026lt;/id\u0026gt; ​ \u0026lt;name\u0026gt;Planet Mirror\u0026lt;/name\u0026gt; ​ \u0026lt;url\u0026gt;http://public.planetmirror.com/pub/maven/\u0026lt;/url\u0026gt; ​ \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; mvn deploy:deploy-file -DgroupId=com -DartifactId=client -Dversion=0.1.0 -Dpackaging=jar -Dfile=d:client-0.1.0.jar -DrepositoryId=maven-repository-inner -Durl=ftp://xxxxxxx/opt/maven/repository/ 发布第三方Jar到本地库中： mvn install:install-file -DgroupId=com -DartifactId=client -Dversion=0.1.0 -Dpackaging=jar -Dfile=d:client-0.1.0.jar -DdownloadSources=true -DdownloadJavadocs=true mvn -e 显示详细错误 信息. mvn validate 验证工程是否正确，所有需要的资源是否可用。 mvn test-compile 编译项目测试代码。 。 mvn integration-test 在集成测试可以运行的环境中处理和发布包。 mvn verify 运行任何检查，验证包是否有效且达到质量标准。 mvn generate-sources 产生应用需要的任何额外的源代码，如xdoclet。\n常用命令： mvn -v 显示版本 mvn -Dplugin=help 使用 help 插件的 describe 目标来输出 Maven Help 插件的信息。 mvn -Dplugin=help -Dfull 使用Help 插件输出完整的带有参数的目标列 mvn -Dplugin=compiler -Dmojo=compile -Dfull 获取单个目标的信息,设置 mojo 参数和 plugin 参数。此命令列出了Compiler 插件的compile 目标的所有信息 mvn -Dplugin=exec -Dfull 列出所有 Maven Exec 插件可用的目标 mvn 看这个“有效的 (effective)”POM，它暴露了 Maven的默认设置 mvn archetype:create -DgroupId=org.sonatype.mavenbook.ch03 -DartifactId=simple -DpackageName=org.sonatype.mavenbook 创建Maven的普通java项目，在命令行使用Maven Archetype 插件 mvn exec:java -Dexec.mainClass=org.sonatype.mavenbook.weather.Main Exec 插件让我们能够在不往 classpath 载入适当的依赖的情况下，运行这个程序 mvn dependency:resolve 打印出已解决依赖的列表 mvn dependency:tree 打印整个依赖树 mvn install -X 想要查看完整的依赖踪迹，包含那些因为冲突或者其它原因而被拒绝引入的构件，打开 Maven 的调试标记运行 mvn install -Dmaven.test.skip=true 给任何目标添加maven.test.skip 属性就能跳过测试 mvn install assembly:assembly 构建装配Maven Assembly 插件是一个用来创建你应用程序特有分发包的插件 mvn jetty:run 调用 Jetty 插件的 Run 目标在 Jetty Servlet 容器中启动 web 应用 mvn compile 编译你的项目 mvn clean install 删除再编译 mvn hibernate3:hbm2ddl 使用 Hibernate3 插件构造数据库\n","permalink":"https://stoneepigraph.github.io/posts/maven/","title":"maven基础"},{"content":" 常用SVN命令 svn checkout 签出,创建新的工作拷贝. svn info 搞清楚工作拷贝从哪里来的. svn update 从项目仓库中更新目录中的所有文件 svn add 添加文件的目录到项目仓库中 svn propset 设置文件的属性 svn add 添加文件 svn delete 删除文件 svn move src.file dist.file 移动文件 svn commit -m \u0026lsquo;提交信息\u0026rsquo; svn log filename 查看指定文件的历史 svn diff 展示文件版本之间的差异. 在版本之间找差异 svn diff -r19:21 filename 使用-r选项来指定一个版本范围 svn revert 删掉本地改动并使用项目仓库中的文件版本 svn resolved 修正冲突后执行 svn blame 显示每个文件的每一行最后的版本, 以及做出这个改动的人 svn update 获取最新的代码 svn merge -r 27:26 filename 移除file中版本27的改动 svn lock filename 给文件加锁 ","permalink":"https://stoneepigraph.github.io/posts/svn/","title":"SVN常用命令"},{"content":" 基础知识 UML图 类图 表述系统中各个对象的类型以及其间存在的各种静态关系.类图也示明类中的特性和操作以及用于对象连接方式的约束.\n聚合与组合\n聚合是整体-部分关系.\n可见性\n+: 公用 -: 私用 ~: 包 #: 受护 顺序图 顺序图能明晰地指出参加者交互方面的区别.不擅长于示明诸如循环与条件行为等算法细节,但却能使参加者之间的调用一目了然. 当你考查单个用例内部若干对象的行为时,\n用例图 用例通过表述系统的用户和系统本向之间特有的交互而工作,提供了如何使用系统的一种陈述.\n对象图 是在一个时间点上系统中各个对象的一个快照. 由于对象图示明的是实例而不是类,\n包图 在UML中用双冒号表示包名. 对大型系统要了解系统主要成分之间的依赖时,使用包图. 包图表示一种编译时刻的聚组机制.关于示明在运行时刻如何来组合各个对象.\n部署图 通过揭示\u0026quot;哪些软件片段运行于哪些硬件片段上\u0026quot;来示明系统的一个物理布局. 任何复杂的部署都可以很好地使用部署图.\n活动图 活动图可以示明组织机构的工作流,示明软件与人的活动如何交互.活动图还可以示明用例的环境发及复杂用例如何工作的细节. 考查跨用例或跨线程的行为,就考虑活动图. 活动图是一种表述过程基理,业务过程以及工作流的技术.\n分划\n分划示明一个类或一个机构单位施行哪些动作.\n信号\n活动图有明确定义的起点,它对应于程序或例和的启用.动作亦可对应于信号. 信号指明活动接收来自外部过程的一个事件.\n权标 流与边\n是UML2中用来表述两个动作之间连接的同义词.\n饰针与转换 展开区域\n展开区域是活动图上标出的一个区域,其中的动作对一个组中每一项均要发生一次.\n流终\n流终(flow final)指明在整个活动并未终止时,一个特定流的终结.\n汇合指明 何时使用活动图\n活动图最大的优点是,它们支持并鼓励并行行为.这使它们成为工作流建模和过程建模的一项重要工具.\n通信图 通信图是一种着重阐明交互中各个参加者之间的数据连接的交互图. 在UML1.x中,这些图称为协作图.\n构件图 状态图 如果一个概念具有有趣的生命周期,具有各种状态发及改变状态的事件,状态图则可能有用. 考虑用例的单个对象的行为,就用状态图.\n交互概观图 是将活动图与顺序图嫁接在一起的图.\n定时图 Tips 进行需求分析时,最重要的是与用户及客户有交流.通常他们都不是软件业人士,并且不熟悉UML或任何别的技术.要记住,不要引进软件实现所特有的任何东西 .不论何时都要准备背离UML的规则,如果它能帮助你更好地进行交流的话.在分析过程中使用UML最大风险是领域专家对你所绘的图不能完全理解.一个了解领域的人不理解的图比无用更坏,它所做的一切是使开发组产生一种错误的自信感. ","permalink":"https://stoneepigraph.github.io/posts/uml/","title":"UML"},{"content":" 为何这本书与你先前读过的任何书籍都迥然不同 讲述如何成为一名优秀的软件开发人员的书，优秀开发人员指的是那些能够把控自己的职业生涯，达成目标，享受生活的人。本书并不再讨论你能做什么，而是讨论你自己。关乎你的职业生涯，你的生活，你的身体，你的思想及你的灵魂。\n职业生涯：学习如何主动管理自己的职业生涯，从而达到自己追寻的结果。 自我营销：学习如何推销自己。 如何打造个人品牌，如何打造一个成功的博客，如何通过演讲，教学，著书立说的方式让你扬名立万。 学习：学习如何学习，学习如何自觉 生产力：关于如何让工作更加富有成效的 理财：学习如何有效地管理你赚到的财。 健身： 精神： 职业 你所能犯的最大错误就是相信自己是在为别人工作。这样一来你对工作的安全感已然尽失。职业发展的驱动力一定是来自个体本身。记住：工作是属于公司的，而职业生涯却是属于你自己的。体验决策过程：你要决定自己想要从软件开发这个职业中获得什么，以及如何去获得。\n从非同凡响开始：绝不要做其他人都在做的事 拥有商业心态 因为只有你开始把自己当作一个企业去思考时，你才能开始做出良好的商业决策。尽管在你的职业生涯的某个特定时间段里，你可能确实是在为某家公司打工，但是千万不要让那个特定的角色固化了你和你的整个职业生涯。我们需要把雇主当作是自己的软件开发企业的一个客户。\n如何像企业一样思考 理解企业的构成：首先，要有一个产品或服务，我的产品是什么？通常软件开发人员售卖的就是他们把一个想法变成一个数字化的现实产品的能力。作为一名软件开发人员，你提供的服务具备有形价值，你要传达的不仅是这款软件的价值是什么，还有它与别的成千上万款软件开发人员提供的服务有什么不同。同时，你需要认识到仅有服务或产品是不够的。想要赚钱，你就必须能让潜在的客户了解该产品或服务。所以我需要做到：\n专注于你正在提供怎样的服务，以及如何营销这项服务。 想方设法提升你的服务 思考你可以专注为哪一特定类型的客户或行业提供特定的服务 集中精力成为一位专家，专门为某一特定类型的客户提供专业的整体服务（记住，作为一个软件开发人员，你只有真正专注于一类客户，才能找到非常好的工作） 另外，还要想想如何更好地宣传你的服务，如何更好地找到你的客户。\n思考未来：你的目标是什么 定义你的业务目标要实现任何目标，都必须先知道目标是什么。\n如何设定目标 起步阶段最简单的就是在心中树立一个大目标，然后再建立能帮你达成这个大目标的小目标。因为很难清晰地界定远期可能发生的事情，所以大目标通常不是非常明确。不过大目标不一定要非常具体。只要目标能具体到给你提供清晰的方向即可。花点儿时间思考一下你的大目标，你希望从职业生涯中收获什么？你希望自己5年或10年之后在哪里？——这非常重要。一旦你想通了自己长远的大目标是什么，下一步注是设定路线，制订通往大目标的小目标。有时还可以运用一下逆向思维，反推一下如何从大目标到当前的情况。如果你可以驱动小目标逐渐前行并靠近你的大目标，那么你最终一定会达到目的地。\n追踪你的目标 你应该定期追踪并更新自己设定的目标，必要时还要调整。建议你定期核对自己的目标，这有助于在必要时进行调整，让你对自己负责。反思自己在短期和长期取得的成果是大有裨益的，你能够弄清自己是否取得了合理的进展，或者是否需要进行某些调整。\n人际交往能力：远比你想象的重要 别管我，我只想一个人安静地写代码 我曾经对软件开发人员的工作的印象就是写代码。事实上，在软件开发领域，我们大多数时候是与人而非与计算机打交道。甚至我们所写的代码首先是供人使用的，其次才是让计算机可以理解。\n学会如何与人打交道 每个人都希望感觉自己很重要\n当你和别人打交道的时候，你应该知道 的最重要的一个概念就是：以自己为核心，每个人都希望自己很重要。这是人类最深邃，最致命的欲望之一，也是社会和生活中取得伟大成就的主要动机。我们常常容易犯的一个错误就是，轻率地否决同事的想法，以便于可以提出自己的想法。然而承着你作出这样的错误判断，你往往会发现他们对你的想法充耳不闻，仅仅因为你让他们感觉自己是无足轻重的。如果你希望人们接受你的想法，并认可其中的价值，首先你最好先主动给他人相同的礼遇。如果你不能保全他人的自尊，那你永远也不可能赢得他的心。\n永远不要批评\n研究表明，奖励积极行为要比惩罚消极行为有效得多。\n换位思考\n在人际交往方面获得成功的关键在于：停止用“我”和“我想要什么“来思考。你应当开始思考对他人而言什么才最重要，什么才是他们需要的。\n避免争吵\n作为软件开发人员，我们有时候倾向于认为所有人是从逻辑角度来思考问题的，这很容易让你落入陷阱，错误地认为严谨的推理足以使他人接受你的思维方式。事情的真相是：尽管我们为自己的智慧感到骄傲，但人们依然是情感动物。我们就像那些穿着西装，打着领带，四处游荡的小孩，假装自己已经长大，其实任何轻微的伤害都能让我们号啕大哭，或者大发雷霆，我们只是已经学会了如何控制和隐藏这些情绪。如果你因为”该怎么做某事“与他人产生分歧，那么在很多情况下，你最好先确定分歧点是否值得你去拼命维护，特别是在你知道它已让他人卷入时。如果你从来没花时间来提高自己的人际交往能力，那现在正当其时。你会发现，当你学会了如何以令人愉悦的方式与他人互动和交往的时候，自己的生活也越来越愉快。通过买得这些技能，你积累了让自己获益终生的财富，它的价值无法用金钱衡量。\n破解面试之道 通过面试的最快捷的方式 通过面试最快捷的方式是让面试官对你怀有好感。达成该目标有很多方法，其中大多数可以在面试之前完成。\n我是如何得到最后一份工作的 我事先确定了我要入职的公司，我花了一些时间研究这家公司，找出这个公司有哪些开发人员在写博客。我开始关注为这家公司工作的开发人员的所有博客。并开始在他们的博客文章下留下经过沉思熟虑的评论。慢慢地，许多在这家公司供职的开发人员开始认识了我，并通过我给他们博客做出的评论知道了我是谁，他们中的一些人甚至开始读我的博客。接下来，当这家公司开始招聘开发人员的时候，我递交了申请。\n突破陈规，建立融洽关系 “破解”面试的要诀就是在面试开始之前就思考应对面试的策略。大量工作岗位来自“个人推荐”。你要试图确保你申请的职位也适用于个人推荐。所以你必须要突破常规，想尽办法与公司内部人员建立联系。随着社交媒体和互联网的广泛应用，你能非常容易地找到任何公司的各种信息，也容易与他们的员工建立联系。\n真正的面试会是什么样子的 如果顺利的话，在你走进面试间的时候，面试官已经知道你是谁了，但无论如何 ，你都需要了解在面试时自己该做什么。现在，很明显，你需要从技术能力上证明你可以通过技术面试。接下来要关注的事情就是自信地展示自己的能力。——知道要获得这份工作需要做什么，做就是了。对于公司来说招聘员工就是一项投资。与其雇用技术高超但需要生拉硬拽才能干活的人相比，宁愿雇用这样的开发人员：知道的东西可以少一点，但是明确知道要做什么，以及怎样去做。从某种程度上，在你可控的内，面试的时候你要集中精力证明自己就是无需督促也能自动自发做好事情的员工。你还必须要证明：在技术上你确实胜任工作。同时，如果你能说服面试官相信你非常能干，不会被困难阻挡，那么他们不仅会喜欢你，而且更有可能会录用你。\n当下你能做什么 不管你现在是正在积极寻找工作，还是给自己保留选择的余地，再没有比现在更好的时机去开始准备你的下一场求职面试了。你应该做的第一件事情是确保自己仍旧保持技术能力。所以确保自己一直阅读技术书籍和博客文章，并会花些时间提升自己的技能。你也可以未雨筹谋，拓展自己的社交网络。开始与本领域不同公司的员工接触，建立联系，他们日后会帮到你。通过阅读并评论他们的博客，认识本领域的其他开发人员甚至是招聘人员。想方设法扩大你的社交圈子。别忘了实践，即使你现在对换新工作毫无兴趣，为了获得面试经验，你也要去面试。集中精力推销自己会对你大有裨益。行动：\n即使你现在不需要努力找工作，也要整理一份清单，列出你想去工作的公司，以及你认识 的公司的人 在这份清单上的，如果有的公司你一个人都不认识，那么制订计划至少去认识这些公司中的一位员工，并与之建立联系。 在自己所在的领域找出至少一个本地用户组，参数聚会，并把自己介绍给尽可能多的人。 就业选择：列出你的选择 落入俗套很容易，循规蹈矩也很容易，只要跟其他人做一样的事情就是了。你自己甚至可能都不知道除了雇用型劳动关系之外还有其他选项。\n选择一：雇员 对广大软件开发人员而言，这是一项常见的，默认的就业选择。一部分原因是因为不知道还有其他选项，一部分在于这是最容易的选择。身为雇员的最大的好处就是稳定。作为一名雇员也是一条比其他选择更轻松的道路，因为你的职责是有限的，路线明晰。寻找和申请工作都有一个明确定义的流程。你也无需要操心“做什么才能赚钱”这种问题。作为一名雇员，你通常还有带薪年假。作为一名雇员的消极方面，很大部分与自由相关。此外，作为一名雇员也意味着你的收入是事先确定好的，这就意味着收入有一个“封顶”的界限。\n选择二：独立咨询师 作为独立咨询师，软件开发人员不再为特定的单个雇主工作，而是服务于一个或多个客户。如果你曾兼职为某个客户写程序，他们以时薪或固定价格付你报酬，那你就明白什么是咨询了。做独立咨询师最大的好处可能就是赚钱的潜力。作为独立咨询师，你其实就是名副其实的经营者（不仅仅指心态），你要负责税务，法律咨询，销售，健康保险以及各种与企业经营有关的事情。\n创业者 创业之路可能是你职业生涯中最验证，最不确定但却最具回报潜力的选择。“创业者”意味着软件开发者使用自己的软件技能开发自己的产品，拓展自己的业务。“创业者”的优势： 完全的自由和完全不封顶的赚钱潜力。但需要学习诸多方面的技能：销售，市场营销，以及商业和理财待。\n到底应该选哪个 选择什么完全取决于你自己，并且你也可以随时切换路径。虽然这并不容易。\n你是哪类软件开发人员 专业化很重要 有大量的软件开发人员并没有具体的专业方向。虽然专业化确实会把你关在一些机会的大门之外，但与此同时它将打开的机会大门要比你用其他方式打开的多得多。从表面上看，身为”专才“后，潜在雇主和客户群都变小了，但是实际上你对他们更具吸引力了。只要你专业能力雄厚，市场没有过度饱和，与那些自称为”软件开发人员“的人相当，你能更轻松地找到工作或者赢得客户。\n在一个专业方向上拥有专长 专业化的规则是：专业化程度越深，潜在的机会就越少，但获得这些机会的可能性越大。\n软件开发人员的专业类别 软件开发人员有很多不同的专业分类。比较明显的分类方法是按照开发语言分类和按照平台分类，但是也可以按照方法论分类，按照技术或业务各类分类。首先你得弄清楚一件事，自己想从事哪类软件开发工作。\n专业领域\nWeb开发栈 嵌入式系统 特定的操作系统 移动开发 框架 软件系统 选择你的专业 选择专业的技巧：\n在你现在或以前工作的公司里，有哪些主要的痛点？你能成为一名专门解决这些痛点的专家吗？ 有没有一种特定的工作是无人能做的，或者缺乏经验丰富的人？成为这个领域的专业，你就会获得大量业务。 在各种会议上和用户组中哪些话题最常出现？ 哪类问题你回复的最多，无论是针对同事还是在Stack Overflow这样的网站上。 无论你做什么，道德确保你选定了某些专业方向。市场规模决定了你的方向有多么具体，所以一定要尽可能地具体。\n精通多种语言的程序员怎么办 学富五车，或者灵活变通并同时仍有所专长让自己卓而不群。如果你非要二选一，那先从专业化开始，再拓展分支。行动：\n列出你能想到的所有软件开发的专业领域。从广义的范畴将它们逐一细化，看看你能细化到多具体 你当前专业领域是什么？如果没有的话，想想你会选择专攻哪个领域。 去主流的招聘网站上看看自己的专业领域市场行情如何。确定一下，专业化道路是会让自己受益，还是地度限制了自己的选择。 公司与公司是不一样的。 不仅公司规模决定你的工作体验，每个公司都有其独特的文化，深刻地影响着你的整体幸福感，存在感和归属感。在接受一份工作之前考虑这些是很重要的。从薪资和福利的角度评价一个潜在的工作机会是很容易的，但是从长期发展和工作环境的角度去评价可能对你更为重要。\n小公司和创业公司 大多数小公司都是创业公司，所以它们有着非常独特的”创业心态“。所谓创业心态通常表现为：关注快速增长，竭尽所能让公司盈利，或者达成其他一些迫切目标。在这样一家公司工作的软件开发人员，你极有可能要身兼多职，不能只写代码。但是如果你精力充沛，活力四射，喜欢迎接新挑战，那你就会对这种环境着迷。在一家小公司，你做的事情可能影响更大，可以说是好坏参半。小公司通常没有大公司稳定，但是长远来看，潜在的回报更大。\n中等规模的公司 大多数公司都是中等规模。在一家中等规模的公司里，角色定义通常很明确，你也会更稳定。我要说的是，中等规模 的公司往往比大公司还稳定，因为大公司往往还有大裁员或者周期性重组。在中等公司规模 的公司里工作，你可能 会发现工作节奏有点慢，但是想不为人知也很难。\n大公司 大公司非常有趣，每家都不同。大公司通常都有很深厚的公司文化，渗透到公司各个方面。在为一家大公司工作时，你会注意到的最大的事情 也许 就是那里大量的规范和流程。为大公司工作的一个显而易见的事情 就是成长 机会。许多 大公司提供职业 发展指导，帮助 你在组织内部 学习和成长。你也可能有机会做一些很酷的东西。中小规模的公司可没有如此庞大的预算去做改变世界的大型项目。但是对于许多 大公司而言，技术创新是很常见的。但对于很多软件开发人员而言，在大公司工作令人沮丧，因为他们感到他们个人的贡献无足轻重。关于大公司的最后一点是：办公室政治。大公司通常有着复杂的政治体制，堪比大型政府机构。\n软件开发公司与拥有软件开发人员的公司 谨慎选择 在接受工作之前与这家公司工作的开发人员聊一聊是个好主意，你能够更真切地体会在这家公司工作的感受。行动：\n花点时间思考自己喜欢什么样的工作环境，多大规模的公司符合你自己理想中的工作环境？ 列出在你所在地区的公司名录，或者你工作过的公司名录，看看它们分别属于哪种类型。 攀登晋升阶梯 承担责任 在任何公司里能让你脱颖页出的最重要法宝就是承担更多的责任。金钱总是追随着责任。有任何机会去承担更多责任时，承担起来！有时候你不得不去主动寻找机会，去负责一项任务，或者牵头一个项目。只要深入挖掘，你总能找到一些被忽视的业务领域去发挥自己的聪明才智。没有人愿意涉足的领域是搜寻机会最好的地方。如果你能把沼泽变为良田，你也就展现了自己的价值。另一种间接承担责任的方式是成为团队中其他人的导师，自愿帮助新人加速成长，为任何有需要的人提供帮助。通过介入和解决别人的问题，你不仅可以学到更多 自己专业之外的知识，而且随着时间推移，你还能在团队中逐步树立“及时雨”的名声。 如何能让自己承担更多责任\n有一个不受重视的项目，你能去负责它吗？ 你能帮助团队里的新人快速成长吗？ 你能负责文档制作流程，并保证及时更新这些文档吗？ 哪项工作是没有人愿意去做，你愿意承担起来，并将其简化或者自动化。 引人注目 如果你一直默默无闻，你的成就不为人知的话，即使你是团队中最聪明，最努力，最出色的开发人员，那也一文不值。 如何令自己引人注目\n每天都记录自己的活动日志：把这个日志以周报的形式发送给你的经理 提供演讲或培训：选择一个对你的团队有用的话题 发表意见： 只要在会议上就这么做，或者只要你能提到的机会就这么做。 保证“曝光度”： 定期与老板见面，确保你经常被注意到。 自学 另一个可以获得提升 的非常好的办法就是不断增加自己的技能和知识。在你不断提高自己的教育 水平时，很难停滞不前。自觉能力升职加薪变得容易，因为你可以很清楚地表明：现在的自己比之前更有价值。另外，不要只学软件开发。如果你把目标设定为更高级别的岗位甚至是行政岗位，你还需要学习领导力，管理和商科的相关知识 。知万不要忘记分享自己学到时的东西。你可通过演讲的方式分享自己的知识，也可以创建自己的博客，为杂志写文章或者写书，还要以在社区活动或者技术大会上发表演讲。外部曝光有助于你建立自己在该 领域的权威地位，也让你看起来对所供职的更有价值。\n成为问题的解决者 在任何组织中，总是有很多人会告诉 你为什么这个想法行不能，为什么那个问题太验证。这样的人不胜枚举。千万不要成为他们中的一员。相反，你要成为那个永远 能为各种问题找到解决方案的人，要成为勇于 执行这些解决方案以获得成果的人。在任何公司中，最有用的就是那咱看似没有克服不了的障碍的人。\n关于政治 行动：\n在你当前的工作岗位上，你可以通过何种方式承担更多的职责？ 对于你的老板 和经理，你现在的“曝光度”如何？下一周，你可以采取何种具体方式来提升自己的“曝光度” 目前你正在自觉些什么？确定要自觉的最有价值的东西是什么，制订一份下一年的自学计划。 成为专业人士 成为专业人士的全部在于：引人注目，恪尽职守，以及不屈服于挫折。成为专业人士 ，需要你克服自身的缺点，表下心来创作出尽可能最好的作品。作为一名软件开发人员，专业将是你最大的财富。\n什么是专业人士 简而言之，专业 人士 会严肃对待自己的责任和事业，愿意作出艰难的选择去做自己认为是正确的事情 ——往往还要自己承担代价。一些专业人士与外行的差异：\n专业 人士 外行 :\u0026ndash; :\u0026ndash; 遵守自己的原则 让干什么就干什么 专注于正确完成工作 专注于完成工作 不惧怕承认自己错了，不会文过饰非 不懂装懂 持续稳定 无法预测，不可靠 勇于承担责任 回避责任 成为专业人士 （养成良好习惯） 一切始于习惯。习惯是成为专业人士的必不可少的部分，我们每天做的很多事情都是习惯性的。起床，上班，完成日常工作，大多数无需思考。如果你想改变自己的人生，那从改变自己的习惯开始。作为一名专业人士需要养成的另一个强大的习惯是时间管理技能。每天开始工作之前你知道自己要做什么吗？你能很好地掌控日常任务所需要的时间吗？每天提前做好计划，就能养成有管理时间的习惯。\n坚守正道 追求品质，完善自我 作为一名专业人士 ，你必须不断改善和提高自己的工作品质。将品质管理应用到你工作的每个细节，而不仅仅是那些看似重要的部分，这一点非常重要。一旦你越过了底线，选择妥协，就很难再回头。\n行动\n你认为自己现在是一名专业人士吗？如果是，为什么，如果不是，又为什么？ 你都有哪些习惯？观察自己的一天，尝试找出尽可能多的习惯。把你的习惯 分为好习惯 和坏习惯。找出一些你需要养成的好习惯，制订一份好习惯养成计划。 上次你说“不”是在什么时候？如果你从来没有遇到过这种情况，想想如果你的老板要求你做一些你明知是错的事情，你会如何应对？ 记得自由——如何辞职 明智的处理方式 如果我真的想跳槽，唯一可能的方法就是，弄明白如何开展我的新业务（维持现有的工作岗位，把这个当副业），并让它足够成功，这样即使薪水大幅减少，我依然能完成转型。在考虑辞掉工作之前，你需要有一个切实可行的计划。我强烈推荐先生在业余时间启动你想创建的业务，待能从这项业务中产生足以维持生计的收入时，你再转为全职。这种离职的过程漫长页又痛苦，但用这种方式做事非常重要，不仅是经济上的原因。\n准备好为自己工作 为自己工作的麻烦在于，没到正式辞职的那一刻，你永远 不知道为自己工作是多大的工作量，但是到那里才知道的话已经为时已晚了。通过在业余时间创业，同时保有全职工作，你就会知道每天工作很长时间是什么感觉 ，开始自己的冒险之旅又是什么感觉。即使创业失败，你仍然会依靠你的工作以获取收入。如果你仍然没有被说服，那我再给你一个为何要如此行事的坚实理由——创业，特别是首次创业，很可能会失败。大多数创业型企业莫不如是。可能要屡战屡败向次后，你才能创建成功的企业，让自己丰衣足食。你是愿意倾多年积蓄后期望创业一举成功，还是愿意不断尝试，直到有所斩获？\n你真正工作的时间到底有多长 建立一种机制，每天记录并追踪自己的时间，以便我能了解自己的时间都 去哪儿了。其次，很重要的一点是，你要认识到，你在为自己工作时，你不能计划每个工作日就只有8小时工作时间。辞掉工作之前，很重要的一点是你对自己实际 承担的工作量有一个符合实际 的预期，并训练自己提前处理更高强度的工作负荷。\n切断脐带 离职 行动\n确切计划一下，为了维持生计你每个月到底需要赚多少钱。你可能会惊讶地发现还挺高的。如果想更快地获得“自由”，你需要想办法减少开支，这样你对兼职带来收入的需要会降低。 追踪每天的工作时间，了解当前你是如何度过每一天的。找出自己每天真正刻苦、高效工作的时候到底有多少，结果可能会让你大吃一惊。 成为自由职业者：开启自己的一片天地 开始 自由职业者的一大担忧是接不到工作，于是也注没有报酬。如果没有足够的工作填满自己的时间，或者在完成 一个客户的工作之后你不得不积极寻求更多的客户，你的压力会很大。最好的情形是工作任务已经提前安排妥当，或者处于工作太多不得不推掉一些的状态。要达到这一目标的唯一方法，就是随着时间流逝不断增强业务能力。你需要有长期客户，以此来确保未来的业务量， 同时你也需要有稳定的新客户上门。挂出招牌之后就等着这两件好事从天页降，几乎不可能。你需要假以时日，精心培养这两类客户。\n问问你认识的人 获取客户的最佳方式是通过你已经认识的人。熟悉你的人更容易信任你，特别是在启动阶段。列出所有你认识 的并且可能会对你的业务感兴趣的人员名单，给他们发私人邮件，让他们明确知晓你能为他们做什么，以及他们为什么要雇用你做这项工作。随着时间的失衡，这种勤奋总会有回报的。你的目标应该是让自己达到这样一个点：你为这份事业分配的时间已经饱和，无法再接受其他工作，不得不回绝掉一些人。如果你在做兼职工作的时候做不到这一点，那你就不要想着去做全职了。填满每周40个小时的工作量比填满10-20小时间艰难。\n获得客户的最佳途径 你真正要关注的是所谓的吸引式营销。大多数开发人员应该有一个博客，因为你能够在博客发表文章们来阅读，所以博客也是吸引式绝佳途径。电子邮件营销是推广产品或服务的最佳和最有效的方法。一理你能够将对你能提供的服务感兴趣的人集结成一份名单，你就可以慢慢地给他们提供更多的信息——关于你自己，关于你能为他们做什么，最终将其转换为你的客户。“吸引式营销”的方法多种多样，如：做免费的网络课程，写书，在大会上做沈凌，制作自己的播客等。“吸引式营销”唯一 的问题是起效时间略长。你必须有足够丰富的内容来吸引足够多的潜在客户来充实自己的工作渠道。\n怎么收费 除了获取客户之外，这是自由职业者要面对的最大的难题之一。通用的规则是，成为了自由职业者之后，你的时薪水平应该是作为全职雇员时的两倍。可看如下对比\n全职雇员的薪酬 自由职业的薪酬 :\u0026ndash; :\u0026ndash; 每小时50美元-无 每小时100美元-自主就业税-办公设备-会计或者记账员-非计费时间 实际收入等于每小时50美元 实际收入等于每小时50美元 然而你的收费标准是由市场决定的。你在业界的名气越大，你的客户就越多，你能收取 的服务费也就越高。你还需要知道 你要按什么价码收费才能谋生 ，你需要根据市场来判断定价——或者更高一点。这么做的重点不在收费标准本向，而是你的工作对你的客户页言是否物有所值。 行动\n整理一份名单，列出谁有可能会使用你的服务，或者谁知道谁会使用你的服务。 制作一个电子邮件模板，使用该 模板给上面那份名单里的每一个人发邮件（记得一定要谈论你会给他们带来怎样的价值，而不仅仅只是从技术的角度告诉他们你能做什么。） 在社交媒体上民布消息，给名单上的一小部分人发送邮件，看看会有什么反馈。一旦得到反馈，更新你的邮件模板，发送给更多人的。 创建你的第一个产品 找到受众 许多软件开发人员一开始就深陷创业者最常犯的错误之中——在为产品找到客户之前就构建好产品。人类创造出的每个产品（包括这本书在内）都是为了解决某个特定的问题。没有要解决的问题的产品毫无意义，毫无意义的产品自然也就不会有用户，也就意味着你不会赚到钱。如果你想开发出一款产品，第一步应该是筛选出一组特定的受众，他们也是你的解决方案的目标用户。针对这些人你要解决的问题是什么，你可能已经有了总体概念。不过在很多情况下，你要多做一些调研，找出要么没被解决的问题，要么没有被很好解决的问题。去目标客户常去的地方，与用户参与的社区交流，了解一下普遍存在 的哪些问题。你能从中看到的痛点有哪些。\n测试市场 一旦你明确了产品的受众，并明确了如何用它解决用户的问题，在开发产品之前你还有一步工作需要完成。你应该通过测试市场来验证你的产品，看看你的潜在客户是否真的愿意为它买单。\n从小处着手 太多崭露头角的创业都为自己的第一个产品设置了非常激进的目标，不顾一切地追求新的梦想。如果你倾尽所有投入创业，如果你为一次创业成功赌上自己的整个未来，你可能会把自己置于绝境——没有资源，甚至没有意志再去尝试一次。所以别这么做。从小处着手，作为副业开发你的第一个产品。\n开始 大量的创业技能最终还要通过尝试和失败获得。某种程度上，你必须 去做自己认为正确的，找出为什么它不管用，然后再去尝试不同的东西。大多数创造 出成功产品都也是这样做的。 行动\n整理出一批能够为自己将要创建的产品进行调研的目标受众。 从这些受众中挑选出一位用户，看看他参数了哪些领会（无论是线上的还是线下的）。加入他们的社区，倾听他们的问题。看看你能不能从中挑选出一两个潜在领域去开发产品，解决他们人痛点。 排查是否有人已经解决了这个问题，你并不想进入一个竞争已经白热化的市场。 你打算开始创建业吗 创业的基础 尽管从技术上讲，任何一家新成立的公司都被认为是一家创业公司，但是实际上还是存在两类不同的创业型公司。第一种创业公司在成立伊始就试图以获得外部投资都的投资来刺激公司的成长。这种创业公司可能是我们最常听说的那类。许多 成功的大型科技公司在开始创业的时候拿到投资人的资金，获得成长，并最终成功。与创业有关的术语和讨论实际 上指的就是这类公司。另一类创业就是自力更生创业。\n不做大，毋宁回家 创业的典型周期 通常，当你着手创建一家创业公司的时候，你对自己要创建怎样的公司已经有了想法。通常，这家公司要有些独一无二的知识产权，使得它的那些规模更大的竞争对手难以进入并简单地复制你正在做的。很好的创业修行是能够申请专利或受保护的新技术和新方法，而糟糕的创业候选则包括餐厅或其它缺乏独创，很容易被复制的服务。好的创业项目要有规模扩张的潜力。一旦你有了一个想法，你必须要决定是做一个单独创始人还是希望作为联合创始人。尽管二者各有优缺点，但总的来说，大多数创业企业都至少有两个联合创始人。\n创业加速器 要想在创业启动时获得额外的帮助，申请加入创业加速器计划是个好方法。\n获得投资 无论你是否加入创业加速器计划，对创业公司而言，第一个重要里程碑就是获得第一笔资金。一旦你烧光了种子基金，如果你的项目仍然可行，那将会引来一次重大投资。 A轮融资完成后，大多数创业公司还需要经过几轮融资，因为它们的初始资金几近耗尽，艰难地实现盈利和扩张。基本上你就是在不断重复这个过程以获得更多投资，直到再也得不到更多的投资，最后成功实现盈利，或者被收购。 采取行动\n研究一下一两家你的心仪的创业公司的历史。注意它们是如何开始以及如何获得融资的。 这些公司创立时是一个创始人还是多个创始人。 这些公司的创始人还成功创立过其他公司吗？ 这些公司什么时候获得融资的，它们获得了多少资金 这些公司启动的时候是否加入了加速器计划。 远程工作的生存策略 做“隐士”面临的挑战 挑战1：时间管理\n在家办公的时候，你会面临各种各校的在办公室里不会遇到的干扰。真正解决这个问题需要缜密的时间管理。你可以在你想工作的任何时间再去工作，但是你必须要设定每周的日程表并坚持下去。日程表越有规律，越是规划得好越好。\n挑战2：自我激励\n如果你总是无法做到自律和自控，你也许应该重新考虑是否要在家办公。当你感觉倦怠时，日程表和常规是非常重要的倚靠。当你不想工作的时候，有一个必须工作的固定时段可以帮你保持足够的激情去完成工作。常规也是一样的。如果可以，你培养一些常规。当激情不再时，习惯可以帮到你。你还要尽可能排除干扰和诱惑，让它们远离你的工作环境。别想着靠意志力去占用诱惑，这个教训适用于生活的许多方面。相反，排除诱惑，你会生活得更轻松自如。当你感到实在没有动力的时候，有一种我常用 的简单方法——坐下来，设定一个15分钟的计时器，开始工作。在这15分钟里，你必须工作。你不能让自己分心，必须专注于手头的任务。15分钟纯粹且专注的工作结束后，你可能会发现继续下去变得容易些了。事实证明，一旦我们专心致志地工作一段时间，我们就会沉浸其中，也有动力继续。我把称为问题效应。\n挑战3：孤独感\n刚开始在家办公的时候，我觉得就像一种解脱。没人打扰你，你可以安静地坐在那里做自己的工作。但是过了一段时间之后，那份寂静与安宁令人焦躁不安。大多数在家办公的软件开发人员并没有意识到，长期缺乏社交会使自己变得孤独。那么怎样才能治愈这种孤独感呢？这里有一个简单答案：走出去，确保你每周都能走出家门，让自己有机会去认识除配偶和孩子 以外的其他人。试着加入本地的软件 开发者小组，每周或者每月参加他们的聚会。或者换个场景。参加健身。等等。如果你能克服以上三项挑战，你就会成为一名成功的远程工作者，但是如果不能克服，你得再考虑一下自己是否适合在家办公。 行动\n吃饭自己做一个客观的评估，针对上面描述的内容，想想你自己该怎样应对时间管理，自我激励和孤独感这三项挑战。 如果你已经在家办公或者计划在家办公，制订一个你每周都会坚持的时间表。你要决定自己的工作时长以及哪天是工作日。 假装自己能成功 很多在面对逆境的时候都会选择知难面退。但是另外一些人在面对同样的挑战时，会勇敢地站出来直面挑战。所有选择留下来与困难做斗争的人，是真的对自己成功和克服困难的能力信心十足吗？肯定不是，但他们中的许多人都有一个共同点——假装自己能成功。\n“假装自己能成功”的真实含义 当我说“假装自己能成功”的时候，并不是暗示你去撒谎或者假装拥有息尚不掌握的知识和技能。相反，我的意思是，在你做事之前，可以暗示自己“我已经成功完成任务”。当我在说“假装自己能成功”的时候，我是在说你要如心理暗示那样行事：\n你仿佛已经具备了成功完成任务的技能和天分 你仿佛已经成为自己想成为的那类人 仿佛战斗已经结束，而你大获全胜，因为你深知如果自己坚持不懈，胜利就在眼前。 你仿佛已经对即将踏上的未知道路驾轻就熟。 当你以这样的心态做事情的时候——注意，关键词是“做”——你终究会实现你自己展示的蓝图。“假装自己能成功”就是这样起作用的。你说服自己的身体和内心去努力，使梦想成为现实。“假装自己能成功”是不自信的对立面。你要在做任何事情的时候都充满自信，即使是自己的能力远远不到的时候，因为你有一种自己能够克服一切障碍的信念。\n付诸实践 所谓“假装自己能成功”，就是要有意识地让自己身处逆境，迫使自己学会拼搏。正是这种在生活中“假装自己能成功”的心态，带领自己勇敢走向未知领域，坚信挑战与机会并丰。如果你想学会“假装自己能成功”，你就必须拥有破釜沉舟的勇气。你的自信（注意，并非自大）是富有感染力的。如果你抱有“我可以”的心态，当你真正信任自己，既不夸大其词也不妄自菲薄的时候，知道自己最终能实现心中所想，那么你会发现别人也会对此深信不疑。抱着这种心态走向面试官吧，你会见识到“假装自己能成功”的威力。 行动\n诚实地评估一下自己。面对困境，你的心态如何？当遭遇新问题或不熟悉的问题时，你会怎样做？回想一下，上一次面对困难或者不熟悉的形势时，你是怎么做的？ 你该怎样树立一种自信而不是自负的心态？自信与自负之间的区别是什么？为了强化“假装自己能成功”的能力，你现在应该做什么？ 小练习：有目的地将自己置于困境，演练一下自己既定的应对策略。 单调乏味的简历——如何修改 你不是专业的“简历写手” 雇一个简历写手 你需要让他帮你做：\n为你的经历做一个文字优美引人入胜的广告，令你看起来光彩照人 让这份广告看上去装帧精美，格式赏心悦目 比别人多做一点点 对软件开发人员来说，简历不一定要花哨好看，但一份专业的简历非常重要。\n如果不想雇专业的简历写手该怎么做 提示 好处 :\u0026ndash; :\u0026ndash; 把简历放到网上 确保雇主能够很容易访问你的简历。如果你申请Web开发的职位，这一点尤其重要 简历要有创意 简历样式不落俗套，别人一眼扫过去就会被深深吸引 使用“行动-结果”的描述 你的简历应该展现你做了哪些工作及相应的结果。这样你的潜在雇主即能了解你会干什么，还能了解你能取得的成果，以及雇用你会给他们带来的收益 校对 即使是聘请专业 简历写手，你也要通篇校对 。简历里有错别字或拼写错误会让人觉得你粗心大意 采取行动\n不管你现在是否正在找工作，把你的简历给一些招聘人员，询问他们的意见。招聘人员看过大量的简历，他们是能告诉你是否需要改进你自己的简历的最佳人选 查阅分析一些专业和简历代写服务，看看亿们提供的简历样本。与之相比，你自己写的简历如何？ 请勿陷入对技术的狂热之中 如果你能让自己不成为某种技术的信徒，你会在职业生涯之路上走得更远。\n我们都是技术的信徒 你会对某种技术或编程语言存在偏见，认为它是最好的——至少大多数程序员是这样的。对技术虔诚的一大问题是，我们中的大多数崇拜某项特定的技术，只是因为自己熟悉这种技术。我们很自然地会相信自己选择的是最好的，然页这会让我们经常忽略任何反对意见。我们不可能充分了解现在的所有技术，从而给“哪项技术最好”作出最英明，最睿智的判断，于是我们倾向于选择我们了解的技术并先入为主地认为它是最好的。人生多艰，无暇他顾。\n天生一物必有用 不是所有的技术都是“伟大的”，但多数被普遍应用的技术至少是“好的”。一样东西如果不好，就不会为人所知或使用，也不会成功。有了这样的视角会有助于你理解：在很多情况下，解决问题并不只有一个好的或是最好的办法。同理，最好的编程语言，框架，操作系统，甚至是文本编辑器不会只有一种。你可能会某项技术多过其他，或者用某种编程语言的效率要高过其他，但是称其最好并无必要。\n不拘一格 没有理由去强烈坚持自己选择的技术就是最好的，而轻视甚至无视其他技术。如果固执已见，最终受损失的是你自己。另一方面，如果你愿意对技术保持开放的心态，而不是固守自己已经了解的技术，声称它是最好的，你会发现有更多的机会为你敞开大门。 行动\n列出你钟爱的所有技术，或者你觉得更胜一筹的技术。 针对这张列表里的每一项，想想它为什么吸引你。你都做了哪些比较来确定它确实 是“更胜一筹”？你真的使用过它们的竞争对手吗？ 挑战一门你厌恶的技术，找几个喜欢它的人，开诚布公地议论为什么他们喜欢这门技术。更进一步，你也度着用用它。 自我营销 营销就是一场争夺人们注意力的竞赛！你的营销手段决定了你的营销对象是受益还是受损。营销需要人们的关注， 以便让人们关注你，关注你的产品。优秀的营销会将人们的需要或者期待与能够满足此愿望 的产品或服务关联起来。所以，营销追求的是“实现 价值在先，要求回报在后”。\n针对 “码农”的营销基础课 自我营销意味着什么 营销的核心在于将一些人所需要的所期待的产品或者服务与产品或服务本身连接起来。所以“自我营销”也就是把希望得到你提供的产品或者服务的人和你自己连接起来。自我营销的正确方式就是为他人提供价值。关键在于：如果想让别人喜欢你，想和你一起工作，你就必须要为他们提供价值。无论你是否意识到，其实你每时每刻都在营销自己。当你试图说服他人接受你的想法时，本质上，你就是在把自己的想法推销给他们。当你申请一份工作时，从本质上讲，你的简历就是推销自己服务的一份广告。问题在于，即使我们都在推销自己，我们中大多数人并不是有意识地在做这件事情。我们将机会拱手相让，任由他人和环境来定义我们。自我营销无非就是学习如何 控制好自己要传达的信息，塑造好自己的形象，扩展信息送达的人群。当你营销自己的时候，你就是在积极地管理自己的职业生涯，有目的地选择好如何塑造自己，以及将塑造好的自己主动推送给那些对你感兴趣的人。\n自我营销为何如此重要 如何自我营销 自我营销要从打造能代表你自己的个人品牌做起。你不可能将所有的东西全部呈现出来，因此，对于自己成为怎样的人，给世界呈现怎样的形象，你要谨慎决定。一旦你拥有了自己的品牌风格，也知道要传达怎样的信息，你就需要找到传达上述信息的方式。首推博客，这个策略需要时间，需要持之以恒。随着时间的推移，你写的每一篇博客，你采访的每一期播客，还有你写下的每一本书，每一篇文件，都有助于营销自己，提升你的个人品牌认知度。最终你在这个领域就成为了权威。我想强调的是：所有这一切都取决于你的能力——能给其他 人带来怎样的价值。自我营销的基本机制是，要想让人们追随你，倾听你，你就要带给他们价值：能你为他们的问题提供答案，甚至是给他们带去欢乐。如果你在持续自我提升的同时并没有给他人带来价值，那么你终究不会走得太远。因为每个人都会离你而去。 行动\n如果你还没有博客，开通一个吧。想想看，你会专注于哪些主题上 给你的新博客至少想出20篇文章。 现在做一个时间表，列出你开通博客的确切时间，为博客创建内容。 打造引人注目的品牌 品牌不只是商标，更是一项承诺。品牌了客户对你的期望，而且这些期望也必须能够实现。\n什么是品牌 品牌是对产品或服务的一整套预期。商标仅仅是品牌的视觉符号而已。品牌的着急并不在于视觉元素，而是品牌带给你的感受，是你与品牌互动时的预期。品牌即承诺：承诺按照你预期的方式交付你所预期的价值。\n构成品牌的要素有哪些 要打造一个品牌，你需要四个要素： 品牌所要传递的信息，品牌的视觉符号，品牌的一致性和品牌的曝光率。首先，而且也是最重要的，就是品牌所传递的信息。缺乏信息的品牌也就没有了目的性。信息就是你想传达的，以及品牌所承载的情感诉求。其次，品牌需要视觉符号。显而易见，一个品牌应该有一个标识，即能够代表品牌的简单的视觉符号。好的品牌会让自己的视觉符号无处不在。再者，品牌要有一致性。品牌所包含的信息，品牌的视觉形象固然非常重要，但是一旦失去了一致性，就无法构建品牌认知度，或者更糟，你在不断地背离品牌。最后一个要素，品牌曝光度。通过写博客，写文章，发表演讲，创建视频分享，做播客内容等一切手段，你需要竭尽所能传播你的信息，扩大你的知名度。\n创建属于自己的品牌 当你着手创建自己的专属品牌时，第一步就是定义你想传达的信息。你不可能覆盖所有人群，因此需要缩小自己的受众范围，选择自己的细分市场。选择某个细分市场，然后以它为核心建立你的品牌，越有针对性越好。如果能充分聚集，你就可以直接向受众传达信息，也能更轻松地建立品牌的认知度。\n创建品牌的步骤\n明确要传达的品牌信息 挑选细分市场 创建品牌口号 创建电梯内销售概要 创建视觉符号（即标识） 采取行动 列出一些你熟悉的流行品牌，选择1-2个进行深入研究，试着确定一下这些品牌传递的信息是什么，看看它们是如何使用商标和其他视觉元素来传达该信息的。 使用头脑风暴的方法为自己的个人品牌列出细分想法，先列出至少10-15个想法，然后再缩小到2-3个，最后选定一个作为你的个人品牌。 电梯销售是指用两到三句话棋手一个产品，一个提案或一个项目，向潜在的买家或赞助人做介绍。 创建大获成功的博客 使用面对面直接交往的方式，你只能遇到有限的人，所以你需要另一种方式来推销自己，拓展自己的社交圈子。而博客是推销自己的一种既廉价又简单的方式，对于让自己声名鹊起极具价值。\n为什么博客如此重要 让别人在全方面了解你，还能提高你的写作与沟通能力。组织自己的思想，并将其转化为文字，是一项颇具难度却也极具价值的技能。作为软件开发人员，学习如何写博客实际上都能帮你写出更好的代码，因为你能更轻松地传达自己的意图。博客还能帮你更好地传达自己的想法，令想法更有说服力。\n创建博客的步骤\n决定要使用哪种托管服务：免费的，付费的还是VPS 设置或安装博客软件 配置或者自定义所有主题 开始写吧。 打造成功博客的秘诀 打造成功的博客的最大秘诀有且仅有一个——持之以恒。\n提升访问量 第一个策略就是开始评论其他人的博客。你的评论越有见地，人们越有兴趣查看你在自己博客上所说的。另外一个策略：在社交网站上分享你的博客文章，在你的电子邮件签名的底部以及所有的在线个人主页中添加你的博客链接。最后，如果你足够勇敢并且认为自己的文章足够优秀或富有争议，可以把自己的文章提交到Reditt或Hacker News。\n我可不能保证你能够一鸣惊人 你的主要目标：为他人增加价值 当你营销自己的时候，如果你所做的一切都只是为了你自己的利益而不是给别人带来真正的价值，那么即使你所做的都正确无误，那也无济于事。\n给人们想要的东西 要先知道他们想要什么。 你提供的内容应该直接瞄准你所选定的研究领域，为该领域带来价值。 把你工作成果的90%都做成免费的 免费内容比付费内容更容易被分享。通过提供免费的内容，你让人们有机会无需投入资金就能了解你生产的内容多么有价值。免费还会让人们对你心生感激之情，他们也希望能通过购买你开发的产品或服务来回报你。虽然免费做这些事情看起来是在浪费时间，但是你要把它视为对未来的一项投资。通过为人们创造价值并且免费提供这种方式自我营销，你就赢利了为他人提供价值的声誉，也为自己的未来创造了机会。这种声誉是无法衡量的。它能帮你赢得更好、更高薪水的工作，获得更多的客户，或者成功地发布一款产品。\n行动 什么样的内容会让你觉得有价值？有没有哪个特别的博客会让你每周都去阅读，或者哪个播客的内容如此有价值让你欲罢不能，以至于一集都不想落下？ 你可以提供自己的爱人或你的细分市场的最大价值是什么？你 认为什么样的内容对于你有受众群体而言是最有价值的？ 善于运用社交媒体 培育你的社交网络 要想用好社交媒体，首先你要给息积累足够多的粉丝，或者至少是让人们进入你的社交网络。有多种不同的策略来帮助你构建你的社交网络，你要根据具体的社交网络来决定自己该怎么做。不过对于大多数社交网络来说，最容易做到的就是关注他人，或者邀请他人加入你的网络。你也可以把自己社交网络的个人主页的链接放在你的在线介绍，博客文章的结尾或者邮件的签名档中。\n有交地运用社交媒体 你的社交媒体应用策略应该主要聚集于构建稳定的受众群体，并逐步提升活跃度。你应该想方设法让人们从关注者变为粉丝，这样他们就会更加关注你的内容，会与别人分享，也会积极地推荐你。如果你持续不断地在自己的社交媒体上给别人分享和提供有价值的内容，那你必定会赢得尊重和声誉。\n通过社交媒体分享的内容 方式 内容 博客文章 转帖一些博客文章，或者自己的博客 新闻报道 转载一些有趣的文章，尽量与你的细分领域有关，或者与软件开发相关 励志名言 名我名言，特别是鼓舞人心，非常流行的名言警句 技巧、小窍门 任何你所了解的特殊技巧或者知识，别人会欣赏 幽默故事 发一点幽默故事不错的，但是一定要确保确实好笑，另外千万别冒犯别人 吸引人的问题 这是一个很棒的吸引你的听众并和他们互动的方法 自己的一些推广活动 别太多，并且跟其他内容混在一起 保持活跃度 如果你不能持续不断地在你的社交媒体上保持足够的活跃度，你将会丢掉大量粉丝。但是除非你愿意每天都投入大量的时间，否则你最有可能的情况就是，选择一到两个作为你最心仪的平台。你可以使用自动同步，自动分享内容的工具同步你的多个社交平台。\n不同的社交网络，不一样的功能划分 行动 你当前是如何使用社交媒体的，年你使用社交媒体的时间线，找出别人根据你在社交媒体上的分享，对你和你的品牌产生的印象。 制订一份社交媒体改进计划。确定有哪些内容需要不同的社交媒体上，把它们整合在一套每周内容分享策略。关注哪些分享最为流行。 演讲、报告和培训：做“说话的极客” 演讲和举办某种形式的培训是连接普罗大众和自我营销的最有效的方式之一。虽然这一方式在扩散速度上不及其他媒体，但是站在目标受众面前，直接面对他们侃侃而谈，却是最能打动他们的方式。\n为什么现场演讲如此有力 演讲也是一种互动媒介，或者至少你能将其作为媒介使用。安你在大会发言时，你能够直接回答现场听众的问题，让他们参与到你的演讲当中。这种交互方式能够迅速建立起人群对你的大量信任感，能帮你收获粉丝，促进信息的传播。\n开始演讲 行动 列出你所在地区的所有用户组清单，同时列出你能去发表演讲的代码训练营清单。挑选一个自己觉得丝袜有把握的专题发表一次演讲。 找出同上提供的那些针对软件开发人员的培训课程，无论是还是免费的，关注并记录找出成功的培训师是怎么做的。 试着以截屏视频的形式创建自己的短时培训课程，然后在YouTube等网站发布。 创建一个列表，列出所有你可以发表演讲的主题。 著书立说，吸引追随者 如果我所做的一切都正确无误，在你阅读这些文字的此刻，你应该感到我正在与你谈话，而不是说教。文字不只是信息，文字就像一块功能强大的画布，将你的心声传递给其他人。如果你的心声很有趣，能够吸引到读者的注意，给他们提供价值，那他们就会与你建立联系，你终将征服他们。\n为什么著书立说如此重要 书籍为它的作者带来非凡的影响力。一个人通过写书可以收获极大的依赖。除了能让自己的大名出现在装订成册的书脊上，一本书就像是一辆满载的货车，可以以非常具有针对性的、聚集的方式传达你的信息。\n书籍和杂志都不赚钱 通过一本书可以获得一笔可观的收入是非常罕见的，而且通常作者只能获得收益的一小部分。写书是为了提高自己的声誉。通过出版，你能获得更广泛的知名度和声望。\n获得出版机会 许多出版商不愿意冒险与完全不熟知的作者合作。要想让自己有机会出书，最好的办法就是明确一个有市场需求的主题，同时也能够充分作为该领域专家的学识。你应该提前做功课从而让自己在市场上立足。我建议你开设博客，给一些较小的杂志投稿。随着你在自己的专业领域树立起的声望，你可以积累更大的出版物。你的粉丝越多，你对出版商的吸引力就越大。\n自出版 网络，Kindle等等\n行动 查看网络上与软件开发相关的畅销书列表，找出哪种类型的书销量最好。 在你写长篇大作之前，先从杂志文章这样的短篇着手。找出一些发行量不高的软件开发类杂志，提交一篇文章摘要。 百折上挠，越挫越勇 如果想通过自己的努力获得成功，你就必须学会不在乎别人怎么想，你必须学会如何无惧自己被别人看作傻瓜。\n万事开头难 万物都在变化之中。随着时间流逝，原本让你不适的东西你最终都会应对自如。你需要足够的时间和意愿去克服尴尬，直到它们不再让你感到局促不安。大多数人在第一次面对挑战时都需要克服这样的不适感，尤其是他们面对一群人的时候。\n被看作傻瓜又如何 如果你想成功，你必须要学会收起自己脆弱的自尊心，勇敢走出去，别害怕让自己出丑。成功终将会来。你不可能专注做某件事而毫无长进， 你只要坚持足够长的时间就会有收获。你的生存之道就是不必太在意。别害怕被人看作傻瓜。\n小步快跑 准备好面对批评，但不要惧怕。总会有人不喜欢你的言论，或者不赞同你的观点，那又怎样？开始阶段，一种很好的方式是在别人的博客正面写评论。一旦你觉得自己变勇敢了那么一点点，那就开始写自己的博客吧。围绕自己熟知的话题写，或者干脆写“怎么做”。不要写已有定论的话题。无论是像缓慢适应水温那样小心翼翼，还是一头就扎进深水区，这些都无送紧要。核心在于一直保持前进状态。你会感觉不适，你可能会受惊吓甚至被吓倒，但是这一切终将会过去。如果你愿意坚持下去，面对前方的种种挑战，如果你不介意短期内被看作傻瓜，你就会在大多数人失败的地方获得成功。\n行动 让自己勇敢起来。今天就是你的大日子。走出去做一些令你害怕的事情，大小都不要紧，迫使自己牌不自在的环境，并且提醒自己：“这没什么大不了的。” 现在重复上一步，至少每周一次。 学习 学习怎样学习：如何自我教育 如果你一直依赖他人来教你，从业没有掌握自我教育技能，这会严重限制你提升自己的知识和技能的机会。软件开发人员可以学到的最重要的一项技能就是自我教育能力。\n剖析学习过程 如果我告诉你该怎么做，你可能会忘掉，但是如果你自己动手做一次，你可能就记住了。如果你能将自己所学的东西教给别人，你不仅能记住，还能理解得更深刻。尽管每个人的学习风格千差万别，但是通过动手实践和教会他人，我们能学得更好。与其他学习方式相比，主动学习是效率更高的方式。\n自我教育 我的“十步学习法” 体系背后的逻辑 为了能够掌握一门技术，我需要了解以下三个要点\n如何开始：要想开始使用自己所学的，我需要掌握哪些基本知识？ 学科范围：我现在学的东西有多宏大？我应该怎么做？在开始阶段，我不需要了解每个细节，但是如果我能对该学科的轮廓有大致的了解，那么将来我就能发现更多的细节。 基础知识：不上在开始阶段，要想使用一项特定的技术，我需要了解基本的用户案例和最常见的问题，也需要知道自己学的哪20%就能满足80%的日常应用。 十步学习法体系 “十步学习法”的基本思想就是：要对自己要学的内容有个基本的了解——解自己不知道什么就足矣。然后，利用这些信息勾勒出学习的范围，即需要学哪些内容，以及学成之后又会获得什么。依靠这些知识，你可以找出各种资源来帮助自己学习。最后，你可以创建自己的学习计划，列出要去学习哪些相关课程，筛选学习材料，只保留能帮助自己达成目标的优质内容。一旦完成这些工作，你对自己要学什么和怎样学都了然于胸，你就可以把控自己的学习计划中的每个关键点，通过“学习-实践-掌握-教授”的过程（LDLT），获得对该学科的深刻理解，同时你也向着自己的目标前进。\n过程 了解全局 确定范围 定义目标 寻找资源 创建学习计划 筛选资源 开始学习，浅尝辄止 动手操作，边玩边学 全面掌握，学以致用 乐为人师，融会贯通 第一步到第六步：这些步骤只做一次 这六个步骤只需要针对你想学的每个主题做一次。第七步到第十步则要针对在第五步所制订的学习计划中的每个模块循环往复。\n第一步：了解全局 在这一步，你要做的是了解自己将要学习的主题的全局。这个主题宏观上什么样？你能从中学到足够丰富的知识以了解自己所不知道的吗？以及自己所不知道的有多少？你通常可以使用网络搜索来完成大部分研究。也可以看相关主题的书，浏览其中的介绍性章节，粗略浏览一下内容。我们在这一步目的不是要掌握该主题，只是对这一主题的相关内容有一个全局的了解。\n第二步：确定范围 在任何项目中，明确项目的范围都是至关重要的。将一个大的主题分解成可控的子主题。在此过程中，你可能会受到时诱惑，为了学习该 主题下的不同子主题，你可能会扩张你的学习范围而不够聚集，但是务必抑制住这个诱惑，尽可能地保持专注。你一次只能学一样东西。你可以稍后再回头学习别的分支领域，但就目前而言，选择一个专注而聚集的范围，潜心学习。最后，在这一步中一定要注意：明确学习范围的时候要考虑时间因素。\n第三步：定义目标 在全全力以赴启动之前，明确“成功”的含义极为重要。如果不知道成功是什么样子，很难找准目标，也很难知道自己什么时候已经真正达到目标。好的成功标准应该是具体的、无二义性的。不要对自己想要完成的任务进行含糊不清的描述。\n第四步：寻找资源 要尝试收集到多种多样的资源以帮助你学习，而不是只读一本关于这一主题的书。资源可以多种多样。在这一步，你会想到找尽可能多的与自己所选主题相关的资源。此时无需要考虑这些资源的质量。稍后你会对你找到的这些资源进行过滤，去伪存真。信息来源：\n图书 博客文章 在线视频 专家，歌者对你所想要学习的内容已经熟知的人 播客 源代码 示例项目 在线文档 第五步：创建学习计划 在这一步，你需要创建自己的学习路径 。把它看作自己写书时的大纲。打造自己的学习计划，一个好方法就是观察别人是如何老爸感兴趣的主题的。\n第六步：筛选资源 在这一步中，把你在第中步中收集的全部资源浏览一遍，找出哪些内容能够覆盖你的学习计划。你还应当看看评论，试着找出品质最高的资源。\n第七步到第十步：循环往复 第七步：开始学习，浅尝辄止 这一步的关键在于过犹不及。你会很容易就失去自控力，开始消化计划学习中列出的所有资源。但是，你会发现， 如果你能经受信这样的诱惑，你会取得更大的成就。你要专注于掌握自己所需的、能在下一步动手操作的最小量的知识 。\n第八步：动手操作，边玩边学 在这一步中，你要采用在第7步中学到的知识。不用担心结果，勇敢探索吧。如果你正在学一门新技术或者新的编程语言，你可以先创建一个小项目来测试这一步的效果。把那些暂时还没有答案的问题记录下来，你在下一步中会有机会找出这些问题的答案。\n第九步：全面掌握，学以致用 好奇心是学习特别的自学的重要组成部分。通过动手解决第八步中未解决的问题。不过请记住，你依然没有必要把收集到的所有资料全部仔细看一遍。你只需要阅读或观看与当前所学相关的部分。\n第十步：乐为人师，融会贯通 在这一步中，我会要求你走出自己的舒适区，将自己学到的知识教给别人。要想确定你确实掌握了某些知识，这是唯一的办法，同时，在你将自己所学介绍给他人时，这也是查漏补缺的最好办法。在这一过程中，你要切实剖析并理解自己所学的知识，将其转化到自己的思想；同时，你也要用能够上他人理解的方式精心组织这些信息。你可以用多种方式将自己所学教给他人。你可以写博客，也可以缺件视频。你也可能跟自己的爱人探讨，将自己所学解释给他/她.重点在于，你要花时间将自己学到的东西从大脑中提取出来，以别人能够理解的方式再组织起来。在经历了整个这个过程之后你会发现，有很多你以为自己明白了的知识点，其实并没有摸透。于是你会将那些以前自己没太明白的东西联系起来，并且简化自己大脑中已有的信息，将它们浓缩并经常复习。\n寻找导师 导师的修养 在寻找一位导师的时候，你必须要抛开自己的判断和推理，只去关注导师的成就。你可以去找那些已经实现了你所设定的目标的人做你的导师，或者水平略胜你一筹的人做你的导师。你也可以去找已经帮助别人实现你设定的目标的人，即使他自己还没达到这个水平。寻找导师时的检查单\n他们做到了我想要去做的？ 他们曾经帮助他人做到时了我想做的？ 他们现在取得了什么可以展示的成就？ 你能和这个人和睦相处？他充满智慧吗？ 在哪里可以找到导师 最好的选择就是去自己认识的人中找。不过有的时候你的人际关系没那么广，那你就需要试试别的方法。你可以先去查看一下本地的各种社群，通常是各种各样的兴趣小组。还可以去相关的网站上找。大多数本地群组由水平参差不齐的成员组成，但通常在经验丰富的牛人的号召下聚会。这样的牛人在回馈社会的同时，也在寻找亲的门徒去继承自己的衣钵。即使你不能在这样的群组里找到合适的导师，你也会遇到高人，他要么能告诉你去哪里找，要么认识你想认识的人。如果你想在一家公司里获得晋升，那么在公司内部给自己找一位导师无疑是暖和之举。\n虚拟导师 招募导师 完成这一任务的最佳途径就是交换互助。你能提供的最好的交换物就是对学习的渴望，还有免费工作。但是很可能你没有时间或财力来为他人免费工作。你也许只是需要在自己追求的人生领域中获得一点点帮助，或者你的导师不需要你的义务帮助。你该怎么办？（你可以考虑请他吃午餐。。。）一定要有耐心，大部分人在第一次听到“不”的时候就止步不前。别做这样的人，恰恰相反，要做一个别人用棍子赶才能赶走的人——即便如此，过一会儿也还要回来。你的顽强不会总有回报，但是你可能会惊讶地发现回报来得很频繁。\n行动 在寻找导师之前，你必须要明确，你需要导师帮你解决什么问题。坐下来，仔细想想你为什么需要一位导师，你希望从这段师徒经历中获得什么。 列出所有你认识的人中可以做自己的导师的人。请其他人在你的列表上再列出他们认识 的人，用好你的人际网络。 想一想，为了能够换取导师的帮助，你能给他提供什么？ 开山收徒 拥有一位导师是非常好的，而成为导师更是好上加好。\n做一名导师 你一定会在某个领域成为别人的导师。花点时间思考一下你会比谁领先一步。身为导师并非每时每刻都要成竹在胸、永无谬误。身为一名导师，要客观地看待别人的问题并提供相应的解决方案，而对方之所以看不到时这些解决方案，只因当局者迷。通常，你要结合自己的智慧和经验进行观察，但是，有时候仅仅以“旁观者”的观察视角就足以帮助别人获得成功。\n身为导师的好处 在你担任导师的时候，你通常会比自己的学生还学得多，你会修正自己关于某个课题的观战，以全新的视角观察和思考。在你做导师的时候，你经常面对的都是最强悍的问题：为什么？为什么这样就是对的？为什么要用这种方法？当你被近去探究这些“为什么”的时候，你会发现其实自己并不知道为什么。你可能还会发现，当你想去帮助别人的时候，你探求答案的过程能让你愈加深入思考 ，甚至可能完全改变你最初的想法。当导师有时候也是要讲点儿运气的。你帮助过的每一个人，可能终有一天会超越你并且回馈于你。做导师的好处：\n帮助他人时的成就感 深入学习和领悟知识的途径 你的徒弟有朝一日会帮到你 自身的成长。帮助别人成长的过程也就是自己成长的过程。 挑选一会“值得”指导的门徒 身为导师的一大困难就是找到一们值得自己付出时间和精力的门徒。在决定是否接纳新门徒的时候，需要首先查看他的基本素质（你知道可以导致成功的素质）。一个品行端正、有原则但缺乏智慧和知识的人，如果给予正确的指引，最终也会成功。要找真正有意愿去学习，并愿意为此付出努力的人做自己的门徒。\n采取行动 在哪些领域内你可以辅导别人呢？整理一份清单，列出自己有意愿且有足够知识能帮助别人的主题。 持续提升自己，成为为名导师。找到那些真正需要你帮助又符合条件的人做你的门徒。 传道授业：若要学知识，必得为人师 你觉得你在某方面已经是专家了，才敢把这些东西拿出去教给别人。然而，能将自己的专业知识教授给别人，却是成为专家的一部分要求。教学通常需要正规的资质，而教学的真谛则是与他人分享知识。\n在你传道授业的时候都会发生什么 当我们初次接触某个课题的时候，我们对于自己对此了解多少往往会高估。我们很容易自欺欺人，以为已经对某样东西了如指掌，直到我们试着去教会别人的时候，才能发现事实并非如此。你有没有被别人问过一个非常简单的问题，却震惊地发现自己不能清晰地解答。我们自认为已经透彻理解这个话题，实际上我们只是掌握了表面知识。这就是传道授业的价值。在你的知识集合里面，总有一部分知识你并没有理解透彻到时可以向别人解释，而“教”的过程能够迫使你面对这一部分。这种肤浅的理解力无碍于我们完成工作，因而不易被察觉。然而一旦我们试着向别人解释某件事情的动作原理或背后的原因的时候，我们在认知上的漏洞就会暴露出来。不过这并非感觉事。我们需要知道自己的弱点，然后才能对症下药。在教别人的时候，你迫使自己面对课题中的难点，深入探索，从只知皮毛变成完全理解。在教别人的时候，你需要重新组织大脑中的所有数据。当我们刚开始学新东西的时候，通常都是些零散的知识点。在你试力教别人的时候，你强迫自己重新组织大脑中的资料。最好的思维方法就是解释某样东西并将其记录在纸上，或者记录到时文件或幻灯片中，使你可以将这些互不连贯的碎片信息收集起来，并以一种有效的方法重新组织起来。要想教人，你得先把自己教会。传道授业为何是卓有成效的学习方法，原因正是如此。\n入门 我发现最好的教学方式就是以谦虚的视角来观察问题，以权威的口吻去诠释问题。我的意思是说，当你教别人的时候，无需让自己表现得比学生更智慧、更博学，但要充满信心，坚信自己所说的一切。没人愿意跟一个对自己讲的内容毫无底气的人学习，也没有人愿意在学习的过程中被人看作是愚不可及的。我的建议是：你从“小”做起渐渐习惯去分享自己的想法。我一直建议开发人员要开自己的博客。在你掌握一个主题之后，可以撰写博客来分享自己所学。看看自己能不能以这一简单的方式来从接收到的信息中提炼出要点。然而你并不要止步于写博客。另一个重要方法就是在本地用户组的聚会上或者自己的工作场所进行演讲。呆做记住一个原则：心态谦卑，信心满满。即使你可能不是最好的演讲者，你也会做得很好。\n行动 想出一个你可以教给别人的话题并教给别人。本周你要尝试一些教学方法，如果写博客、发表演讲、录制截屏等。 当你做教学准备的时候，要特别注意这些准备工作是如何提升自己对某个主题的理解 的。对那些没打算去教别人就不可能发现的自己的知识短板要多加留意。 你需要一个学位吗，还是可以对此忽略不计 获得成功必须要有学位吗 作者认为拥有学位并不是成功所必需的，但它肯定是一个限制性因素，它限制了可以提供给你的职位数量，并且某种程度上也限制了你的晋升，特别是在大公司中。没有学们可能会让你的简历被过滤掉，连被人看到时的机会都没有。与其他行业相比，软件开发最大的不同就是：该领域总是为断变化。每天都有新的框架和技术问世，在教育机构中培养能适应真实工作环境的软件开发人员几乎是不可能的。但是，这并不意味着，软件开发中不存在永恒不变的核心领域。许多计算机科学课程中包含的算法，操作系统，关系弄数据库理论和其他主题都是永恒的。然后最笑意的事实是，当你坐在办公桌前开始写代码的时候，你极少会用到在学校学到的技能。身为软件开发人员，我们所做的大部分工作，都是如何使用新技术，学会如何用它们完成工作。我们很少需要回溯到计算机科学的本源。同样，这并不意味基础的计算机科学教育毫无价值。能够深入挖掘问题并理解问题的能力更具价值。对大多软件开发人员来说，在工作中取得更直接因素还是相关工作经验。\n拥有学历的优势 首先，学历教育可以确保你在软件开发方面获得全面的教育。拥有一个学位也可以帮你即使毫无经验也能踏入职场。学位还可以给你更多的选择。如果你没有获得过相关学位，有一些职位你是永远不会得到的，尤其是在大公司中。\n没有学历又如何 如果没有学历，你就不得不更多地依靠经验来证明自己的能力。而证明自己的能力的最好的办法就是以往的工作经验。另一个要考虑的是，如果你目前没有学位，你是否想将来去获得一个？另一种方法是是获得专业谁。虽然不如学位那么有用，但是它们没学们那么贵，也能证明你在某领域的专业能力，如微软和Java的专业 技术谁，Scrum方法谁。。。\n行动 如果你没有学们，看看有哪些网上课程或者 业余 课程可以参加。看看它会花费多少，多久会让你毕业。 如果你决定 完全 放弃学位教育，那么一定要确保 自己有一个非常出色的作品集。花时间把写过的代码整理一下，证明 你了解你所做的工作。 发现在自己的知识短板 专注于自身强项，这没什么不妥，但有时候，如果弱点得不到解决，通常会的职业或生活的桎梏。\n为什么我们会有短板 我们总是倾向于掩饰自己的短板，而且我们也总是太忙，忙到时无暇去填补它们。结果，我们要么不能真正明白自己在做什么，要么为了避开自己的短板而采取低效的方法。尽管我们最终明确了这些短板，也明白自己深受其害，但基本上依然会无动于衷——即使我们知道自己应该有所作为。这就像牙疼的时候不愿意去看牙医，因为我们并不愿意为此而烦恼。\n找出你的短板 你的知识短板并不全都显而易见。事实上，大多数的知识短板，你只能隐约觉察到，对于自己不知道的，你很难清楚地意识到，也很容易忽略。知识短板会阻碍你进步，准确识别它们的最侍方式之一就是看看自己在哪些工作上花费了大量的时间，或者一直进行重复性劳动。另一种识别知识短板的方法是，时刻都要试图了解自己不理解或不清楚的事物。你可以维护一份清单，列出自己需要去研究或者螅民不清楚 的所有事物，追踪有哪些主题总是不断出现在这个清单上。你会惊讶地发现这份清单 的增长速度有多快。知识短板高发区：\n在哪些工作上花费时间最多？ 可以改进的重复笥劳动 自己没有完全理解 的东西 你回答不出来的面试题 消除短板 如果不能采取措施弥补自己的知识短板，就算明确了所有短板也无济于事。消除短板的关键就是定位短板。你必须要确切地知道自己需要学什么，保证焦点明确。\n采取行动 在接下来的几天里随身带着一个记事本，把自己遇到 的不明白的地方都记下来。 在谈话中遇到自己不明白的地方，即使觉得尴尬，也要有意识地提问 明确自己一天中的某些“痛点”，通过弥补自己知识上的短板，找出消除痛点的方法。 生产力 做该做的工作\n一切始于专注 生产效率高并不能保证你是高效的。产量多只能表明生产效率高，只有完成正确的工作才会成为高效的人。如何让更多的工作忙完成呢？这一切都源于专注。专注对于完成任何任务都是至关重要的。\n什么是专注 简言之，专注就是注意力分散的对立面。我们生活的世界充满了太多的诱惑，很多人并不知道真正的专注是什么，很容易忙忙碌碌一整天却从示到达专注点。专注，就像生活中的许多事情一样，就是一个关于“冲量”的游戏。想要达到专注工作的状态很验证，但是一旦进入专注状态，就能轻松保持。\n专注的魔力 专注非常重要，因为它可以让我们在处理任务的时候不必一遍又一遍地重复基础部分。\n如何更专注 你可以挑选一些耗时15到30分钟的任务。现在就去完成这样的任务，你必须完全专注于做这件事，不要想别的事情，只关注于这一项任务。要进入专注模式，必须要克服将自己的思绪集中于单一任务时的那种痛感。\n没有听起来那么容易 专注并不像坐下来在键盘上打字那么简单。你要激发自己的斗志，对搞各种让你分心的事情，只有打败它们，你才能升档到“高速”，将自己送入巡航状态。与分心作战需要一些沉思熟虑。在开始一项任务之前，确保你已经做好一切可以让自己免受干扰的措施，不管是内部干扰还是外部干扰。\n采取行动 想一想自己极度专注于工作的时候。那是一种什么感觉？是什么令你进入 这种专注模式？又是什么最终打破了你的专注？ 时不时实践一下专注。选一项大概需要占用你半小时或者更长时间的任务，给完成这项任务分配一个完整的时间段，完全专注于这项任务。迫使自己只集中精力在这一项任务上。当你进入专注状态时，在心里记住是什么感觉。 我的私房“生产务提升计划” 概览 季度计划 月计划 周计划 日计划及执行 与干扰作斗争 休息和休假 番茄工作法 番茄工作法概述 它的基本思路是：你规划出打算一天之内完成的工作，然后设置一个时长25分钟的定时器，去完成计划中的第一项任务；在这25分钟之内，你只专注于这一项任务，心无旁骛。一旦有肺感染，可以用各种方法屏蔽掉干扰，但是通常你要努力保证自己完全不被打扰。总之，你不希望自己的专注的工作状态被打断。在25分钟结束的时候，设置一个5分钟的定时器，休息一下。这就是所谓的一个“番茄钟”。每4个番茄钟后，你都需要休息一会儿，通常是15分钟。\n有效利用番茄工作法 番茄工作法只有被当作估算和评估工作的工具使用时，才能发挥它的真正威力。通过跟踪自己在一天内完成了多少个番茄钟，以及为每天要完成的番茄钟的数量设定目标，你瞬间有能力去真正评估自己每日工作的努力程度，也能知晓自己的工作能力。有效地利用番茄工作法，不但让自己全天保持专注，而且 可以计划每天和每风吹雨打的工作，找出自己每天的时间都用到哪儿去了，激励自己尽量工作得更富有成效。使用番茄工作法，你可以把每周看作是由有限个番茄钟组成的。想在第完成一定数量的任务，你要搞清楚自己一风吹雨打能工作多少个番茄钟，并相应地设置任务的优先级。通过计算自己完成的番茄钟的数量，可以确切知道自己一风吹雨打完成了多少任务，也就不会觉得自己没完成足够量的任务。\n你可以完成多少工作 如果你打算采用番茄工作法，要先确保你对自己能力有符合实际的预期。你每周工作40小时并不意味着你能完成80个番茄钟。每人每天能够专注地、富有成效地工作的时间是有上限的。你的时间只有那么多，要怎么利用你自己说了算。\n行动 试卷用一下番茄工作法。不用担心要给每天设置多少个番茄钟的目标，只是试着使用这种方法，并列出你一整周能够完成多少工作。 一旦了解自己一周能完成多少个番茄钟，你就可以给下一周设定目标了，看看能不能达到这个目标，留意自己最后完成了多少工作，以及完成每天设定的番茄钟目标之后自己感觉如何。 我的“定额工作法”：我是如何做到超额完成工作的 想想自己每周或每月要完成哪些任务，把它们写下来。\n定额工作法的工作原理 挑选一些需要重复去做的任务，设定一个定额，即明确自己在一个给定的时间段内完成该项任务的频率。一量你明确自己做什么，多久做一次，接下来的步骤就是要做出“承诺”。真正的承诺意味着你要不遗傻地完成自己设定的任务。这意味着除非身体丧失工作能力，否则没有任何情况可以阻止你去完成任务。定额工作法的规则：\n挑选一荐重复性任务 明确有效时限，在此期间该任务被重复执行。 明确在给定的有效时限内该 任务应该完成的次数的定额 给自己承诺：一定要达成定额 调整。调高或者调低定额，但是不能在有效时间段之内调整。 定额工作法为什么有效 以缓慢但稳定的节奏工作，要优于快速但缺乏持久和坚持的工作方式。\n行动 列出自己生活中需要重复做的所有任务。特别要专注于那些目前你还无法持续完成但一旦完成就会从中受益的事情。 选择至少一项任务，承诺在规定时间段内要完成的额度。认真对待这一承诺，试着坚持至少5个时间段，想象一下，如果自己能坚持几个月或几年，会发生什么。 对自己负责 让人们完成工作主要有两大动机——内部和外部。内部动机要比外部动机有效得多。所以，秘诀是让你的主要动机来自内心而非外部。\n责任感 培养出在没有人监督自己的时候也能高效工作的自我责任感非常重要。但是如果你缺乏对自己的责任感，你交依赖外部动机来驱使你努力工作。你容易折服于一根胡萝卜的诱惑，也容易屈服于一根大棒的威胁。自我控制是一门自我激励的艺术，而自我激励的核心则是自我责任感。如果你想不南依赖别人的影响，获得稳定，可预测的结果，你就要学会对自己负责。\n对自己负责 要培养“对自己负责”的精神，道德要让自己的生活井然有序。如果你不知道应该做的事情是什么，就不能真正为自己所做的任何事情承担责任。你必须通过为自己设定规则，将这种条理性自愿地应用于自己的生活中。你需要创建自己的规则来管理自己的生活，并且要在自己思维清晰、大脑沿未被错误 的判断蒙蔽的时候，提前制订好这此规则。\n外部问责 你还可以请别人监督自己履行责任，完成自己的承诺，这样并没有什么坏处。找到责任监督伙伴——理想情况下，最好是跟你有类似目标的人，这样会很有帮助。最重要的是要确保自己对自己行为带有某种责任感。坚守自己设定的标准时，生产效率会高很多。\n行动 抉择一下：你想如何度过自己的一生。花点儿时间创建一些自己的规则，确保自己朝着正确的方向前进。 创建自己的责任制度，帮助自己严格执行规则 要不要多任务并行 为什么多任务并行一般都很糟糕 多任务导致效率低下的根本原因似乎在于，我们根本没有能力真正去践行多任务并行。多任务并行的时候，很容易打破专注力，最后你不得不花时间回到之前的任务。当你不在专注模式下时，很容易会拖延时间，或者会让其他的干扰分散注意力。\n批量处理生产效率更高 指一次性完成一系列互相关联的任务，而不是将它们拆分完成。潜在的适合批量处理的领域\n处理电子邮件 打电话 修复BUG 开短会 什么才是真正的多任务并行 真正的多任务并行使我极大地提升了自己的生产力。如果你可以将两项任务组合起来，并且真正做到同时处理它们两个，你才能完成更多。最有可能的就是，将一项不费脑筋的任务和一项一定程度上需要精神专注才能完成的任务组合起来。比如，写代码，听音乐。健身，听播客。\n行动 停止任何并百真正的多任务并行的多任务并行。每天力争在一个时间段内只做一件事。番茄工作法对此有很大帮助。 一次性批量处理小任务，而不是每天或每周里做许多次 找出能够真正实现多任务并行的领域。任何不需要耗费脑力的活动都可以跟其他活动结合起来。只要进行任何需要耗费脑力的活动，就将其与体育运动结合起来。 职业倦怠 提高生产力的最大障碍之一就是身体和心理上的倦怠。\n为什么会产生倦怠 作为人类，我们往往会对则出现的新鲜事物激动不已。但是之后，因为对它们习以为常了，我们要么把它们看作是理所当然的。要么会心生太厌烦。你越是努力工作，完成的工作就越多，这种倦怠感得就会越快。这就是难以取得工作成效的原因。工作效率 越高，你从中体会到的愉悦感就越少。\n事实上，你不过是撞到了一堵墙 在墙的另一侧 如果能咬紧牙关坚持到底，如果双腿穿越那堵墙战胜自己，最终你会发现，简单地无视它的存在，你的倦怠感已经不治自愈。经历痛苦就是克服倦怠的秘诀。你以后还会撞到更多的墙，但每穿越它一次，你将会体验到全新的动力，充沛的活力。另外，你人竞争都的数量会越来越少。\n穿过那堵墙 在动机水平处于低点的时候还继续坚持真的很难。没有动机，你不会有紧迫感。你觉得完全是在反其道而行之。你需要的只是些许条理 。你或许一下关于保持对自己负责的内容，但本质上，你需要为自己创建一套确保自己继续前行的规则。\n行动 想想以前都有哪些项目是你付出努力却没有最终完成而半途而废了。是什么原因让你放弃的？你现在对这件事儿有什么感受？ 下次开始新项目的时候，下定决心，你一定会完成，或者完全掌握。设定规则和约束条件，强迫自己穿过那堵不可避免的墙 如果你正面临职业生涯或者个人生活中的那一堵墙，试着去穿越它。想想在墙的另一侧会有怎样的收获等着你。想象自己的动机和兴趣终将获得回报。 时间是怎样被浪费掉的 最大的时间杀手 停止看电视。。。\n其他时间杀手 社交媒体是一个主要的时间杀手。 新闻网站 不必要的会议 烹饪 玩电子游戏,尤其是网络游戏 工间喝咖啡休息 跟踪你的时间 你可以使用RescueTime等这类工具来跟踪自己一天中到底是如何花费时间的。\n行动 下一周，精心地跟踪一下自己的时间花费情况。获取精确的数字，了解每天的每小时你都是怎样花掉的。看看数据，找出你最大的2-3个时间杀手。 如果你有看电视的习惯，尝试离开电视一周，即尝试度过一个无电视周，看看如果不看电视你都会做些什么。 弄清楚哪些时间是可以买回来的，如果雇人为你修剪庭院，做保洁等 形成惯例的重要性 生产力的真正秘诀在于：长期坚持做一些小事。\n创建一个惯例 一个好的惯例始于一个大的目标。一旦挑选好了大目标，接下来就要弄清楚怎样才能每天或每周前进，最终实现目标。大目标将构成惯例的基础，你要围绕这一目标自己的日程。然后就是精确地安排这些时间。\n让惯例更细化 强烈建议安排好每个工作日的时间，以便自己知道每天，每周要做什么。\n运行 你目前有哪些惯例？跟踪一下你的日常活动，看看你已经在遵循的惯例有哪些 选择一个大目标，以每个工作日为单位制订例行安排。计算一下，如果你每天都朝着这个目标前进，一年下来你会取得多大的成就。 培养习惯 每个人都有习惯，有好有坏。好习惯能够失去我们前进，帮助我们成长；坏习惯则阻止我们前进，阻碍我们成长。\n了解习惯 习惯主要由三个要素构成：暗示，惯例和奖励。暗示是导致习惯被触发的某样东西。它可能是某一天的某个特定时刻、某种形式的社交场合、某个特定的环境或者其他任何东西。惯例就是你做的事情，也就是习惯的本质。奖励就是让习惯真正保持下去的“锚”这是一种你从执行习惯中获得的良好感觉。奖励可能只是一种满足感。\n找出坏习惯，改掉 养成新习惯 运行 跟踪你的习惯。哪些习惯对你目前的生活影响最大？你认为其中有多少是好习惯，又有多少是坏习惯？ 挑选一项你的坏习惯，试着把它转变成好习惯。在开始做之前，先在自己脑海中设想一下从现在起一周之后、一个月之后、乃至一年之后你会有什么成果。 分解任务 造成拖延的首要原因之一，同时也是造成生产力低下的祸根，就是总是在感慨一个问题：好忙啊，问题好大啊……实际上，你并没有真正试着去解决问题。我们需要试着去分解任务，通过将大任务分解成小任务，你会发现自己更有动力去完成它们，也更加稳妥地向着目标前进。\n为什么更大并不总是更好 任务越大，看起来就越吓人。这些大任务或大项目给我们带来了恒上的伤害，也削弱了我们的生产力——因为我们无法年楚未来的前景。大型任务往往也很难估算完成时间。大型任务是一种智力挑战，与小任务相比，大任务更可能导致拖延，通常描述也更少，更容易出错是，\n分解任务 事实证明，大多数大任务都可以被分解成更小的任务。\n如何分解任务 大多数任务都可以通过一次一步的方式分解成许多小任务。如果想承担一项大任务，又不想被它吓倒，你首先要明确完成这项任务需要哪些步骤。如果你把大任务拆分成小任务的时候遇到问题，很可能是由于缺少信息。但这并不是坏事。在项目早期发现信息不足要比项目已经进展很多后才以现信息不中要好得多。\n行动 当前，你因为其规模惊人放弃了哪些大型任务？你会在打扫车库、写博客文章、解决复杂算法等事情上拖延吗？ 选出一个你当前面临的最大问题，看看能否找到好办法将它分解为更小的任务。 努力工作的价值，以及为什么你总是逃避努力工作 努力工作是成功的必要条件，无法逃避\n为什么努力工作是如此的辛苦 艰苦的工作最有可能是让我们获益良多的工作。艰苦的工作最有可能是推进我们职业发展或者为我们打开机遇之门的工作。所以没有任何好处的工作看起来总是那么轻而易举。\n如果我只是“聪明地”工作 如果真想富有成效，你就不得不学会工作的时候既聪明又努力。光有聪明是不够的。一定量的必须具备的，然而想获得真正的成功，面对挫折的时候一定量的毅力也是必要的。\n努力工作总是枯燥的。 被我们认为困难的事情，实际上都是我们不想做的事情，因为它们不那么激动人心，也不那么光彩照人。\n现实 在所有的情况下，我们所面对的现实就是，没有一件事情是轻而易举的。如果真想成功，如果真想要成为成功人士，你就不得不在有些时候通宵达旦。不过，这并不意味着你永远都不能有片刻轻松。成功会带来更多的成功。越成功就越容易获得成功。但是，攀登第一座山峰的过程是漫长又艰难的。\n努力工作：如何做到这一点 你只需要下定决心去做那些需要做的工作。你必须认识到，工作最终必须要被完成，所以还不如现在就做，而不是拖到以后；你必须认识 到，你要想实现目标，要想发挥出自己的全部潜力，唯一的途径就是自愿咬紧牙关、硬着头皮、开始工作。\n任何行动都比不采取行动好 在软件开发的职业生涯中，没有什么比不采取行动对生产力更致命了。\n我们为什么拒绝采取行动 恐惧可能是最大的原因\n不采取行动会发生什么 如果我们宁可选择无所作为，也不愿意选择次优方案或者承担失败的风险，那么这些无头紧要的决定也会对我们的生活产生巨大的影响。\n可能最坏情况是什么 现在要怎么做 采取行动时的检查表\n采取行动的检查表 答案 阻拦我采取行动的障碍是什么 如果我需要做出选择，我的选择会是什么？我要从哪些选项中做出选择？ 做出了错误的选择会导致的最坏结果是什么？ 如果我选择失误，我可能退回去选择其他选项吗？这么做的代价高吗？ 选择之间的区别是否很大？我能选择可以立即采取行动的次优方案吗？ 我当前面临的问题有助于自我发现吗？如果开始我采取一些行动，在我发现正在的行动之前，还能进行调整吗？ 如果我不采取行动，会发生什么？会有什么代价？是浪费时间，错过机会，还是损失金钱？ 采取行动 挑选你知道你应该采取行动的事项 识别出过去因为不采取行动而错过的机会，如购买或者出售股票、投资一家公司或者创业 如果上述这些事项没有像你希望的那样发展，最坏的结果是什么？ 最好的结果又是什么？如果当前的行动目标过于复杂，难以决断，你能做出哪些小一眯儿的决定 来继续前进？例如，如果 你要决定到底是学弹吉他还是学弹钢琴，你可以决定先暂时学哪一样，同时决定长期学哪一样吗？\n理财 怎样支配你的薪水 拒绝短期思维 资产与负债 所谓交道，是指实用价值高于维护成本的东西。也就意味着，一样东西如果有资格被定义为“资产”，必须能够带来比自身成本更高的价值。所谓负债，是指成本高于带来的价值的东西。也就是说要保有“负债”，你不得不往外挣钱，但你永远也拿不回来与自己掏出的钱一样多的钱。资产与负债\n资产 负债 可获得股息的股票 信用卡债务 可供出租的不动产 房产（如果超出你的实际需要） 债券 车（如果超过你的实际需要） 音乐版权授权 每用的服务旨 软件版权授权 所有随着时间推移会贬值的设备 企业 严格上来讲，任何能把钱装在你口袋里的东西才叫资产，而任何需要你把钱从口袋里掏出来的东西都是负债。\n回到薪水这个话题 如果想在财务上获得成功，就必须学会如何投资，别无选择。即使你工作一辈子，竭尽全力丰钱，如果代不到理财的方法，你也永远不会变得富有，更遑论财务自由。\n行动 算一下每个月你经手的资金。看看每个月你能赚多少钱，这些钱最后又去了哪里。是否大部分资金最后都变成了资产而非负债。 计算一下，为了达到在银行存款100万美元的目标（或者其他你认为可以达到财务自由的目标所需要的数额），每年你得存多少钱。再算一算，如果不做投资，你一辈子能攒够这么多钱吗？ 开始问自己“我能攒多少钱”，而不是“我能花多少钱”。 怎样进行薪酬谈判 薪酬谈判非常重要，不只是因为随着时间的推移，你的薪水会不断累积，最后所得摆在桌上可以越垒越高，还因为在薪酬谈判中你如何评价自己与如何把控自己会极大地影响你所服务的公司对你的看法。\n薪酬谈判始于求职之前 你的薪酬又有点能力很大程度上受声望的影响。对某些人来说，这是要看机遇，但对大多数软件开发人员来说，这需要仔细的规划和策略。为了做到这一点基本策略就是尽可能让自己的名字出现在各种媒体上。写博客，做播客，写书或文章，在大会或用户组中发表演讲，制作视频教程，为开源项目上贡献代码等，尽可能让自己的名字出现在各种场合。只要记住：自我营销做得越好，声望越高，薪酬谈判就越容易。\n获得工作的方式至关重要 获得工作的几种方式：第一种，你看到一份招聘启事，然后发送自己的简历去申请该职位，最好再附上一封优美的求职信息。其实这是获得工作最糟糕的一种方式。另一种方法是能过他的推荐。最佳状态就是，一家公司知道你，然后无需要任何面试就直接为你提供一个职位。在这种情况下，你尽可以根据自己的声望为自己标价。\n先出价者输 先出价的人会处于明显的劣势。\n被要求先出价该怎么办 如果职位申请表上有这一字段，如果可以的话干脆空着不填，或者简单填写“根据整体薪酬方案面议”。如果必须得写个具体的数字，那就填成0，后续再解释为什么。如果雇主拒绝先出价，你不得不先出价，那就给出一个跨度很大的范围，并且以整体薪酬方案为条件，但要确保该范围的最小值略高于你心理价位的最低值。\n被问题及当前薪酬怎么办 尽量绕过问题。\n拿到offer的时候 可以在拿到offer后再一次还价。\n最后一些建议 一定要清楚自己值什么价钱。尽可能娱乐性地研究一下自己求职的公司的薪酬范围，研究一下与你申请的职位类似的薪酬范围。你对自己薪酬的调查工作做得越好，谈判起来就越容易。要求这样的薪酬的理由绝对不是“我需要这么多钱”。没人在乎你需要什么。相反你要说清楚自己为什么值这个价钱，你能给公司带来什么好处。尽可能一次多获得几个offer，但是要小心，别让它们互相旁人。如果你拥有“转身离开”的能力，那么在任何谈判中你都具有明显的优势。你可以用得体的方式做到这一点，告诉他们你已经有几个offer,现在正在沉思熟虑，希望做个最好的决定。但是，要小心，语气不要太傲慢。自信是好事，傲慢就是坏事了。\n行动 尽可能练习谈判技巧，以便克服对谈判的恐惧感。下一次去商店买东西的时候，试着计价还价，即使没成功，也会获得一些宝贵的经验。 仔细研究一下行业薪酬水平，以便了解自己值什么价钱。试着找出你所在领域的公司给职员的薪酬是多少，跟自己当前的薪资情况比较一下。 即使不找工作，也可以试着去参加一下面试。你也许会发现，当自己无所求的时候（因为这时你并不需要找新工作），谈判更容易。说不定你能通过这种锻炼找到更好的工作。 期权：所有乐趣之所在 期权的基础知识 期权就是选择做什么或者不做什么。期权背后的基本思想就是允许某人在未来的某个日期买入或卖出股票的权利付费。\n深入了解期权 期权从根本上说就是赋予你在未来某个日期之前以固定价格购买一定数量股票的选择权。但你也可以购买另一咱让自己在未来某个日期之前以固定 价格出售一定数量股票的选择权。这种期权能让你在股价下跌的时候也赚钱。\n卖出期权 从技术上讲这叫“沽出期权”，因为你创建了一份期权合约以供他人可以买入。在你沽出期权的时候，你其实是在赌盘的另一边下注。你不是赌股份涨跌，而是赌股价要么停在目前的水平，要么走向期权的反方向。\n更复杂的期权 房地产投资面面观 为什么要投房地产 最大原因就是稳定性\n第一步：学习 第一步就是房地产市场的学习。\n采取行动 一旦对房地产市场有了不错的感觉，就该采取行动了。\n利用物业托管 你真的了解自己的退休计划吗？ 退休计划就是利用逆向思维 规划退休计划的关键就是利用逆向思维，精确计算每个月的生活费用，找出办法确保自己的收入能满足这一要求，同量还留有余地，以备不时之需。\n计算你的退休目标 一旦算出自己退休以后每个月的生活开销是多少，当你“被动收入”达到每用所需的生活开销的时候，你就可以正式退休了。\n行动 计算你的当前每月支出。看看如果自己愿意做出一些牺牲的话，能削减多少开支。 计算一下，精简开支后，你每月要赚多少钱才能实现退休，记得要给息留有缓冲余地。 弄清楚根据不同的投资回报率，你要多少钱才以须退休的时候每个月的足够的收入。 债务的危害：社保债务代价昂贵 真正财务成功的唯一方法就是用钱生钱。如果想获得财务自由，你就必须要能够让你的钱为你所用。如果说收益给我们自由，那么后面一定要再加上一句——债务会给我们套上枷锁。\n为什么债务一般都是不好的 当你身背债务的时候，通常会靠自己的钱去支付利息，这就意味着，虽人可能通过你的开销致富。\n债务方面常见的愚蠢之举 以错误的顺序偿还债务。\n并非所有的债务都是不好的。 如果你能利用债务赚到时的钱比为这一债务支付的利息多，这样的债务就是好的。\n行动 列出你的所有债务的清单，把它们区分为两类：好的债务和不好的债务。 把不好的债务按照利率从高到低排序，计算一下多久你可能清偿所有债务。 额外馈赠 “退休”的确切含义是什么 退休，代表着“自由”，具体而言，即财务自由——一种不会囿于财务善被迫用自己别无选择的方式将自己的时候花费在不合心意的事情上的能力。\n健身 为什么需要破解自己的健康密码 健身不公是保持健康体魄的关键要素之一，也是灵活的、具有创建性的脑力活动的基础。\n自信心 好的身材能让你自我感觉良好，也能让你对能完成自己设定的目标这伯事感觉良好。这种自信心可以展现出来，体现在你和他人的交谈与交往当中。此外，还有一个不太科学的解释：当你看上去很好看的进修，你的感觉也会很好。\n大脑的力量 我不能肯定地说，是锻炼或者体脂率引起我大脑的化学变化或结构变化，从而让我更聪明、更专注 、还是只是我感觉更好，因此更加努力地工作。另外，当你总觉得疲倦，无心工作的时候，或者你觉得自己状态不佳的时候，你可能会发现，改变饮食和加强锻炼可以让你的身心同时获得新活力。\n恐惧 不要让自己醒悟得太晚，从现在起就认真对待。不要等到出了健康问题才开始关心自己的健康。\n设定自己的健身标准 挑选一个具体的目标 谨记每次不要试图挑选一个以上的目标。同时达到多个健身非常难以实现的，因为这些目标之间经常会是直接冲突的。\n创建里程碑 一旦决定 了健身的主要目标，你就应该想办法创建一系列里程碑，沿着里程碑前进你就一定会到达最终的目标。一定要确保里程碑是可以实现的。\n测量你的进展 在你向着自己的目标努力前进的时候，采用正确的方法测量自己的进展也是非常重要的。每个时间间隔，你都需要知道自己是否正朝着正确的方向前进。\n保持健康的生活方式 达成健康目标，你的战斗还远没有结束。如果不能切实改变自己的生活方式，你取得的进展很快就会消失。你必须弄清楚如何将健康的生活习惯引入你的生活，以便让定期锻炼和健康饮食成为你日常生活的组成部分。\n热力学、热量和你 什么是卡路里 卡路里根本上讲是能量的计量单位。具体而言，就是将一千克水在一大气压下提升一摄式度所需要的热量。每克碳水化合物和每克蛋白质提供 的热量大约是4卡路里，而每克脂肪提供的热量约是9卡路里。因为我们无法消化纤维，所以来息纤维的热量基本上可以忽略不计。\n减肥很简单 只要吃下去的热量比燃烧掉的热量少就可以了。\n摄入了多少卡路里 燃烧了多少卡路里 利用卡路里来实现自己的目标 动力：让你的屁股离开椅子 什么能激励你 如果你能为自己找到时一个能够激励你实现健身目标的因素，你就可以利用它来帮助自己离开椅子，立刻投入到健身运动中。\n过早奖励自己 如果你想扼杀自己的动力，那么你尽可以犯这样的错误：在做好工作之前就因为“做好工作”而奖励自己。\n保持动力的做法 即使你可能已经想出最大的激励等量关系让自己立刻开始转变成一个全新的、健康的你，但是久而久之激励很可能最终会失去效力。在各个地方张贴图片，提醒你自己想变成的样子，这是保持 动力的一种好方法。制作进度图表并且不断提醒自己你已经走了多远也是有帮助的。另一咱强大的保持动力的方法是游戏化。坚持健身计划的激励因素\n方法 说明 听有声书 我跑步或举重的时候会一直听着有声书或播客，我发现这件事值得我每天都期待 在跑步机上看电视 如果你保允许自己在跑步时才看电视，你可能会有更大的动力去跑步 外出跑步 如果你喜欢户外活动，那么外出跑步对你而言可以是一个巨大的动力 离开孩子一段时间 我们都需要给自己一点儿休息时间，许多健身房有看护服务，能在你锻炼的时候照看你的孩子 计划了就一定要执行 如果你能让自己持久保持动力，这确实很棒。但是，有时候不论有没有动力，你都得咬紧牙关坚持计划。一定要提前做好决定，这能给你约束，让你致力于自己想要采取的一系列行动。\n行动 列出你要健身或改善健康头部的原因。从这份清单中，明确三项最重要的激励因素，打印出来并张贴在不同的地方，确保自己每天都能看到。 从本章讲述的保持动力的做法中选出几条，并在生活中实践。或者找几个可以激励你的人的照片，张贴在你能看到的地方，或者找一个新的有关健身的应用，把锻炼身体变成乐趣。 在达成健身计划的某个里程碑之后给自己一个奖励。把你的进展头部画成图表，达成目标的时候奖励自己。 当你想要中断锻炼步伐的时候，停下来问自己，如果不放弃，3个月后，下一年会怎样。不管怎样那一时刻总会到来的。 如何增长肌肉：书呆子也能拥有强健的肌肉 肌肉是如何生长的 人类的身体具有令人惊讶的适应性。着急就是，通过增加你要求肌肉完成的运动量来逐步增加肌肉的负担，使身体以增长肌肉作为回应。从根本上讲主浊，你要让自己的身体相信：在增加新肌肉之前，你需要更大的肌肉。\n举重的基础知识 不同的目标 力量\n如果你的重复次数较少，而每组之间的休息时间较长，你基本上是在增强力量。\n规模\n肌肉增大主要是通过中午的重复次数和矢量的休息间隔实现的。\n耐力\n继续增加重复次数。\n准备开始 你应该做哪种举重练习 挑选好的动作的总体策略就是，要做尽可能多的复合运动。复合运动 就是会身体多处关节的练习。\n吃些什么 如何获得完美腹肌 尽管就像其部位那样，你可以通过激进必对抗性训练增大你的腹肌，介是大我数人之所以没有腹肌，不是因为腹肌不够在，而是因为他们看不到。\n你的身体不想让你有腹肌 你要明白身体是一台非常复杂的机器，它并不在乎你穿泳衣是否漂亮，它的主要关注点集中在确保让你活着。\n你该怎么做 你不仅要调节自己的包含，放弃任何禁忌的食物，还要确保自己像试图增加肌肉时那样继续做举重练习。\n启动跑步程序 不管是想减肥还是想改善心血管健康，你都可能会对跑步感兴趣。\n为什么你想跑步 跑步是最容易增强心脏、增加肺活量的方法。\n准备开始跑步吧 入门建议 在开始跑步之前，最重要的就是下定决心。如果不能坚持一周跑3次，你不会有任何实际进展。如果你不能坚持跑步，你不公不会进步反而会退步。锻炼耐力需要时间，而失去耐力却不需要太多时间。此外，刚开始跑步的时候不要太关注进展。随着时间的推移。你的跑步距离会不断增加，最终会到达你设定的目标。你必须坚持并有耐心，如果你过早地急于求成，很可能会变得心灰意冷，无法继续。\n站立式办公及其他窍门 站立式办公和跑步机上办公 包含窍门 用微波炉烹饪鸡蛋 原味脂酸奶 冷冻肉类 高科技健身关务：极客现身 步行计数器和计步器 无线体重计 组合设备 耳机 应用 精神 如果你不征服自己，你就会被自己征服\n心灵是如何影响身体的 从心灵开始 如果你不相信自己能够做到，你几乎做不成任何事情。\n心灵和身体的联系 不管这个机制是如何运转的，重要的是你要理解自己的所思所想影响着塑了你现在的生活。\n拥有正确的心态：重新启动 什么是积极性 积极思考与现实主义是不矛盾的。事实上，积极思考在应用层面上是现实主义的照张体现，因为它是一咱信念，这种信念让你有力量改变现实，让你确信你不是环境的受害者。\n积极性的正面作用 工作态度会直接影响工作表现。关于这一点，是用自己的工作效率来做的试题。\n如何重启你的态度 改变自己的想法\n如果想改变自己的态度，你就必须改变自己的想法。如果想改变自己的想法，你就必须转变自己思维模式。你的思维模式是由你的习惯决定的，因为我们可以追溯到改变你生活中处理任何关键事情所采用的主要方式——养成一个习惯。\n冥想\n某些论点表明经常冥想的人更容易体会到时正面情绪。\n劳逸结合 推荐书籍\n积极思考就是力量 构建一个积极的自我形象——规划你的大脑 什么是自我形象 自我形象是在甩掉别人对你的看法，摆脱所有用来自我安慰的谎言和欺骗以后，你看到的自己的样子。这种自我形象是很强大的，因为你的大脑往往不允许你做任何事情以违反它的自我评估。这种人为的局限性很难克服，只是你可能甚至都没有意识到它们的存在。\n自我形象是很难改变的 如果你重复做一件事同时假装你已经是自己想成为的那样的人，你归终将变成那样的人。\n对你的大脑“重新编程” 行动 列出你的缺点。不仅试着想想你是如何认知自己的，也试着想想别人又是如何认知你的。这份清单不一定完全正确——你的自我形象的很多方面被坦在了潜意识的深处，但它会是一个很好的起点。 你觉得这份清单上有哪些方面是无法改变的？为什么？想想这些方面是记久性的，还是只是因为你的偏偏给你自己带来了局限。 尝试至少改变自我形象的一个负面的方面。用本章提出的建议来进行改变。试着用这个“假装自己能成功”的方法和正面的强化自己的新信念。 爱情与恋爱：计算机无法牵着你的手 书单 自我提升和励志类图书 Steven Pressfield的The War of Art Dale Carnegie的《人性的弱点》 Napoleon Hill的《思考致富》 Maxwell Maltz的《心理控制方法》 Norman Vincent Peale的《积极思考就是力量》 Ayn Rand的《阿特拉期耸耸肩》 软件开发类图片 代码大全 代码整洁之道 Head First设计模式 投资类书 Gary Keller和The Millionaire Real Estate Investor Robert Kiyosaki的《富爸爸，穷爸爸》 Kerry Given的No-Hype Optiions Tradiing: Mythhs, Realitiies, and Strategies That Really Work 积极面对失败 因为在你的生活和事业中你很可能面对大量的困难。\n为什么我们总是害怕失败 畏惧失败似乎是大多数人的本能。人都喜欢做自己擅长的事情，逃避做那些自己涌胜任的或是缺乏技能的事情 。我们似乎与生俱来畏惧失败。这可能是基于保护脆弱的自尊的想法。或许我们害怕失败就是因为我们太过将失败归咎于个人，我们认为在特定领域下的失败是个人价值的流逝。即使我们知道失败并不是终点，我们似乎也能感受到这一点。我们往往太过较真，把失败看得太重。\n失败并不是被打败 失败不同于被打败。失败是暂时的，被打败是永恒的。要实现不畏惧失败，第一步就是真正意识到失败不是终点——除非你选择把它看作是终点。\n失败是通往成功的必经之路 不要畏惧失败，要拥抱失败。不只是因为失败和被打败 不同，还因为失败是通往成功的必经之路。生活中所有值得拥有、值得去完成的事情都需要经历失败。\n学会拥抱失败 只是不畏惧失败还不够，还要主动寻觅失败。想成长就必须把自己放在保证会失败的环境中。我们常常会因为停止做那些对我们有挑战或者危险的事情而停滞不前。\n结束语 ","permalink":"https://stoneepigraph.github.io/posts/%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%E7%9A%84%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97/","title":"代码之外的生存指南"},{"content":" 提问 提问的智慧 提问的智慧http://www.catb.org/~esr/faqs/smart-questions.html 提问的智慧https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md 学习新技术的逻辑 这个技术出现的背景、初衷和要达到什么样的目标或是要解决什么样的问题。这个问题非常关键，也就是说，你在学习一个技术的时候，需要知道这个技术的成因和目标，也就是这个技术的灵魂。如果不知道这些的话，那么你会看不懂这个技术的一些设计理念。 这个技术的优势和劣势分别是什么，或者说，这个技术的 trade-off 是什么。任何技术都有其好坏，在解决一个问题的时候，也会带来新的问题。另外，一般来说，任何设计都有 trade-off（要什么和不要什么），所以，你要清楚这个技术的优势和劣势，以及带来的挑战。 这个技术适用的场景。任何技术都有其适用的场景，离开了这个场景，这个技术可能会有很多槽点，所以学习技术不但要知道这个技术是什么，还要知道其适用的场景。没有任何一个技术是普适的。注意，所谓场景一般分别两个，一个是业务场景，一个是技术场景。 技术的组成部分和关键点。这是技术的核心思想和核心组件了，也是这个技术的灵魂所在了。学习技术的核心部分是快速掌握的关键。 技术的底层原理和关键实现。任何一个技术都有其底层的关键基础技术，这些关键技术很有可能也是其它技术的关键基础技术。所以，学习这些关键的基础底层技术，可以让你未来很快地掌握其它技术。可以参看我在 CoolShell 上写的 Docker 底层技术那一系列文章。 已有的实现和它之间的对比。一般来说，任何一个技术都会有不同的实现，不同的实现都会有不同的侧重。学习不同的实现，可以让你得到不同的想法和思路，对于开阔思维，深入细节是非常重要的。 ","permalink":"https://stoneepigraph.github.io/posts/study/","title":"学习"},{"content":" 精通Git Git基础 获取Git仓库 $ git init 记录每次更新到仓库 git add . git commit -m 'commit mesg' 查询提交历史 #+END_SRC git log #+END_SRC\n撤消操作 git commit --amend 这个命令会将暂存区中的文件提交，如果自上次提交以来你还未做任何修改，那么快照会保持不变，而你所修改的只是提交信息。 e.g.\ngit commit -m 'initial commit' git add ofrgotten_file git commit --amend 最终你只会有一个提交 - 第二冷饮提交将代替第一次提交的结果。\n取消暂存的文件\ngit reset HEAD 撤消对文件的修改\ngit checkout xxx.file 远程仓库的使用 查看远程仓库\nget remote -v 添加远程仓库\ngit remote add \u0026lt;shortname\u0026gt; \u0026lt;url\u0026gt; 从远程仓库中抓取与拉取\n#+END_SRC git fetch [remote-name] #+END_SRC\n推送到远程仓库\n#+END_SRC git push origin master #+END_SRC\n查看远程仓库\ngit remote show origin 远程仓库的重命名\ngit remote rename oldname newname 远程仓库的移除\ngit remote rm remotename 标签 列出标签\ngit tag git tag -l 'XXXX*' 创建标签\n附注标签 -a选项 git tag -a v1.4 -m 'version 1.4' git show v1.4 轻量标签 git tag v1.4-lw 后期打标签 git tag -a v1.2 commitId 共享标签\ngit push origin tagname 如果想一次性推送很多标签可以使用带有\u0026ndash;tags\ngit push origin --tags 检出标签\ngit checkout -b [branchname] [tagname] Git别名 git config --global alias.co checkout git config --global alias.br branch git config --global alias.ci commit git config --global alias.st status Git分支 分支简介 分支创建\ngit branch branchname Git通过一个名为HEAD的特殊指针区分当前是在拿一个分支上。可以将HEAD想像成当前分支的别名。可以使用git log命令查看各个分支当前所指的对象。\ngit log --oneline --decorate 分支切换\ngit checkout branchname 切换后HEAD就会指向新的branchname 可以使用git log 查看分叉历史\ngit log --oneline --decorate --graph --all 分支的新建与合并 git checkout -b branchname 这条命令相当于\ngit branch branchname git checkout branchname 将新分支合并到主分支上\ngit checkout master *切换回主分支 git merge branchname * merge分支到主分支 删除无用分支\ngit branch -d branchname 遇到冲突时的分支合并\ngit mergetool 该命令会为你启动一个合适的可视化合并工具然后\ngit add . git commit -m 'xxxxx' 分支管理 查看分支\ngit branch 会列出所有的分支，带*字符的表示当前检出的分支如果想查看每个分支的最后一次提交可以\ngit branch -v \u0026ndash;merged与\u0026ndash;no-merged这两个选项可以过滤这个列表中或沿示合并到当前分支 的分支。\ngit branch --merged 这个列表中不带*号的分支表示已经合并到当前分支了，可以安全删除还可以查看尚未合并到当前分支的分支\ngit branch --no-merged 这里显示的分支使用git branch -d删除会失败。因为会丢失信息。不过可以使用git branch -D强制删除\ngit branch -D branchname * 强制删除分支 分支开发工作流 远程分支 显示获得远程引用的完整列表\ngit ls-remote 推送\ngit push (remote) (branchname) 将branchname推送到remote服务器或\ngit push (remote) localbranchname: originbranchname 拉取\n将远程指定分支合并到当前所在分支\ngit merge origin/branchname 或建立本地分支跟踪远程分支\ngit checkout -b localbranchname origin/remotebranchname 或\ngit checkout --track origin/remotebranchname 设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，你可以在任意时间使用-u或者\u0026ndash;set-upstream-to 选项运行git branch来显示设置\ngit branch -u origin/originbranchname 如果想要查看设置的所有跟踪分支，可以使用git branch的-vv选项。这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否领先、落后或是都有。\ngit branch -vv git pull\ngit pull = git fetch + get merge\n删除远程分支\ngit push origin --delete originbranchname 变基 在Git中整合来自不同分支的修改主要 有两种方式：merge和rebase\nrebase\ne.g.\ngit checkout experiment git rebase master 它的原理是首先找到这两个分支（即当前分支experiment,变基操作的目标基底分支master)的最近共同祖先，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底，最后以此将之前另存为临时文件的修改依序应用。现在回到master分支，进行一次快进合并 #+END_SRC git checkout master git merge experimet #+END_SRC e.g.\ngit rebase --onto master server client 将client中的修改合并到主分支并发布，但暂时不合并server中的修改\ngit rebase master server git checkout master git merge server 将server中的修改变基到master上，server中的代码被“续”到了master后面。\n服务器上的Git 协议 本地协议，HTTP协议，SSH协议以及Git协议。\n本地协议\n本地协议中，无程版本库就是硬盘内的另一个目录，常见于团队每个成员都对一个共享的文件系统拥有访问权。 e.g.\ngit clone /opt/git/project.git 或\ngit clone file:///opt/git/project.git 增加一个本地版本库到现有的Git项目\ngit remote add local_proj /opt/git/project.git 优点 简单 缺点 共享文件系统比较难配置，并且比起基本的网络连接访问，不方便从多个位置访问。 HTTP协议\n智能（Smart）HTTP协议 哑（Dumb）HTTP协议\n优点 不同的访问方式只需要一个URL以及服务器只需要授权时提示输入授权信息 HTTP/S协议被广泛使用，一般企业防火墙都会允许这些端口的数据通过。 缺点 在一些服务顺上，架设HTTP/S协议的服务端会比SSH协议的棘手一些。 SSH协议\ngit clone ssh://user@server/project.git 或 scp式写法 #+END_SRCsell git clone user@server:project.git #+END_SRC\n优点 SSH架设相对简单 SSH访问是安全的 与HTTP/S协议、Git协议及本地协议一样，SSH协议很高效，在传输前也会尽量压缩数据。 缺点 你不能通过他实现匿名访问。 Git协议\n这是包含在Git里的一个特殊的守护进程；它监听在一个特定的端口（9418），类似于SSH服务，但是访问无需任何授权。\n在服务器上搭建Git 将现有的仓库导出为裸仓库\u0026ndash;即一个不包含当前工作目录的仓库 git clone --bare my_project my_project.git 现在，你的my_project.git目录中应该有Git目录的副本了。整体上效果大致相当于\ncp -Rf my_project/.git my_project.git 把裸仓库放到服务器上 假设服务器git.example.com的服务器已经架设好 ，并可以通过SSH连接，你想把所有的Git仓库放在/opt/git目录下，你可以通过以下命令复制你的裸仓库来创建一个新仓库：\nscp -r my_project.git user@git.example.com:/opt/git 此时，其他通过SSH连接这台服务器并对/opt/git目录拥有可读权限的使用者，通过运行以下命令就可以克隆你的仓库。\ngit clone user@git.example.com:/opt/git/my_project.git GitLab 可以在http://bitnami.com/stack/gitlab%E4%B8%8A%E8%8E%B7%E5%8F%96%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E5%8C%85， 同时调整配置使之符合你的特定的环境。\n","permalink":"https://stoneepigraph.github.io/posts/git/readnote/%E7%B2%BE%E9%80%9Agit_22/","title":"精通Git(2)"},{"content":" 开始 本章重构：\n将原函数分解成一组嵌套的函数 分离计算逻辑与输出格式化逻辑 为计算器引入多态性来处理计算逻辑 好的代码的检验标准就是人们是否能构轻易地修改它注： 小步累积\n重构的原则 何谓重构 名: 对软件内部结构的一种调整,目的是在不改变软件可观察行为的前提下,提高其可理解性,降低其修改成本. 动: 使用一系列重构手法,在不改变软件可观察行为的前提下,高速其结构. 重构时不添加新功能,添加新功能时不重构. 为何重构 改进软件的设计 使软件更容易理解 帮助找到BUG 提高编程速度 何时重构 事不过三, 三则重构\n预备性重构: 在添加新功能之前进行重构 帮助理解的重构: 捡垃圾式重构: 不想从眼下正要完成的代码上跑题太多,但也不想把垃圾留在原地.所以在重构可以很快完成时就立即重构,如果需要花一些精力,可以做一个TODO.至少要让营地比你到达时干净. 有计划的重构和见机行事的重构每次修改时,首先令修改很容易,然后再进行这次容易的修改. 长期重构如果想替换掉一个正在使用的库,需要很长时间,可以先引入一层新的抽象,使其兼容新旧的两个库的接口.一旦调用方已经完全为使用这层抽象,替换掉下面的库就会容易很多. 重审代码时重构 何是不应该重构 如果我看见一块凌乱的代码,但并不需要修改它,那么我就不需要重构它. 如果丑陋的代码能被隐藏在一个API之下,我就可以容忍它继续保持丑陋. 如果重写比重构还容易,就别重构了. 重构的挑战 延缓新功能开发 代码的坏味道 神秘命名 重复代码 过长函数 现代编程语言几乎已经完全免除了进程内的函数调用开销.\n过长的参数列表 如果可以向某个参数发起查询而获得另一个参数的值,那么就可以使用以查询取代参数去掉这第二个参数. 如果正在从现有的数据结构中抽出很多数据荐,就可以考虑使用保持对象完整手法 如果有几项参数总是同时出现,可以引入参数对象 如果某个参数被用作区分函数行为的标记,可以使用移除标记参数. 全局数据 可以把全局数据用一个函数包装起来,至少能看见修改它的地方.\n可变数据 发散式变化 每次只关心一个上下文\n霰弹式修改 依恋情结 总是将一起变化的东西放在一块儿.\n数据泥团 基本类型偏执 可以运用使用对象取代基本类型\n重复的switch 任何switch语句都应该用以多态取代条件表达式.\n循环语句 可以使用管道取代循环\n冗赘的元素 有些类或者额外的结构在设计过程中不再有用,就把它抛弃\n夸夸其谈通用性 那些我们想的总有一天需要做这些事,并且企图以各式各样的钩子和特殊情况来处理一些非必要的事情.\n临时字段 过长的消息链 可以使用隐藏委托关系\n中间人 如果你看到某个类中有一半的函数都委托给其它类,这样就是过度运用.应该移除中间人.\n内幕交易 如果两个模块有共同的兴趣,可以尝试再新建一个模块,把这些共用的数据放在一个管理良好的地方\n过大的类 如果想利用单个类做太多的事情,其内往往就会出现太多字段\n异曲同工的类 纯数据的类 被拒绝的遗赠 注释 如果需要太多注释注解的代码,往往意味着需要重构\n构筑测试体系 自测试代码的价值 介绍重构名录 第一组重组 提炼函数 将意图与实现分开\n内联函数 提练变量 内联变量 改变函数声明 函数改名 添加参数 移除参数 修改签名 封装变量 封装能提供一个清晰的观测点，可以由此监控数据的变化和使用情况。\n变量改名 引入参数对象 将多个总是同时出现的值参数组合成类，形成一个概念，可以更好的理解业务。\n函数组合成类 函数组合成变换？ 拆分阶段 每当看见一段代码在同时处理两件不同的事，就可以把它拆分成各自独立的模块。\n封装 封装记录 以数据类取代记录\n封装集合 不要直接使用集合的字段，而是通过定义类上的方法来代替。\n以对象取代基本类型 一旦发现对某个数据的操作不仅仅局限于打印时，就为它创建一个类。\n以查询取代临时变量 把临时变量抽取成函数\n提炼类 内联类 隐藏委托关系 移除中间人 替换算法 搬移特性 在不同的上下文之间搬移元素\n搬移函数 搬移函数的一个直接原因是,它频繁引用其他上下文中的元素,而对自身上下文中的元素却关心甚少. 为了做出决定,我们需要仔细检查函数当前上下文与目标上下文之间的区别,需要查看函数的调用都有谁,它自身又调用的哪些函数.\n搬移字段 可能是因为发现每当调用某个函数时,除了传入一个记录参数,还总是需要同时传入另一条记录的某个字段一起做为参数.\n搬移语句到函数 如果发现调用某个函数时,总有一些相同的代码也需要每次执行,那么就需要考虑将此段代码合并到函数里头.这样, 日后对这段代码的修改只需要修改一处地方,还能对所有调用者同时生效. 如果某些语句与一个函数放在一起更像一个整体,并且更有助于理解,那么就会将语句搬移到函数里去.\n搬移语句到调用者 以函数调用取代内联代码 抽取函数\n移动语句 让存在关联的语句一起出现,可以全代码更容易理解要判断一次语句移动是否安全,都意味着我得真正理解代码的工作原理,以及运算之间的组合方式等.\n拆分循环 让每个循环只做一件事儿,便于理解代码.\n以管道取代循环 移除死代码 版本控制系统出现之前注释还是有必要的,版本控制系统出现之后就可以直接删除无用代码了.\n重新组织数据 拆分变量 让每个变量只承担一个责任\n字段改名 以查询取代派生变量 将引用对象改为值对象 将值对象改为引用对象 简化条件逻辑 分解条件表达式 合并条件表达式 以卫语句取代嵌套条件表达式 卫语句告诉阅读者:这种情况不是本函数的核心逻辑所关心的,如果它真发生了,请做一些必要的整理工作,然后退出.\n以多态取代条件表达式 引入特例 引入断言 如果发现代码假设某个条件始终为真,就加入一个断言明确说明这种情况\n重构API ","permalink":"https://stoneepigraph.github.io/posts/%E9%87%8D%E6%9E%842/","title":"重构2"},{"content":"I won\u0026rsquo;t be a loser!!!\n","permalink":"https://stoneepigraph.github.io/abouts/about/","title":"About"},{"content":"","permalink":"https://stoneepigraph.github.io/abouts/contact/","title":"Contact"},{"content":" Emacs shortcutKeys 基本快捷键（Basic） C-x C-f 查找文件，即在缓冲区打开/新建一个文件 C-x C-s 保存文件 C-x C-w 使用其他文件名另存为文件 C-x C-v 关闭当前缓冲区文件并打开新文件 C-x i 在当前光标处插入文件 C-x b 新建/切换缓冲区 C-x C-b 显示缓冲区列表 C-x k 关闭当前缓冲区 C-z 挂起Emacs C-x C-c 关闭Emacs 光标移动基本快捷键（Basic Movement） C-f 后一个字符 C-b 前一个字符 C-p 上一行 C-n 下一行 M-f 后一个单词 M-b 前一个单词 C-a 行首 C-e 行尾 C-v 向下翻一页 M-v 向上翻一页 M-\u0026lt; 到文件开头 M-\u0026gt; 到文件末尾 编辑（Editint） M-n 重复执行最后一个命令N次 C-u 重复执行后一个命令4次 C-u 重复执行后一个命令N次 C-d 删除后一个字符 Del 删除前一个字符 M-Del 删除前一个单词 C-k 移除到行尾 C-Space 设置开头标记 C-@ 设置开头标记，用于C-Space被操作系统拦截的情况 C-w 移除标记区域的内容 M-w 复制标记区域的内容 C-y 粘贴复制或移除的区域/行 M-y 粘贴更早的内容 C-x C-x 交换光标和标记 C-t 交换两个字符的位置 C-x C-t 交换两行的位置 M-t 交换两个单词的位置 M-u 使从光标位置到单词结尾处的字母变成大写 M-l 使从光标位置到单词结尾处的字母变成小写 M-c 使光标位置开始的单词的首字母变成大写 C-x r l 命名剪切板列表 C-x r s name 插入命令剪切板 重要快捷键 C-g 停止当前运行/输入的命令 C-x u 撤消前一个命令 M-x revert-buffer RET 撤消上次存盘后所有改动 M-x recover-file RET 从自动存盘文件恢复 M-x recover-session RET 如果编辑了几个文件，用这个恢复 C-c C-e 导出 在线帮助（Online-help） C-h c 显示快捷键绑定的命令 C-h k 显示快捷键绑定的命令和它的作用 C-h l 显示最后100个键入的内容 C-h w 显示命令被绑定到哪些快捷键上 C-h f 显示函数的功能 C-h v 显示变量的含义和值 C-h b 显示当前缓冲区所有可用的快捷键 C-h t 打开Emacs教程 C-h i 打开info阅读器 C-h C-f 显示emacs FAQ C-h p 显示本机Elisp包的信息 搜索/替换（Search/Replace） C-s 向后搜索 C-r 向前搜索 C-g 回到搜索开始前的位置（如果你仍然在搜索模式中） M-% 询问并替换（query replace） Space或y 替换当前匹配 Del或n 不要替换当前匹配 . 仅仅替换当前匹配并退出替换 , 替换并暂停（按Space或y继续） ! 替换以下所有匹配 ^ 回到上一个匹配位置 RET或q 退出替换 M-x query-replace-regexp 使用下则表达式搜索并替换 窗口命令（Window Commands） C-x 2 水平分割窗口 C-x 3 垂直分割窗口 C-x o 切换至其他窗口 C-x 0 关闭窗口 C-x 1 关闭除了光标所在窗口外的所有窗口 C-x ^ 扩大窗口 M-x shrink-window 缩小窗口 M C-v 滚动其他窗口内容 C-x 4 f 在其他窗口中打开文件 C-x 4 0 关闭当前缓冲区和窗口 C-x 5 2 新建窗口 C-x 5 f 在新窗口中打开文件 C-x 5 o 切换至其他窗口 C-x 5 0 关闭当前窗口 书签命令（Bookmark commands） C-x r m 在光标当前位置创建书签 C-x r b 转到书签 M-x bookmark-rename 重命名书签 M-x bookmark-delete 删除书签 M-x bookmark-save 保存书签 C-x r l 列出书签清单 d 标记等待删除 Del 取消删除标记 x 删除被标记的书签 r 重命名书签 s 保存列表内所有书签 f 转到当前书签指向的位置 m 标记在多窗口中打开 v 显示被标记的书签（或者光标当前位置的书签） t 切换是否显示路径列表 w 显示当前文件路径 q 退出书签列表 M-x bookmark-write 将所有书签导出至指定文件 M-x bookmark-load 从指定文件导入书签 Shell M-x shell 打开shell模式 C-c C-c 类似Unix里的C-c C-d 删除光标后一个字符 C-c C-d 发送EOF C-c C-z 挂起程序 M-p 显示前一条命令 M-n 显示后一条命令 C-u M-! shell Command 插入shell命令结果到当前窗口 Directory Editor(dired) C-x d 打开dired C（大写c）复制 d 标记等待删除 D 立即删除 e或f 打开文件或目录 g 刷新当前目录 G改变文件所属组（chgrp） k 从屏幕上的列表里删除一行（不是真的删除） m 用*标记 n 光标移动到下一行 o 在另一个空格打开文件并移动光标 C-o 在另一个窗口打开文件但不移动光标 P 打印文件 q 退出dired Q 在标记的文件中替换 R 重命名文件 u 移除标记 v 显示文件内容 x 删除有D标记的文件 ^ 返回上一级目录 Z 压缩/解压缩文件 M-Del 移除标记（默认为所有类型的标记） ~ 标记备份文件（文件名有~的文件）等待删除 # 标记自动保存文件（文件名形如#name#）等待删除 */ 用*标记所有文件夹（用C-u */n移除标记） = 将当前文件和标记文件（使用C-@标记而不是dired的m标记）比较 M-= 将当前文件和它的备份比较 ! 对当前文件应用shell命令 M-} 移动光标至下一个用*或D标记的文件 M-{ 移动光标至上一个用*或D标记的文件 % d 使用正则表达式标记文件等待删除 % m 使用正帽表达式标记文件为* 新建文件夹 \u0026gt; 移动光标至后一个文件夹 \u0026lt; 移动光标至前一个文件夹 s 切换排序模式（按文件名/日期） M-x speedbar 打开一个独立的窗口显示目录 Telnet M-x telnet 打开telnet模式 C-d 删除后一个字符或发送EOF C-c C-c 停止正在运行的程序 C-c C-d 发送EOF C-c C-o 清除最后一个命令的输出 C-c C-z 挂起正在运行的命令 C-c C-u 移除前一行 M-p 显示前一条命令 Text 如下命令只能在Text模式里使用\nM-s 使当前行居中 M-S 使当前段落居中 M-x center-region 使被选中的区域居中 宏命令（Macro-commands） C-x ( 开始定义宏 C-x ) 结束定义宏 C-x e 运行最近定义的宏 M-n C-x e 运行最近定义的宏N次 M-x name-last-kbd-macro 给最近定义的宏命名（用来保存） M-x insert-kbd-macro 将已命名的宏保存到文件 M-x load-file 载入宏 编程（programming） M C-/ 自动缩进光标和标记间的区域 M-m 移动光标到行首第一个（非空格）字符 M-^ 将当前行接到上一行末尾处 M-; 添加缩进并格式化的注释 C, C++和Java模式 M-a 移动光标到声明的开始处 M-e 移动光标到声明的结尾处 M C-a 移动光标到函数的开始处 M C-e 移动光标到函数的结尾处 C-c RET 将光标移动到函数的开始处并标记到结尾处 C-c C-q 根据缩进风格缩进整个函数 C-c C-a 切换自动换行功能 C-c C-d 一次性删除光标后的一串空格(greedy delete) Org-mode ","permalink":"https://stoneepigraph.github.io/others/emacs%E4%B8%80%E4%BA%9B%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AE%BE%E7%BD%AE/","title":"Emacs-shortcutKeys"},{"content":" gitlab配置 wget \u0026ndash;content-disposition https://packages.gitlab.com/gitlab/gitlab-ce/packages/el/7/gitlab-ce-13.2.4-ce.0.el7.x86_64.rpm/download.rpm 安装信赖 yum install curl openssh-server postfix cronie yum -y install policycoreutils-python rpm -ivh gitlab-ce config gitlab vi /etc/gitlab/gitlab.rb external_url: nginx[\u0026rsquo;listen_port'] gitlab-ctl reconfigure gitlab-ctl restart 配置防火墙 配置gitlab组及用户 jenkins安装 安装Jenkins跳过插件安装 jenkins插件安装 tips 三台服务器,一台gitlab, 一台Jenkins, 一台测试服务器 ","permalink":"https://stoneepigraph.github.io/posts/jenkins%E5%85%A5%E9%97%A8/","title":"Jenkins入门"},{"content":" 入门 安装 Jar包安装 Maven导入 Gradle导入 从XML中构建SqlSessionFactory String resource = \u0026quot;org/mybatis/example/mybatis-config.xml\u0026quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); XML配置\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026quot;-//mybatis.org//DTD Config 3.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026quot;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;environments default=\u0026quot;development\u0026quot;\u0026gt; \u0026lt;environment id=\u0026quot;development\u0026quot;\u0026gt; \u0026lt;transactionManager type=\u0026quot;JDBC\u0026quot;/\u0026gt; \u0026lt;dataSource type=\u0026quot;POOLED\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;driver\u0026quot; value=\u0026quot;${driver}\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;url\u0026quot; value=\u0026quot;${url}\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;username\u0026quot; value=\u0026quot;${username}\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;${password}\u0026quot;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026quot;org/mybatis/example/BlogMapper.xml\u0026quot;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt; 不使用XML构建SqlSessionFactory DataSource dataSource = BlogDataSourceFactory.getBlogDataSource(); TransactionFactory transactionFactory = new JdbcTransactionFactory(); Environment environment = new Environment(\u0026quot;development\u0026quot;, transactionFactory, dataSource); Configuration configuration = new Configuration(environment); configuration.addMapper(BlogMapper.class); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration); 从SqlSessionFactory中获取SqlSession SqlSession session = SqlSessionFactory.openSession(); try { //Blog blog = (Blog) session.selectOne(\u0026quot;*.*.BlogMapper.seelctBlog\u0026quot;, 1); BlogMapper mapper = session.getMapper(BlogMapper.class); Blog blog = mapper.selectBlog(1); } finally { session.close(); } Mapper的配置 XML的配置\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026quot;-//mybatis.org//DTD Mapper 3.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026quot;\u0026gt; \u0026lt;mapper namespace=\u0026quot;org.mybatis.example.BlogMapper\u0026quot;\u0026gt; \u0026lt;select id=\u0026quot;selectBlog\u0026quot; resultType=\u0026quot;Blog\u0026quot;\u0026gt; select * from Blog where id = #{id} \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 注解配置\npackage org.mybatis.example; public interface BlogMapper { @Select(\u0026quot;SELECT * FROM blog WHERE id = #{id}\u0026quot;) Blog selectBlog(int id); } 对命名空间的作用 利用更长的完全限定名将不同的语句隔离开来。 使用代码变得更加整洁，也更方便管理。 作用域（Scope）和生命周期 SqlSessionFactoryBuilder\n一旦创建了SqlSessionFactory，就不再需要它了。\nSqlSessionFactory\n一旦创建就应该在应用的运行期间一直存在。\nSqlSession\n每个线程都应该有它自己的SqlSession实例。\nSqlSession的实例不是线程安全的，因此是不能被共享的。\nXML配置 属性 如果属性在不只一个地方进行了配置，那么 MyBatis 将按照下面的顺序来加载：\n在properties元素体内指定的属性首先被读取 然后根据properties元素的resource属性读取类路径下属性文件或根据url属性指定的路读取属性文件，并覆盖已读取的同名属性。 最后读取作为方法参数传递的属性，并覆盖已读取的同名属性。 设置 设置名 描述 有效值 默认值 cacheEnabled 全局地开启或关闭配置文件中的所有映射器已经配置的任何缓存。 true false true lazyLoadingEnabled 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。特定关联 true false false aggressiveLazyLoading 当开启时，任何方法的调用都会加载该对象的所有属性。否则，每个属性会按需加载 true false false multipleResultSetsEnabled 是否允许单一语句返回多结果集（需要驱动支持） true false true useColumnLabel 使用列标签代替列名。不同的驱动在这方面会有不同的表现。 true false true useGenerateKeys 允许JDBC支持自动生成主键，需要驱动支持。 true false false autoMappingBehavior 指定MyBatis应如何自动映射列字段或属性。NONE：取消自动映射，PARTIAL：只会自动映射没有定义嵌套结果集映射的结果集，FULL：会自动映射任意复杂的结果集（无论是否嵌套）。 NONE，PARTIAL,FULL PARTIAL autoMappingUnknownColumnBehavior 指定发现自动映射目标未知列（或者未知属性类型）的行为。NONE：不做任何反应，WARNING:输出提醒日志，FAILING：映射失败。 NONE，WARNING， FAILING NONE defaultExecutorType 配置默认的执行器。SIMPLE就是普通的执行器；REUSE：执行器会重用预处理语句；BATCH：执行器将重用语句并执行批量更新 SIMPLE，REUSE， BATCH SIMPLE defaultStatementTimeout 设置超时时间，它决定驱动等待数据库响应的秒数 任意正整数 未设置 defaultFetchSize 为驱动的结果集获取数量(fetchSize)设置一个提示值。 任意正整数 未设置 safeRowBoundsEnabled 允许在嵌套语句中使用分页（RowsBounds）如果允许使用则设置为false true false false safeResultHandlerEnabled 允许在嵌套语句中使用分页（ResultHandler）。如果允许使用则设置为 false。 true false True mapUnderscoreToCamelCase 是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。 true false false localCacheScope MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。 SESSION STATEMENT SESSION jdbcTypeForNull 当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型。 某些驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。 JdbcType 常量，常用值：NULL, VARCHAR 或 OTHER。 OTHER lazyLoadTriggerMethods 指定哪个对象的方法触发一次延迟加载。 用逗号分隔的方法列表。 equals,clone,hashCode,toString defaultScriptingLanguage 指定动态 SQL 生成的默认语言。 一个类型别名或完全限定类名。 org.apache.ibatis.scripting.xmltags.XMLLanguageDriver defaultEnumTypeHandler 指定 Enum 使用的默认 TypeHandler 。（新增于 3.4.5） 一个类型别名或完全限定类名。 org.apache.ibatis.type.EnumTypeHandler callSettersOnNulls 指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这在依赖于 Map.keySet() 或 null 值初始化的时候比较有用。注意基本类型（int、boolean 等）是不能设置成 null 的。 true false false returnInstanceForEmptyRow 当返回行的所有列都是空时，MyBatis默认返回 =null=。 当开启这个设置时，MyBatis会返回一个空实例。 请注意，它也适用于嵌套的结果集 （如集合或关联）。（新增于 3.4.2） true false false logPrefix 指定 MyBatis 增加到日志名称的前缀。 任何字符串 logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J LOG4J LOG4J2 JDK_LOGGING COMMONS_LOGGING STDOUT_LOGGING NO_LOGGING proxyFactory 指定 Mybatis 创建具有延迟加载能力的对象所用到的代理工具。 CGLIB JAVASSIST JAVASSIST vfsImpl 指定 VFS 的实现 自定义 VFS 的实现的类全限定名，以逗号分隔。 useActualParamName 允许使用方法签名中的名称作为语句参数名称。 为了使用该特性，你的项目必须采用 Java 8 编译，并且加上 -parameters 选项。（新增于 3.4.1） TRUE FALSE TRUE configurationFactory 指定一个提供 Configuration 实例的类。 这个被返回的 Configuration 实例用来加载被反序列化对象的延迟加载属性值。 这个类必须包含一个签名为=static Configuration getConfiguration()= 的方法。（新增于 3.2.3） 类型别名或者全类名 类型别名 typeAliases 类型别名是为Java类型设置一个短名字。它只和XML配置有关，存在的意义公在于用来减少类完全限定名的冗余。\n这是一些为常见的 Java 类型内建的相应的类型别名。它们都是不区分大小写的，注意对基本类型名称重复采取的特殊命名风格。\n别名 映射的类型 _byte byte _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal object Object map Map hashmap HashMap list List arraylist ArrayList collection Collection iterator Iterator 类型处理器（typeHandlers） 无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时，都会用类型处理器将获取的值以合适的方式转换成 Java 类型。下表描述了一些默认的类型处理器。\n提示 从 3.4.5 开始，MyBatis 默认支持 JSR-310（日期和时间 API） 。\n类型处理器 Java 类型 JDBC 类型 BooleanTypeHandler java.lang.Boolean, boolean 数据库兼容的 BOOLEAN ByteTypeHandler java.lang.Byte, byte 数据库兼容的 NUMERIC 或 BYTE ShortTypeHandler java.lang.Short, short 数据库兼容的 NUMERIC 或 SMALLINT IntegerTypeHandler java.lang.Integer, int 数据库兼容的 NUMERIC 或 INTEGER LongTypeHandler java.lang.Long, long 数据库兼容的 NUMERIC 或 BIGINT FloatTypeHandler java.lang.Float, float 数据库兼容的 NUMERIC 或 FLOAT DoubleTypeHandler java.lang.Double, double 数据库兼容的 NUMERIC 或 DOUBLE BigDecimalTypeHandler java.math.BigDecimal 数据库兼容的 NUMERIC 或 DECIMAL StringTypeHandler java.lang.String CHAR, VARCHAR ClobReaderTypeHandler java.io.Reader - ClobTypeHandler java.lang.String CLOB, LONGVARCHAR NStringTypeHandler java.lang.String NVARCHAR, NCHAR NClobTypeHandler java.lang.String NCLOB BlobInputStreamTypeHandler java.io.InputStream - ByteArrayTypeHandler byte[] 数据库兼容的字节流类型 BlobTypeHandler byte[] BLOB, LONGVARBINARY DateTypeHandler java.util.Date TIMESTAMP DateOnlyTypeHandler java.util.Date DATE TimeOnlyTypeHandler java.util.Date TIME SqlTimestampTypeHandler java.sql.Timestamp TIMESTAMP SqlDateTypeHandler java.sql.Date DATE SqlTimeTypeHandler java.sql.Time TIME ObjectTypeHandler Any OTHER 或未指定类型 EnumTypeHandler Enumeration Type VARCHAR 或任何兼容的字符串类型，用以存储枚举的名称（而不是索引值） EnumOrdinalTypeHandler Enumeration Type 任何兼容的 NUMERIC 或 DOUBLE 类型，存储枚举的序数值（而不是名称）。 SqlxmlTypeHandler java.lang.String SQLXML InstantTypeHandler java.time.Instant TIMESTAMP LocalDateTimeTypeHandler java.time.LocalDateTime TIMESTAMP LocalDateTypeHandler java.time.LocalDate DATE LocalTimeTypeHandler java.time.LocalTime TIME OffsetDateTimeTypeHandler java.time.OffsetDateTime TIMESTAMP OffsetTimeTypeHandler java.time.OffsetTime TIME ZonedDateTimeTypeHandler java.time.ZonedDateTime TIMESTAMP YearTypeHandler java.time.Year INTEGER MonthTypeHandler java.time.Month INTEGER YearMonthTypeHandler java.time.YearMonth VARCHAR 或 LONGVARCHAR JapaneseDateTypeHandler java.time.chrono.JapaneseDate DATE 你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。具体做法为：实现 org.apache.ibatis.type.TypeHandler 接口，或继承一个很便利的类 =org.apache.ibatis.type.BaseTypeHandler=，然后可以选择性地将它映射到一个 JDBC 类型。\n处理枚举类型 若想映射枚举类型 Enum=，则需要从 =EnumTypeHandler 或者 EnumOrdinalTypeHandler 中选一个来使用。\n比如说我们想存储取近似值时用到的舍入模式。默认情况下，MyBatis 会利用 EnumTypeHandler 来把 Enum 值转换成对应的名字。\n注意 EnumTypeHandler 在某种意义上来说是比较特别的，其他的处理器只针对某个特定的类，而它不同，它会处理任意继承了 Enum 的类。\n不过，我们可能不想存储名字，相反我们的 DBA 会坚持使用整形值代码。那也一样轻而易举： 在配置文件中把 EnumOrdinalTypeHandler 加到 typeHandlers 中即可， 这样每个 RoundingMode 将通过他们的序数值来映射成对应的整形数值。\n\u0026lt;!-- mybatis-config.xml --\u0026gt; \u0026lt;typeHandlers\u0026gt; \u0026lt;typeHandler handler=\u0026quot;org.apache.ibatis.type.EnumOrdinalTypeHandler\u0026quot; javaType=\u0026quot;java.math.RoundingMode\u0026quot;/\u0026gt; \u0026lt;/typeHandlers\u0026gt; 但是怎样能将同样的 Enum 既映射成字符串又映射成整形呢？\n自动映射器（auto-mapper）会自动地选用 EnumOrdinalTypeHandler 来处理，所以如果我们想用普通的 =EnumTypeHandler=，就必须要显式地为那些 SQL 语句设置要使用的类型处理器。\n（下一节才开始介绍映射器文件，如果你是首次阅读该文档，你可能需要先跳过这里，过会再来看。）\n\u0026lt;!DOCTYPE mapper PUBLIC \u0026quot;-//mybatis.org//DTD Mapper 3.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026quot;\u0026gt; \u0026lt;mapper namespace=\u0026quot;org.apache.ibatis.submitted.rounding.Mapper\u0026quot;\u0026gt; \u0026lt;resultMap type=\u0026quot;org.apache.ibatis.submitted.rounding.User\u0026quot; id=\u0026quot;usermap\u0026quot;\u0026gt; \u0026lt;id column=\u0026quot;id\u0026quot; property=\u0026quot;id\u0026quot;/\u0026gt; \u0026lt;result column=\u0026quot;name\u0026quot; property=\u0026quot;name\u0026quot;/\u0026gt; \u0026lt;result column=\u0026quot;funkyNumber\u0026quot; property=\u0026quot;funkyNumber\u0026quot;/\u0026gt; \u0026lt;result column=\u0026quot;roundingMode\u0026quot; property=\u0026quot;roundingMode\u0026quot;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026quot;getUser\u0026quot; resultMap=\u0026quot;usermap\u0026quot;\u0026gt; select * from users \u0026lt;/select\u0026gt; \u0026lt;insert id=\u0026quot;insert\u0026quot;\u0026gt; insert into users (id, name, funkyNumber, roundingMode) values ( #{id}, #{name}, #{funkyNumber}, #{roundingMode} ) \u0026lt;/insert\u0026gt; \u0026lt;resultMap type=\u0026quot;org.apache.ibatis.submitted.rounding.User\u0026quot; id=\u0026quot;usermap2\u0026quot;\u0026gt; \u0026lt;id column=\u0026quot;id\u0026quot; property=\u0026quot;id\u0026quot;/\u0026gt; \u0026lt;result column=\u0026quot;name\u0026quot; property=\u0026quot;name\u0026quot;/\u0026gt; \u0026lt;result column=\u0026quot;funkyNumber\u0026quot; property=\u0026quot;funkyNumber\u0026quot;/\u0026gt; \u0026lt;result column=\u0026quot;roundingMode\u0026quot; property=\u0026quot;roundingMode\u0026quot; typeHandler=\u0026quot;org.apache.ibatis.type.EnumTypeHandler\u0026quot;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026quot;getUser2\u0026quot; resultMap=\u0026quot;usermap2\u0026quot;\u0026gt; select * from users2 \u0026lt;/select\u0026gt; \u0026lt;insert id=\u0026quot;insert2\u0026quot;\u0026gt; insert into users2 (id, name, funkyNumber, roundingMode) values ( #{id}, #{name}, #{funkyNumber}, #{roundingMode, typeHandler=org.apache.ibatis.type.EnumTypeHandler} ) \u0026lt;/insert\u0026gt; \u0026lt;/mapper\u0026gt; 注意，这里的 select 语句强制使用 resultMap 来代替 =resultType=。\n对象工厂（objectFactory） MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过参数构造方法来实例化。如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现。比如：\n// ExampleObjectFactory.java public class ExampleObjectFactory extends DefaultObjectFactory { public Object create(Class type) { return super.create(type); } public Object create(Class type, List\u0026lt;Class\u0026gt; constructorArgTypes, List\u0026lt;Object\u0026gt; constructorArgs) { return super.create(type, constructorArgTypes, constructorArgs); } public void setProperties(Properties properties) { super.setProperties(properties); } public \u0026lt;T\u0026gt; boolean isCollection(Class\u0026lt;T\u0026gt; type) { return Collection.class.isAssignableFrom(type); }} \u0026lt;!-- mybatis-config.xml --\u0026gt; \u0026lt;objectFactory type=\u0026quot;org.mybatis.example.ExampleObjectFactory\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;someProperty\u0026quot; value=\u0026quot;100\u0026quot;/\u0026gt; \u0026lt;/objectFactory\u0026gt; ObjectFactory 接口很简单，它包含两个创建用的方法，一个是处理默认构造方法的，另外一个是处理带参数的构造方法的。最后，setProperties 方法可以被用来配置 ObjectFactory，在初始化你的 ObjectFactory 实例后， objectFactory 元素体中定义的属性会被传递给 setProperties 方法。\n插件（plugins） MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：\nExecutor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed) ParameterHandler (getParameterObject, setParameters) ResultSetHandler (handleResultSets, handleOutputParameters) StatementHandler (prepare, parameterize, batch, update, query) 这些类中方法的细节可以通过查看每个方法的签名来发现，或者直接查看 MyBatis 发行包中的源代码。如果你想做的不仅仅是监控方法的调用，那么你最好相当了解要重写的方法的行为。因为如果在试图修改或重写已有方法的行为的时候，你很可能在破坏 MyBatis 的核心模块。 这些都是更低层的类和方法，所以使用插件的时候要特别当心。\n环境配置（environments） MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中，现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；或者想在具有相同 Schema 的多个生产数据库中 使用相同的 SQL 映射。有许多类似的使用场景。\n不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。\n所以，如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例，依此类推，记起来很简单：\n每个数据库对应一个 SqlSessionFactory 实例 为了指定创建哪种环境，只要将它作为可选的参数传递给 SqlSessionFactoryBuilder 即可。可以接受环境配置的两个方法签名是：\nSqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, properties); 如果忽略了环境参数，那么默认环境将会被加载，如下所示：\nSqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, properties); 环境元素定义了如何配置环境。\n\u0026lt;environments default=\u0026quot;development\u0026quot;\u0026gt; \u0026lt;environment id=\u0026quot;development\u0026quot;\u0026gt; \u0026lt;transactionManager type=\u0026quot;JDBC\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;...\u0026quot; value=\u0026quot;...\u0026quot;/\u0026gt; \u0026lt;/transactionManager\u0026gt; \u0026lt;dataSource type=\u0026quot;POOLED\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;driver\u0026quot; value=\u0026quot;${driver}\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;url\u0026quot; value=\u0026quot;${url}\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;username\u0026quot; value=\u0026quot;${username}\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;${password}\u0026quot;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; 注意这里的关键点:\n默认使用的环境 ID（比如：default=\u0026ldquo;development\u0026rdquo;）。 每个 environment 元素定义的环境 ID（比如：id=\u0026ldquo;development\u0026rdquo;）。 事务管理器的配置（比如：type=\u0026ldquo;JDBC\u0026rdquo;）。 数据源的配置（比如：type=\u0026ldquo;POOLED\u0026rdquo;）。 默认的环境和环境 ID 是自解释的，因此一目了然。你可以对环境随意命名，但一定要保证默认的环境 ID 要匹配其中一个环境 ID。\n事务管理器（transactionManager）\n在 MyBatis 中有两种类型的事务管理器（也就是 type=”[JDBC|MANAGED]”）：\nJDBC \u0026ndash; 这个配置就是直接使用了 JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。\nMANAGED \u0026ndash; 这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。例如:\n\u0026lt;transactionManager type=\u0026quot;MANAGED\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;closeConnection\u0026quot; value=\u0026quot;false\u0026quot;/\u0026gt; \u0026lt;/transactionManager\u0026gt; *提示*如果你正在使用 Spring + MyBatis，则没有必要配置事务管理器， 因为 Spring 模块会使用自带的管理器来覆盖前面的配置。\n这两种事务管理器类型都不需要设置任何属性。它们其实是类型别名，换句话说，你可以使用 TransactionFactory 接口的实现类的完全限定名或类型别名代替它们。\npublic interface TransactionFactory { void setProperties(Properties props); Transaction newTransaction(Connection conn); Transaction newTransaction(DataSource dataSource, TransactionIsolationLevel level, boolean autoCommit); } 任何在 XML 中配置的属性在实例化之后将会被传递给 setProperties() 方法。你也需要创建一个 Transaction 接口的实现类，这个接口也很简单：\npublic interface Transaction { Connection getConnection() throws SQLException; void commit() throws SQLException; void rollback() throws SQLException; void close() throws SQLException; Integer getTimeout() throws SQLException; } 使用这两个接口，你可以完全自定义 MyBatis 对事务的处理。\n数据源（dataSource）\ndataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。\n许多 MyBatis 的应用程序会按示例中的例子来配置数据源。虽然这是可选的，但为了使用延迟加载，数据源是必须配置的。 有三种内建的数据源类型（也就是 type=”[UNPOOLED|POOLED|JNDI]”）：\nUNPOOLED\u0026ndash; 这个数据源的实现只是每次被请求时打开和关闭连接。虽然有点慢，但对于在数据库连接可用性方面没有太高要求的简单应用程序来说，是一个很好的选择。不同的数据库在性能方面的表现也是不一样的，对于某些数据库来说，使用连接池并不重要，这个配置就很适合这种情形。UNPOOLED 类型的数据源仅仅需要配置以下 5 种属性：\ndriver \u0026ndash; 这是 JDBC 驱动的 Java 类的完全限定名（并不是 JDBC 驱动中可能包含的数据源类）。 url \u0026ndash; 这是数据库的 JDBC URL 地址。 username \u0026ndash; 登录数据库的用户名。 password \u0026ndash; 登录数据库的密码。 defaultTransactionIsolationLevel \u0026ndash; 默认的连接事务隔离级别。 作为可选项，你也可以传递属性给数据库驱动。只需在属性名加上“driver.”前缀即可，例如：\ndriver.encoding=UTF8 这将通过 DriverManager.getConnection(url,driverProperties) 方法传递值为 UTF8 的 encoding 属性给数据库驱动。\nPOOLED\u0026ndash; 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。这是一种使得并发 Web 应用快速响应请求的流行处理方式。\n除了上述提到 UNPOOLED 下的属性外，还有更多属性用来配置 POOLED 的数据源：\npoolMaximumActiveConnections \u0026ndash; 在任意时间可以存在的活动（也就是正在使用）连接数量，默认值：10 poolMaximumIdleConnections \u0026ndash; 任意时间可能存在的空闲连接数。 poolMaximumCheckoutTime \u0026ndash; 在被强制返回之前，池中连接被检出（checked out）时间，默认值：20000 毫秒（即 20 秒） poolTimeToWait \u0026ndash; 这是一个底层设置，如果获取连接花费了相当长的时间，连接池会打印状态日志并重新尝试获取一个连接（避免在误配置的情况下一直安静的失败），默认值：20000 毫秒（即 20 秒）。 poolMaximumLocalBadConnectionTolerance \u0026ndash; 这是一个关于坏连接容忍度的底层设置，作用于每一个尝试从缓存池获取连接的线程。如果这个线程获取到的是一个坏的连接，那么这个数据源允许这个线程尝试重新获取一个新的连接，但是这个重新尝试的次数不应该超过 poolMaximumIdleConnections 与 poolMaximumLocalBadConnectionTolerance 之和。 默认值：3 （新增于 3.4.5） poolPingQuery \u0026ndash; 发送到数据库的侦测查询，用来检验连接是否正常工作并准备接受请求。默认是“NO PING QUERY SET”，这会导致多数数据库驱动失败时带有一个恰当的错误消息。 poolPingEnabled \u0026ndash; 是否启用侦测查询。若开启，需要设置 poolPingQuery 属性为一个可执行的 SQL 语句（最好是一个速度非常快的 SQL 语句），默认值：false。 poolPingConnectionsNotUsedFor \u0026ndash; 配置 poolPingQuery 的频率。可以被设置为和数据库连接超时时间一样，来避免不必要的侦测，默认值：0（即所有连接每一时刻都被侦测 \u0026mdash; 当然仅当 poolPingEnabled 为 true 时适用）。 JNDI \u0026ndash; 这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。这种数据源配置只需要两个属性：\ninitial_context \u0026ndash; 这个属性用来在 InitialContext 中寻找上下文（即，initialContext.lookup(initial_context)）。这是个可选属性，如果忽略，那么将会直接从 InitialContext 中寻找 data_source 属性。 data_source \u0026ndash; 这是引用数据源实例位置的上下文的路径。提供了 initial_context 配置时会在其返回的上下文中进行查找，没有提供时则直接在 InitialContext 中查找。 和其他数据源配置类似，可以通过添加前缀“env.”直接把属性传递给初始上下文。比如：\nenv.encoding=UTF8 这就会在初始上下文（InitialContext）实例化时往它的构造方法传递值为 UTF8 的 encoding 属性。\n你可以通过实现接口 org.apache.ibatis.datasource.DataSourceFactory 来使用第三方数据源：\npublic interface DataSourceFactory { void setProperties(Properties props); DataSource getDataSource(); } org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory 可被用作父类来构建新的数据源适配器，比如下面这段插入 C3P0 数据源所必需的代码：\nimport org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory; import com.mchange.v2.c3p0.ComboPooledDataSource; public class C3P0DataSourceFactory extends UnpooledDataSourceFactory { public C3P0DataSourceFactory() { this.dataSource = new ComboPooledDataSource(); } } 为了令其工作，记得为每个希望 MyBatis 调用的 setter 方法在配置文件中增加对应的属性。 下面是一个可以连接至 PostgreSQL 数据库的例子：\n\u0026lt;dataSource type=\u0026quot;org.myproject.C3P0DataSourceFactory\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;driver\u0026quot; value=\u0026quot;org.postgresql.Driver\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;url\u0026quot; value=\u0026quot;jdbc:postgresql:mydb\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;username\u0026quot; value=\u0026quot;postgres\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;root\u0026quot;/\u0026gt; \u0026lt;/dataSource\u0026gt; 数据库厂商标识（databaseIdProvider） MyBatis 可以根据不同的数据库厂商执行不同的语句，这种多厂商的支持是基于映射语句中的 databaseId 属性。 MyBatis 会加载不带 databaseId 属性和带有匹配当前数据库 databaseId 属性的所有语句。 如果同时找到带有 databaseId 和不带 databaseId 的相同语句，则后者会被舍弃。为支持多厂商特性只要像下面这样在 mybatis-config.xml 文件中加入 databaseIdProvider 即可：\n\u0026lt;databaseIdProvider type=\u0026quot;DB_VENDOR\u0026quot; /\u0026gt; DB_VENDOR 对应的 databaseIdProvider 实现会将 databaseId 设置为 =DatabaseMetaData#getDatabaseProductName()=返回的字符串。由于通常情况下这些字符串都非常长而且相同产品的不同版本会返回不同的值，所以你可能想通过设置属性别名来使其变短，如下：\n\u0026lt;databaseIdProvider type=\u0026quot;DB_VENDOR\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;SQL Server\u0026quot; value=\u0026quot;sqlserver\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;DB2\u0026quot; value=\u0026quot;db2\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;Oracle\u0026quot; value=\u0026quot;oracle\u0026quot; /\u0026gt; \u0026lt;/databaseIdProvider\u0026gt; 在提供了属性别名时，DB_VENDOR 的 databaseIdProvider 实现会将 databaseId 设置为第一个数据库产品名与属性中的名称相匹配的值，如果没有匹配的属性将会设置为 \u0026ldquo;null\u0026rdquo;。 在这个例子中，如果 getDatabaseProductName() 返回“Oracle (DataDirect)”，databaseId 将被设置为“oracle”。\n你可以通过实现接口 org.apache.ibatis.mapping.DatabaseIdProvider 并在 mybatis-config.xml 中注册来构建自己的 DatabaseIdProvider：\npublic interface DatabaseIdProvider { void setProperties(Properties p); String getDatabaseId(DataSource dataSource) throws SQLException; } 映射器（mappers） 既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要定义 SQL 映射语句了。 但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。 Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。 你可以使用相对于类路径的资源引用，或完全限定资源定位符（包括 file:/// 的 URL），或类名和包名等。例如：\n\u0026lt;!-- 使用相对于类路径的资源引用 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026quot;org/mybatis/builder/AuthorMapper.xml\u0026quot;/\u0026gt; \u0026lt;mapper resource=\u0026quot;org/mybatis/builder/BlogMapper.xml\u0026quot;/\u0026gt; \u0026lt;mapper resource=\u0026quot;org/mybatis/builder/PostMapper.xml\u0026quot;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;!-- 使用完全限定资源定位符（URL） --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper url=\u0026quot;file:///var/mappers/AuthorMapper.xml\u0026quot;/\u0026gt; \u0026lt;mapper url=\u0026quot;file:///var/mappers/BlogMapper.xml\u0026quot;/\u0026gt; \u0026lt;mapper url=\u0026quot;file:///var/mappers/PostMapper.xml\u0026quot;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;!-- 使用映射器接口实现类的完全限定类名 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper class=\u0026quot;org.mybatis.builder.AuthorMapper\u0026quot;/\u0026gt; \u0026lt;mapper class=\u0026quot;org.mybatis.builder.BlogMapper\u0026quot;/\u0026gt; \u0026lt;mapper class=\u0026quot;org.mybatis.builder.PostMapper\u0026quot;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;!-- 将包内的映射器接口实现全部注册为映射器 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;package name=\u0026quot;org.mybatis.builder\u0026quot;/\u0026gt; \u0026lt;/mappers\u0026gt; 这些配置会告诉了 MyBatis 去哪里找映射文件，剩下的细节就应该是每个 SQL 映射文件了，也就是接下来我们要讨论的。\nXML映射文件 ","permalink":"https://stoneepigraph.github.io/posts/mybatis%E5%9F%BA%E7%A1%80/","title":"MyBatis基础"},{"content":" Oracle一些基本查询 字符集相关 查询数据库字符集 select userenv('language') from dual; 实例相关 查询实例名 select instance_name from v$instance; 锁相关 查看被锁的表 select b.username,b.sid,b.serial#,logon_time from v$locked_object a,v$session b where a.session_id = b.sid order by b.logon_time; 杀死锁进程 alter system kill session 'id,serial*'; 查询表之前的状态 select * from tablename AS OF TIMESTAMP (SYSTIMESTAMP - INTERVAL '50' MINUTE) 用户 查询当前用户的缺省表空间 select username,default_tablespace from user_users; 查询当前用户的角色 select * from user_role_privs; 查看当前用户的系统权限和表级权限 select * from user_sys_privs; select * from user_tab_privs; 查询用户下的所有的表 select * from user_tables; 表 查看用户下所有的表 select * from user_tables; 查看名称包含log字符的表 select object_name,object_id from user_objects where instr(object_name,'LOG')\u0026gt;0; 查询表的创建时间 select object_name,created from user_objects where object_name=upper('\u0026amp;table_name'); 查询表的大小 select sum(bytes)/(1024*1024) as \u0026quot;size(M)\u0026quot; from user_segments where segment_name=upper('\u0026amp;table_name'); 查看放在Oracle的内存区里的表 select table_name,cache from user_tables where instr(cache,'Y')\u0026gt;0; 查询表的DDL语句 select dbms_metadata.get_ddl('TABLE',upper('tr_rpt_repair_record'),upper('bjvmmis')) from dual; 索引 查看索引个数和类别 select index_name,index_type,table_name from user_indexes order by table_name; 查看索引被索引的字段 select * from user_ind_columns where index_name=upper('\u0026amp;index_name'); 查看索引的大小 select sum(bytes)/(1024*1024) as \u0026quot;size(M)\u0026quot; from user_segments where segment_name=upper('\u0026amp;index_name'); 序列号 查看序列号，last_number是当前值\nselect * from user_sequences; 修改序列的值\nalter sequence STM_AUTH_USER increment by 50 nocache; select stm_auth_user.nextval from dual; alter sequence STM_AUTH_USER increment by 1 cache 20; select stm_auth_user.nextval from dual; 视图 查看视图的名称 select view_name from user_views; 查看创建视图的select语句 set long 2000; select text from user_views where view_name=upper('\u0026amp;view_name'); 同义词 查看同义词的名称 select * from user_synonyms; 约束条件 查看某表的约束条件 #+BEGIN_SRC sql select constraint_name, constraint_type,search_condition, r_constraint_name from user_constraints where table_name = upper(\u0026rsquo;\u0026amp;table_name\u0026rsquo;);\nselect c.constraint_name,c.constraint_type,cc.column_name from user_constraints c,user_cons_columns cc　where c.owner = upper(\u0026rsquo;\u0026amp;table_owner\u0026rsquo;) and c.table_name = upper(\u0026rsquo;\u0026amp;table_name\u0026rsquo;) and c.owner = cc.owner and c.constraint_name = cc.constraint_name　order by cc.position; #+END_SRC\n存储过程和函数 查看函数和过程的状态 select object_name,status from user_objects where object_type='FUNCTION'; select object_name,status from user_objects where object_type='PROCEDURE'; 查看函数和过程 的源代码 select text from all_source where owner=user and name=upper('\u0026amp;plsql_name'); 违反完整性约束,已找到子纪录解决办法 select a.constraint_name, a.table_name, b.constraint_name from user_constraints a, user_constraints b where a.constraint_type = 'R' and b.constraint_type = 'P' and a.r_constraint_name = b.constraint_name and a.constraint_name = 'reference_key_name'; Oracle的一些数据字典 常用数据字典 USER_ 记录用户对象的信息，如user_tables包含用户创建的所有表； user_views,user_constraints等; ALL_ 记录用户对象的信息及被授权访问的对象信息； DBA_ 记录数据库实例的所有对象的信息，如DBA_USERS包含数据库实例中 所有用户的信息，DBA的信息包含user和all的信息； V$ 当前实例的动态视图，包含系统管理和优化使用的视图； GV_ 分布环境下所有实例的动态视图，包含系统管理和优化使用的视图， 这里的GV表示 Global v$的意思； 基本数据字典 DBA_TABLES 所有用户的所有表的信息； DBA_TAB_COLUMNS 所有用户的表的列(字段)信息； DBA_VIEWS 所有用户的所有视图信息； DBA_SYNONYMS 所有用户同义词信息； DBA_SEQUENCES 所有用户序列信息； DBA_CONSTRAINTS 所有用户的表约束信息； DBA_INDEXES 所有用户索引的简要信息； DBA_IND_COLUMNS 所有用户索引的列信息； DBA_TRIGGERS 所有用户触发器信息 ； DBA_SOURCE所有用户存储过程源代码信息； DBA_PROCEDUS 所有用户存储过程； DBA_SEGMENTS 所有用户段（表，索引，Cluster）使用空间信息； DBA_EXTENTS 所有用户段的扩展段信息； DBA_OBJECTS 所有用户对象的基本信息（包括素引，表，视图，序列等）； CAT 当前用户可以访问的所有的基表 ； TAB 当前用户创建的所有基表，视图，同义词等； DICT 构成数据字典的所有表的信息；\n与数据库组件相关的数据字典 数据库 \u0026lt;![CDATA[ V$DATABASE 同义词 V_$DATABASE,记录系统的运行情况；]]\u0026gt; 表空间 DBA_TABLESPACES 记录系统表空间的基本信息； DBA_DATA_FILES 记录系统数据文件及表空间的基本信息； DBA_FREE_SPACE 记录系统表空间的剩余空间的信息； 控制文件 \u0026lt;![CDATA[V$CONTROLFILE 记录系统控制文件的路径信息；]]\u0026gt; \u0026lt;![CDATA[V$PARAMETER 记录系统各参数的基本信息；]]\u0026gt; \u0026lt;![CDATA[v$CONTROLFILE_RECORD_SECTION 记录系统控制运行的基本信息；]]\u0026gt; 数据文件： DBA_DATA_FILES 记录系统数据文件及表空间的基本信息； \u0026lt;![CDATA[v$DATAFILE 记录来自控制文件的数据文件信息；]]\u0026gt; \u0026lt;![CDATA[v$FILESTAT 记录数据文件读写的基本信息 ；]]\u0026gt; vga show sga; \u0026lt;![CDATA[SELECT * FROM V$SGASTAT;]]\u0026gt; 动态性能视图 系统统计信息 \u0026lt;![CDATA[ select * from sysstat]]\u0026gt;\\ 用户会话信息 V$sesstat 显示内存使用统计信息 V$pgastat SQL游标所用工作区的信息 V$sql_workarea 当前系统工作区的信息 V$ sql_workarea_active 查询到每个Oracle进程的PGA分配的内存和已使用的内存情况 select pid,pga_used_mem,pga_alloc_mem,pga_max_mem from v$process; -- 其中PGA_used_mem表示已使用的，pag_alloc_mem表示已分配的，pga_max_men表示PGA的最大值。 查看后台进程： SELECT * FROM v$bgprocess WHERE paddr \u0026lt;\u0026gt; '00'; 查看 所有的表空间 select tablespace_name from dba_data_files order by tablespace_name; 查看表空间的名字及大小: select t.tablespace_name, round(sum(bytes/(1024*1024)),0) ts_size from dba_tablespaces t, dba_data_files d where t.tablespace_name = d.tablespace_name group by t.tablespace_name; 创建表空间 CREATE TABLESPACE tablespacename DATAFILE 'filename' [SIZE integer [K|M]] [AUTOEXTEND [OFF|ON]]; 创建有多个数据文件的表空间 create tablespace SALES datafile 'd:/sales/SALES_DATA01.dbf' size 10m autoextend on next 10m maxsize 100m, 'd:/sales/SALES_DATA02.dbf' size 10m autoextend on next 10m maxsize unlimited,'d:/sales/SALES_DATA03.dbf' size 10m; 查看表空间大小 SELECT TABLESPACE_NAME,SUM(BYTES)/1024/1024 MB FROM DBA_FREE_SPACE GROUP BY TABLESPACE_NAME; 查看表空间中数据文件存放的路径： SELECT TABLESPACE_NAME, BYTES/1024/1024 FILE_SIZE_MB, FILE_NAME FROM DBA_DATA_FILES; 删除表空间 drop tablespace worktbs including contents; 为表空间增加数据文件 alter tablespace sales add datafile 'd:/oracle/oradata/test/testtablespace/ sales_data04.dbf' size 10m autoextend on next 10m maxsize 100m, 'c:/oracle/oradata/test/testtablespace/sales_data05.dbf' size 10m autoextend on next 10m maxsize unlimited, 'c:/oracle/oradata/test/testtablespace/sales_data06.dbf' size 10m; 修改数据文件的大小 alter database datafile 'c:/oracle/oradata/test/testtablespace/SALES_DATA04.dbf' resize 30m; 关闭数据文件的自动扩展属性 alter database datafile 'c:/SALES_DATA04.dbf' , 'c:/SALES_DATA05.dbf', 'c:/SALES_DATA06.dbf' autoextend off; 打开表空间数据文件的自动扩展属性 alter database datafile 'c:/SALES_DATA04.dbf' , 'c:/SALES_DATA05.dbf', 'c:/SALES_DATA06.dbf' autoextend on; 修改表空间属性(离线) alter tablespace sales offline; 修改表空间属性（在线） alter tablespace sales online; 修改表空间属性(只读) alter tablespace sales read only; -- 如下系统表空间不得设置为 offline 或者 read only -- system ， temp，undo ，undotbs 修改表空间属性（读写） alter tablepsace sales read write; 创建用户，指定默认表空间，磁盘配额 create user rose identified by rose default o tablespace sales quota 10m on sales; 给用户授权 grant connect,resource,dba to rose; 删除表空间同时删除文件 drop tablespace sales including contents and datafiles; 查看当前用户每个表空间占有的空间大小 select segment_name,sum(bytes)/1024/1024 from user_extents group by segment_name 查看每个表空间占有用空间的大小 select tablespace_name,sum(bytes)/1024/1024 from dba_segments group by tablespace_name ","permalink":"https://stoneepigraph.github.io/posts/oracle%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2/","title":"Oracle一些简单查询"},{"content":" 安装及配置 安装 下载postgresql https://www.postgresql.org/download/ 安装 按照官网的说明安装 su - postgres -c \u0026quot;pg_ctl -D /var/lib/postgres/data -l /var/log/postgresql/postgresql.log start\u0026quot; 切换到postgres用户修改postgres密码 su - postres alter user postgres with password 'passwod' 备份及恢复 备份 pg_dump dbname \u0026gt; dbname.bak # 备份单个数据库 pg_dumpall \u0026gt; pd_backup.bak # 备份所有的数据库 备份格式有三种， 可以使用-F指定\n*.bak 压缩二进制文件 *.sql 明文转储 *.tar tarball t 恢复 psql dbname \u0026lt; dbanme.bak pg_restore -U postgres -d dbname /tmp/back_filename.tar 注意 使用psql恢复数据库需要先创建一个空的对应名称的数据库\n序列 查询序列的值 select nextval('sys_menu_menu_id_seq'); 修改序列的值从某个新值开始 SELECT setval('bi_his_corp_policy_part_id_seq', (SELECT MAX(id) FROM bi_his_corp_policy)); 修改序列 alter sequence sys_menu_menu_id_seq increment by 1 restart with 2354; 基础 函数 创建函数 exp insert create or replace function fun_date2utc(p_date timestamp) returns bigint language pluxsql as $$ declare utc integer; begin utc = 86400 * (p_date - to_date('1970/01/01 00:00:00', 'YYYY/MM/DD HH24:MI:SS')) - 8*3600; return utc; end; $$; create trigger trg_insert_local_vehicle2_dynamic before insert on bi_inf_vehicle_local for each row execute procedure check_insert_dynamic_vehicle(); exp delete create function check_delete_dynamic_vehicle() returns trigger language pluxsql as $$ begin delete from vd_sta_vehicle_local where vehicle_id = old.id; return old; end; $$; alter function check_delete_dynamic_vehicle() owner to uxdb; create trigger trg_delete_local_vehicle2_dynamic before delete on bi_inf_vehicle_local for each row execute procedure check_delete_dynamic_vehicle(); 一些函数 生成序列 generate_series() 生成数字序列 select generate_series(1, 10) 生成时间序列 select generate_series(now()::timestamp, now()::timestamp + interval '100 day', interval '1 day') 索引 postgresql使用什么数据结构保存索引的: B-tree 分区表 创建分区表 创建分区表需要在表结构结束添加 partition by partition_type(partition_key);\npartition_type: 类型， 可以有range和list partition_key: 分区字段，分区字段必须是主键或者是主键的一部分。 create table sa_sts_vehicle_day ( vehicle_id bigint not null, sts_time timestamp not null, days_online integer default 0 not null, constraint sa_sts_vehicle_day_new_pkey primary key (vehicle_id, sts_time) ) partition by RANGE (sts_time); 添加新的分区 按时间生成分区表SQL select 'create table vd_his_alarm_attachment_' || to_char(gen_date, 'yyyyMMdd') || ' partition of vd_his_alarm_attachment_part for values from (''' || to_char(gen_date, 'yyyy-MM-dd HH24:mi:ss') || ''') to (''' || to_char(gen_date + interval '1 day', 'yyyy-MM-dd HH24:mi:ss') || ''');' from ( select generate_series('2022-09-28'::date, '2023-12-31'::date, interval '1 day') gen_date) s 添加新分区 create table sa_sts_vehicle_day_20231129 partition of sa_sts_vehicle_day for values from ('2023-11-29 00:00:00') to ('2023-11-30 00:00:00'); 查询 慢SQL -- 查看数据库执行的语句 select pid, query_stay 执行时长s, REPLACE ( query, chr( 10 ), ' ' ) AS sql语句, datname 数据库, usename 用户, client_addr IP, application_name 应用, STATE 状态, backend_start 后台开始时间, xact_start 激活时间, xact_stay 激活时长s, query_start 开始执行时间 FROM ( SELECT pgsa.pid AS pid, pgsa.datname AS datname, pgsa.usename AS usename, pgsa.client_addr client_addr, pgsa.application_name AS application_name, pgsa.STATE AS STATE, pgsa.backend_start AS backend_start, pgsa.xact_start AS xact_start, EXTRACT ( epoch FROM ( now( ) - pgsa.xact_start ) ) AS xact_stay, pgsa.query_start AS query_start, EXTRACT ( epoch FROM ( now( ) - pgsa.query_start ) ) AS query_stay, pgsa.query AS query FROM pg_stat_activity AS pgsa WHERE 1=1 AND pgsa.STATE != 'idle' AND pgsa.STATE != 'idle in transaction' AND pgsa.STATE != 'idle in transaction (aborted)' --and (pgsa.query like 'drop %' or pgsa.query like 'DROP %') ) idleconnections ORDER BY query_stay DESC; -- 删除进程 SELECT pg_terminate_backend(7532); 查看锁 select w1.pid as 等待进程, w1.mode as 等待锁模式, w2.usename as 等待用户, w2.query as 等待会话, b1.pid as 锁的进程, b1.mode 锁的锁模式, b2.usename as 锁的用户, b2.query as 锁的会话, b2.application_name 锁的应用, b2.client_addr 锁的IP地址, b2.query_start 锁的语句执行时间 from pg_locks w1 join pg_stat_activity w2 on w1.pid=w2.pid join pg_locks b1 on w1.transactionid=b1.transactionid and w1.pid!=b1.pid join pg_stat_activity b2 on b1.pid=b2.pid where not w1.granted; 查询表结构 select a.attnum AS \u0026quot;序号\u0026quot;, c.relname AS \u0026quot;表名\u0026quot;, cast(obj_description(relfilenode,'pg_class') as varchar) AS \u0026quot;表名描述\u0026quot;, a.attname AS \u0026quot;列名\u0026quot;, concat_ws('',t.typname,SUBSTRING(format_type(a.atttypid,a.atttypmod) from '\\(.*\\)')) as \u0026quot;字段类型\u0026quot;, d.description AS \u0026quot;备注\u0026quot;, a.attnotnull, a.atthasdef from pg_class c, pg_attribute a , pg_type t, pg_description d where c.relname = 'bi_inf_vehicle_local' and a.attnum\u0026gt;0 and a.attrelid = c.oid and a.atttypid = t.oid and d.objoid=a.attrelid and d.objsubid=a.attnum ORDER BY c.relname DESC,a.attnum ASC ; ","permalink":"https://stoneepigraph.github.io/posts/postgresql%E7%AC%94%E8%AE%B0/","title":"postgresql-note"},{"content":" 网络爬虫简介 识别网站所用技术\u0026mdash;\u0026mdash;builtwith模块 pip install builtwith\nimport builtwith builtwith.parse(\u0026quot;sample.website.com\u0026quot;) 寻找网站的所有者 pip install python-whois\nimport whois print(whois.whois('sample.website.com')) 编写第一个网络爬虫 3种爬取网站的常见方法： - 爬取网站地图 - 遍历每个网页的数据库ID - 跟踪网页链接\n下载网页 import urllib2 def download(url): print('Downloading。。。', url) try: html = urllib2.urlopen(url).read() except urllib2.URLError e: print(\u0026quot;Download error:\u0026quot;, e.reason) html = None return html 下载内容时可能会遇到一些无法控制的错误，如果请求的页面可能不存在。因此需要捕获异常。\n而有些时间的错误可能是临时性的，比如503，对于此类错误，我们可以尝试重新下载。重试N次后还失败，再返回错误。\n因为Python默认的请求头通常会被网站封禁，所以我们需要添加请求代理。\ndef download(url, user_agent=\u0026quot;wswp\u0026quot;, num_retries=5): print(\u0026quot;download...: ', url) headers = {'User-agent': user_agent} request = urllibs.Request(url, headers=hearders) try: html - urllib2.urlopen(request).read() except urllib2.URLError as e: print('Download error: ', e.reason) html = None return html * 网站地图爬虫\n:CUSTOM_ID: 网站地图爬虫\n数据抓取 下载缓存 并发下载 动态内容 表单交互 验证码处理 Scrapy 总结 ","permalink":"https://stoneepigraph.github.io/posts/%E7%94%A8python%E5%86%99%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/","title":"用Python写网络爬虫"}]