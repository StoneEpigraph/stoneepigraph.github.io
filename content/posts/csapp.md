+++
title = "csapp"
author = ["WhatsUpeng!!!"]
date = 2024-08-20
tags = ["book", "csapp", "深入理解计算机系统"]
categories = ["book"]
draft = false
+++

## 计算机系统漫游 {#计算机系统漫游}


### 信息就是位+上下文 {#信息就是位-plus-上下文}


### 程序被其他程序翻译成不同的格式 {#程序被其他程序翻译成不同的格式}

hello程序的生命周期是从一个高级C语言开始的，因为这种形式能够被人读懂。然而，为了在系统上运行hello.c程序，每条C诗句都必须被其他程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为可执行目标程序的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为可执行目标文件。


### 了解编译系统如何工作是大有益处的 {#了解编译系统如何工作是大有益处的}


#### 优化程序性能 {#优化程序性能}


#### 理解链接时出现的错误 {#理解链接时出现的错误}


#### 避免安全漏洞 {#避免安全漏洞}


### 处理器读并解释储存在中的指令 {#处理器读并解释储存在中的指令}


#### 系统的硬件组成 {#系统的硬件组成}

<!--list-separator-->

-  总线

<!--list-separator-->

-  I/O设备

<!--list-separator-->

-  主存

<!--list-separator-->

-  处理器

    <!--list-separator-->

    -  加载

    <!--list-separator-->

    -  存储

    <!--list-separator-->

    -  操作

    <!--list-separator-->

    -  跳转


### 高速缓存至关重要 {#高速缓存至关重要}


### 存储设备形成层次结构 {#存储设备形成层次结构}

在处理器和一个较大较慢的设备（例如主存）之间插入一个更小更快的存储设备（例如高速红艳艳）的想法已经成为一个普通的观念。实际上，每个计算机系统中的存储设备都被组织成了一个存储器层次结构，在这个层次结构中， 从上至下，设备的访问速度起来越慢，容量越来越大，并且每字节的造价也越来越便宜。


### 操作系统管理硬件 {#操作系统管理硬件}

所有应用程序对硬件的操作深度都必须通过操作系统。


#### 操作系统有两个基本功能 {#操作系统有两个基本功能}

1.  防止硬件被失控的应用程序滥用
2.  向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。


#### 操作系统通过几个基本的抽象概念来实现这两个功能 {#操作系统通过几个基本的抽象概念来实现这两个功能}

1.  进程
    进程则是对处理器、主存和I/O设备的抽象表示。
2.  虚拟内存
    虚拟内存是对主存和磁盘I/O设备的抽象表示
3.  文件
    文件是对I/O设备的抽象表示

<!--list-separator-->

-  进程

<!--list-separator-->

-  线程

<!--list-separator-->

-  虚拟内存

    虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。
    在Linux中，地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都是一样。地址空间的底部区域存放用户进程定义的代码和数据。注意，地址是从下往上增大的。
    从下往上依次是：

    1.  程序代码和数据。
    2.  堆
    3.  共享库
    4.  栈
    5.  内核虚拟内存

<!--list-separator-->

-  文件

    文件就是字节序列，每个I/O设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件。


### 系统之间利用网络通信 {#系统之间利用网络通信}


## 程序结构和执行 {#程序结构和执行}


### 信息的表示和处理 {#信息的表示和处理}


#### 信息存储 {#信息存储}

<!--list-separator-->

-  十六进制表示法

<!--list-separator-->

-  字数据大小

<!--list-separator-->

-  寻址和字节顺序

    大端法
    小端法

<!--list-separator-->

-  表示字符串

    C语言中字符串被编码为一个以null(其值为0)字符结尾的字符数组。每个字符都同某个标准编码来表示，最常见的是ASCII字符码。

<!--list-separator-->

-  表示代码

<!--list-separator-->

-  布尔代数简介

    二进制值是计算机编码、存储和操作信息的核心，所以围绕数值0和1的研究已经深化出了丰富的数学知识体系。被称作布尔代数。

<!--list-separator-->

-  C语言中的位级运算

    1.  |
    2.  &amp;
    3.  ^

<!--list-separator-->

-  C语言中的逻辑运算

    <!--list-separator-->

    -  类型

        1.  ||
        2.  &amp;&amp;
        3.  !

    <!--list-separator-->

    -  与位级运算的区别

        1.  逻辑运算认为所有非零的参数都表示TRUE，而参数0表示FALSE
        2.  逻辑运算符&amp;&amp;和||与它们对应的位级运算&amp;和|之间第三个重要的区别是，如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。

<!--list-separator-->

-  C语言中的移位运算

    <!--list-separator-->

    -  类型

        1.  &lt;&lt;
        2.  &gt;&gt;
        3.  &gt;&gt;&gt;


#### 整数表示 {#整数表示}

<!--list-separator-->

-  一些术语

    | 符号   | 类型 | 含义     |
    |------|----|--------|
    | B2T_w  | 函数 | 二进制转补码 |
    | B2U_w  | 函数 | 二进制转无符号数 |
    | U2B_w  | 函数 | 无符号数转二进制 |
    | U2T_w  | 函数 | 无符号转补码 |
    | T2B_w  | 函数 | 补码转二进制 |
    | T2U_w  | 函数 | 补码转无符号数 |
    | TMin_w | 常数 | 最小补码值 |
    | TMax_w | 常数 | 最大补码值 |
    | UMax_w | 常数 | 最大无符号数 |
    | +^t_w  | 操作 | 补码加法 |
    | +^u_w  | 操作 | 无符号数加法 |
    | \*^t_w | 操作 | 补码乘法 |
    | \*^u_w | 操作 | 无符号乘法 |
    | -^t_w  | 操作 | 补码取反 |
    | -^u_w  | 操作 | 无符号取反 |

<!--list-separator-->

-  整数数据类型

    C语言支持多种整形数据类型——表示有限范围的整数。每种类型都能用关键字来指定大小，这些关键字包括char、short、long，同时还可以指示被表示的数字是非负数(声明为unsigned),歌者可能是负数（默认）。

<!--list-separator-->

-  无符号数的编码

<!--list-separator-->

-  补码编码

    最常见的有符号数的计算机表示方式誻补码形式。在这个定义中，将字的最高有效位解释为负权。
    补码的范围是不对称的： |TMin| = |TMax| + 1, 也就是说，TMin没有与之对应的正数。
    最大的无符号数值刚好比补码的最大值的两倍大一点： UMax = 2TMax + 1。
    C语言标准并没有要求要用补码形式来表示有符号整数，但是几乎所有的机器都是这么做的。
    C库中的文件 &lt;limits.h&gt;定义了一组常量，来限定编译器运行的这台机器的不同整形数据类型的取值范围。
    ISOC99标准在文件stdint.h中引入了这个整数类型类。这个文件定义了一组数据类型，它们的声明形式如intN_t和uintN_t,对应不同的N值指定N位有称号和无符号整数。
    关于整数数据类型的范围和表示，Java标准是非常明确的。它要求采用补码表示。在Java中，单字节数据类型称为byte,而不是char。这些非常具体的要求都是为了保证无论在什么机器上运行，Java程序都能表现地完全一样。

<!--list-separator-->

-  有符号数和无符号数之间的转换

    C语言允许在各种不同的数字数据类型之间做强制类型转换。
    对于大多数C语言的实现，处理同样字长的有符号数和无符号数之间的转换的一般规则是：数值可能会改变，但是位模式不变。

<!--list-separator-->

-  C语言中的有符号数与无符号数

    C语言支持所有整形数据类型的有符号和无符号运算。尽管C语言标准i同有指定有符号数要采用某种表示，但是几乎所有的机器都使用补码。
    C语言允许无符号数和有符号数之间的转换。虽然C标准没有精确规定应如何进行这种转换，但大多数系统遵循的原则是底层的位表示保持不变。
    另外，当一种类型的表达式被赋值给另外一种类型的变量时，转换是隐式发生的。

<!--list-separator-->

-  扩展一个数字的位表示

<!--list-separator-->

-  截断数字

<!--list-separator-->

-  关于有符号数与无符号数的建议


#### 整数运算 {#整数运算}

<!--list-separator-->

-  无符号加法

    当执行C程序时， 不会将溢出作为错误而发信号。不过有的时候，我们可能希望判定是否发生的溢出。

<!--list-separator-->

-  补码加法

<!--list-separator-->

-  补码的非

    对于w位的补码加法来说， TMin是自己的加法的逆，而对其他任何数值x都有-x作为基加法的逆。

<!--list-separator-->

-  无符号乘法

    C语言中的无符号乘法被定义为产生w位的值，就是2w位的整数税种的低w从头再来表示的值。

<!--list-separator-->

-  补码乘法

<!--list-separator-->

-  乘以常数

    由于整数乘法比移位和加法的代价要大得多，许多C语言编译器试图以移位、加法和减法的组和来消除很多整数乘以常数的情况。

<!--list-separator-->

-  除以2的幂

    除以2的幂也可以用移位运算来实现，只不过我们用的是右移，而不是左移。

<!--list-separator-->

-  关于整数运算的最后思考


#### 浮点数 {#浮点数}

浮点数表示对形如V=x\*2^y的有理数进行编码。它对执行涉及非常大的数字、非常接近于0的数字，以及更普遍地作为实数运算的近似值的计算，是很有用的。

<!--list-separator-->

-  二进制小数

    数字权的与十进制的小数点符号相关，这意味着小数点左边的数字的权是10的正幂，得到整数值，而小数点右边的数字的权是10的负幂，得到小数值。
    假定我们公考虑有限长度的编码，那么十进制表示法不能准确地表达像三分之一这样的数。类似，小数的二进制表示法只能表示那些能够被写成x\*2^y的数。其他的值只能够被近似的表示。

<!--list-separator-->

-  IEEE浮点表示

    IEEE浮点标准用V=(-1)^s\*M\*2^E的形式来表示一个数

    1.  符号sign: s决定这个ovtj是负数还是正数
    2.  尾数significand M是一个二进制小数
    3.  阶码 exponent E的作用是对浮点数加权，这个权重是2的E次幂（可能是负数）。

    <!--list-separator-->

    -  表示的数值类型

        1.  规格化的值
            这是最普遍的情况，当exp的位模式既不全为0,也不全为1
        2.  非规格化的值
            当阶码哉为全0时
        3.  特殊值
            当阶码全为1的时候。当小数域全为0时，得到的值表示无穷，当s=0时是正无穷，当s=1时为负无穷。

<!--list-separator-->

-  数字示例

<!--list-separator-->

-  舍入

    因为表示方法限制了浮点数的范围和精度，所以浮点运算只能挖地表示实数运算。因此，对于值x,我们一般想用一种系统的方法，能够找到“最接近的”匹配值x'，它可以用期望的浮点形式表示出来。这就是舍入运算的任务。

<!--list-separator-->

-  浮点运算

    浮点加法不具有结合性。
    激战加法满足了单调性。

<!--list-separator-->

-  C语言中的浮点数

    所有的C语言版本提供了两种不同的浮点数据类型:float和double。

    <!--list-separator-->

    -  当int, float和double格式之间进行强制类型转换时，程序改变数值和位模式的原则如下（假设int是32位的）

        -   从int转换成float,数字不会溢出，但是可能被舍入。
        -   从int或float转换成double,因为double有更大的范围，也有更高的精度，所以能够保留精确的数值。
        -   从double转换成float,因为范围要小一些，所以值可能溢出成正无穷或负无穷。另外，由于精确度较小，它还可能被舍入。
        -   从float或者double转换成int,值将会向零舍入。例如1.99将被转换成1,而-1.99将被转换成-1。


### 程序的机器级表示 {#程序的机器级表示}


#### 程序编码 {#程序编码}

<!--list-separator-->

-  机器级代码

    汇编代码表示非常接近于机器代码。与机器代码的二进格式相比，汇编代码的主要特点是它用可读性更好的文本格式表示。
    一条机器指令只执行一个基本的操作。

<!--list-separator-->

-  示例

    1.  查看C语言编译器产生的汇编代码
        ```shell
        gcc -Og -S filename.c
        ```
    2.  汇编代码
        ```shell
        gcc -Og -c filename.c
        ```
    3.  生成可执行文件
        ```shell
        gcc -Og -p prog file1.c file2.c
        ```
    4.  反汇编
        ```shell
        objdump -d program.o
        ```

<!--list-separator-->

-  关于格式的注解

    gcc产生的汇编代码中所有以.形状的行都是指导汇编器和链接器工作的伪指令。我们通常可以忽略这些行。


#### 数据格式 {#数据格式}

由于是从16位体系结构扩展成32位的，Intel用术语“字（word）”表示16位数据类型。因此，称32位数为“双字（double word）”， 64位数为“四字（quad word）”

| C声明  | Intel数据类型 | 汇编代码后缀 | 大小（字节 |
|------|-----------|--------|-------|
| char   | 字节      | b      | 1     |
| short  | 字        | w      | 2     |
| int    | 双字      | l      | 4     |
| long   | 四字      | q      | 8     |
| char\* | 四字      | q      | 8     |
| float  | 单精度    | s      | 4     |
| double | 双精度    | l      | 8     |

大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。
例如：数据传送指令有四个变种：movb, movw, movl, movq


#### 访问信息 {#访问信息}

一个x86-64的CPU包含一组16个存储64位值的通用目的寄存器。这些寄存器用来存储整数数据和指针。
整数寄存器。所有16个寄存器的低位部分都可以作为字节、字（16位）、双字（32位）和四字（64位）数字来访问。

| 63   | 31    | 15    | 7     | 0      |
|------|-------|-------|-------|--------|
| %rax | %eax  | %ax   | %al   | 返回值 |
| %rbx | %ebx  | %bx   | %bl   | 被调用者保存 |
| %rcx | %ecx  | %cx   | %cl   | 第4个参数 |
| %rdx | %edx  | %dx   | %dl   | 第3个参数 |
| %rsi | %esi  | %si   | %sil  | 第2个参数 |
| %rdi | %edi  | %di   | %dil  | 第1个参数 |
| %rbp | %ebp  | %bp   | %bpl  | 被调用者保存 |
| %rsp | %esp  | %sp   | %spl  | 栈指针 |
| %r8  | %r8d  | %r8w  | %r8b  | 第5个参数 |
| %r9  | %r9d  | %r9w  | %r9b  | 第6个参数 |
| %r10 | %r10d | %r10w | %r10b | 调用者保存 |
| %r11 | %r11d | %r11w | %r11b | 调用者保存 |
| %r12 | %r12d | %r12w | %r12b | 被调用者保存 |
| %r13 | %r13d | %r13w | %r13b | 被调用者保存 |
| %r14 | %r14d | %r14w | %r14b | 被调用者保存 |
| %r15 | %r15d | %r15w | %r15b | 被调用者保存 |

-   对于生成小于8字节结果的指令，寄存器中剩下的字节会怎样，对此有两条规则
    1.  生成1字节和2字节数字的指令会保持剩下的字节不变。
    2.  生成4字节数字的指令会把高4个字节置0.

<!--list-separator-->

-  操作数指示符

    大多数指令有一个或多个操作数(operand)，指示出执行一个操作中要使用的源数据值，以及旋转结果的目的位置。

    -   各种不同的操作数的可能性被分为三种类型。
        1.  立即数(immediate): 用来表示常数值
            在ATT格式的汇编代码中，立即数的书写方式是$后面跟一个用标准C表示法表示的整数。
            不同的指令允许的立即数值范围不同，汇编器会自动造势最紧凑的方式进行数值编码。
        2.  寄存器(register): 它表示某个寄存器的内容
            16个寄存器的低位1字节，2字节，4字节，8字节中的一个作为操作数，这些字节数分别对应于8位，16位，32位，64位。
            我们使用rN来表示任意寄存器N,用引用R[rN]来表示它的值，这是将寄存器集合看成一个数组R.
        3.  内存引用
            它会根据计算出来的地址访问某个内存位置。
            我们使用Mb[Addr]表示对存储在内存中从地址Addr开始的b个字节值的引用。
            -   寻址模式
                有多种不同的寻址模式，允许不同形式的内存引用。
                下表中Imm(r_b,r_i, s)表示的是最常用的形式。这样的引用有四个组成部分： 一个立即数偏移Imm,一个基址寄存器r_b,一个变址寄存器r_i和一个比例因子s,这里s必须是1,2,4或者8。基址和变址寄存器都必须是64位寄存器。有效地址被计算为Imm+R[r_b] + R[r_i] \* s。
                操作数模式

                | 类型 | 格式             | 操作数值                      | 名称       |
                |----|----------------|---------------------------|----------|
                | 立即数 | $Imm             | Imm                           | 立即数寻址 |
                | 寄存器 | r_a              | R[r_a]                        | 寄存器寻址 |
                | 存储器 | Imm              | M[Imm]                        | 绝对寻址   |
                | 存储器 | (r_a)            | M[R[r_a]]                     | 间接寻址   |
                | 存储器 | Imm(r_b)         | M[Imm+R[r_b]]                 | （基址+偏移量）寻址 |
                | 存储器 | (r_b, R_i)       | M[R[r_b] + R[r_i]]            | 变址寻址   |
                | 存储器 | Imm(r_b, r_i)    | M[Imm+R[r_b] + R[r_i]]        | 变址寻址   |
                | 存储器 | (,r_i,s)         | M[R[r_i] \* s]                | 比例变址寻址 |
                | 存储器 | Imm(,r_i, s)     | M[Imm + R[r_i] \* s]          | 比例变址寻址 |
                | 存储器 | (r_b, r_i, s)    | M[R[r_b] + R[r_i] \* s]       | 比例变址寻址 |
                | 存储器 | Imm(r_b, r_i, s) | M[Imm + R[r_b] + R[r_i] \* s] | 比例变址寻址 |

<!--list-separator-->

-  数据传送指令

    源操作数指定的值是一个立即数，存储在寄存器中或者内存中。目的操作紵个位置，要么是一个寄存器，要么是一个内存地址。
    x86-64加了一条限制，传送指令的两个操作数不能都指向内存地址。
    大多数情况下，MOV指令只会更新目的操作数指定的那些寄存器字节或内存位置。唯一例外的是movl指令以寄存器作为目的时，它会把该寄存器高位4字节设置为0。

    | 指令         | 效果      | 描述    |
    |------------|---------|-------|
    | MOV s, D     | D &lt;- S | 传送    |
    | movb         |           | 传送字节 |
    | movw         |           | 传送字  |
    | movl         |           | 传送双字 |
    | movq         |           | 传送四字 |
    | movabsq I, R | R &lt;- I | 传送绝对的四字 |

    -   MOV指令的一种可能的组合。第一个是源操作数，第二个是目的操作数。
        1.  movl $0x4050, %eax
            Immediate - Register, 4 bytes
        2.  movw %bp, %sp
            Register - Register, 2bytes
        3.  movb (%rdi, %rcx), %al
            Memory - Register, 1byte
        4.  movb $-17, (%rsp)
            Immediate - Memory, 1byte
        5.  movq %rax, -12(%rbp)
            Register - Memory, 8bytes

    <!--list-separator-->

    -  将较小的源值复制到较大的目的指令

        <!--list-separator-->

        -  MOVZ类

            指令会把目的中简便的字节填充为0

            | 指令      | 效果           | 描述           |
            |---------|--------------|--------------|
            | MOVZ S, R | R &lt;- 零扩展(S) | 以零扩展进行传送 |
            | movzbw    |                | 将做了零扩展的字节传送到字 |
            | movzbl    |                | 将做了零扩展的字节传送双字 |
            | movzwl    |                | 将做了零扩展的字传送到双字 |
            | movzbq    |                | 将做了零扩展的字节传送到四字 |
            | movzwq    |                | 将做了零扩展的字传送到四字 |

        <!--list-separator-->

        -  MOVS

            指令通过符号扩展来填充，把源操作的最高位进行复制。

            | 指令     | 效果                  | 描述            |
            |--------|---------------------|---------------|
            | MOVS S,R | R &lt;- 符号扩展（S） | 传送符号扩展的字节 |
            | movsbw   |                       | 将做了符号扩展的字节传送到字 |
            | movsbl   |                       | 将做了符号扩展的字节传送到双字 |
            | movswl   |                       | 将做了符号扩展的字传送到双字 |
            | movsbq   |                       | 将做了符号扩展的字节传送到四字 |
            | movswq   |                       | 将做了符号扩展的字传送到四字 |
            | movslq   |                       | 将做了符号扩展的双字传送到四字 |
            | cltq     | %rax &lt;- 符号扩展(%eax) | %eax符号扩展到%rax |

<!--list-separator-->

-  压入和弹出栈数据

    栈指针%rsp保存着栈顶元素的地址。

    | 指令   | 效果                                          | 描述   |
    |------|---------------------------------------------|------|
    | pusq S | R[%rsp] &lt;- R[%rsp] - 8; M[R[%rsp]] &lt;- S | 将四字压入栈 |
    | popq D | D &lt;- M[R[%rsp]]; R[%rsp] &lt;- R[%rsp] + 8 | 将四字弹出栈 |


#### 算术和逻辑操作 {#算术和逻辑操作}

整数算术和逻辑操作，大多数操作都分成了指令类，这些指令类有各种带不同大小操作数的变种（只有lead没有其他大小的变种）。这些操作被分为四组：加载有效地址，一元操作，二元操作和移位。

| 指令     | 效果                     | 描述       |
|--------|------------------------|----------|
| leaq S,D | D &lt;- &amp;S           | 加载有效地址 |
| INC D    | d &lt;- d + 1            | 加1        |
| DEC D    | D &lt;- D - 1            | 减1        |
| NEG D    | D &lt;- -D               | 取负       |
| NOT D    | D &lt;- ~D               | 取补       |
| ADD S,D  | D &lt;- D + S            | 加         |
| SUB S,D  | D &lt;- D - S            | 减         |
| IMUL S,D | D &lt;- D \* S           | 乘         |
| XOR S,D  | D &lt;- D ^ S            | 异或       |
| OR S,D   | D &lt;- D 或 S           | 或         |
| AND S,D  | D &lt;- D &amp; S        | 与         |
| SAL K,D  | D &lt;- D &lt;&lt; K     | 左移       |
| SHL K,D  | D &lt;- D &lt;&lt; K     | 左移（等同于SAL） |
| SAR K,D  | D &lt;- D &gt;&gt; K     | 算术右移   |
| SHR K,D  | D &lt;- D &gt;&gt;&gt; K | 逻辑右移   |

<!--list-separator-->

-  加载有效地址

    加载有效地址leaq实际上是movq指令的变形。它的指令形式是从内存读数据到寄存器但实际上它根本就没有引用内存。它的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数。

<!--list-separator-->

-  一元和二元操作

    第二组中的操作是一元操作，只有一个操作数，既是源又是目的。这个操作数可以是一个寄存器，也可以是一个内存位置。
    第三组是二元操作，其中，第二个操作数既是源又是目的。不过，要注意，源操作数是第一个 ，目的操作数是第二个。第一个操作数可以是立即数、寄存器或是内存位置。第二个操作数可以是寄存器或是内存位置。注意，当第二个操作数为内存地址时，处理器必须从内存读出值，执行操作，再把结果写回内存。

<!--list-separator-->

-  移位操作

    最后一组是移位操作，先给出移位量，然后第二项给出的是要移位的数。

<!--list-separator-->

-  说明

    算术和逻辑操作的大多数指令，既可以用于无符号运算，也可以用于补码运算。只有右移操作要求区分有符号和无符号数。

<!--list-separator-->

-  特殊的算术操作

    两个64位有符号整数相乘得到的乘积需要128位来表示。x86-64指令对128位（16字节）数的操作提供有限的支持。Intel把16字节的数称为八字（oct word）。
    支持产生两个64位数字的全128位税种以及整数除尘的指令如下：

    | 指令    | 效果                                 | 描述   |
    |-------|------------------------------------|------|
    | imulq S | R[%rdx]: R[%rax] &lt;- S \* R[%rax]  | 有符号全乘法 |
    | mulq S  | R[%rdx]: R[%rax] &lt;- S \* R[%rax]  | 无符号全乘法 |
    | clto    | R[%rdx]: R[%rax] 符号扩展（R[%rax]） | 转换为八字 |
    | idivq S | R[%rdx] &lt;- R[%rdx]: R[%rax] mod S | 有符号除法 |
    | divq S  | R[%rdx] &lt;- R[%rdx]: R[%rax] mod S | 无符号除法 |


#### 控制 {#控制}

<!--list-separator-->

-  条件码

    除了整数寄存器，CPU还维护着一组单个位的条件码（condition code）寄存器，它们描述了最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。最常见的条件码有：

    -   CF：进位标志。阳近的操作使最高位产生了进位。可用来检查无符号操作的溢出。
    -   ZF：零标志。最近的操作得出的结果为0。
    -   SF：符号标志。最近的操作得到的结果为负数。
    -   OF：溢出标志。最近的操作导致一个补码溢出--正溢出或负溢出。

    <!--list-separator-->

    -  比较和测试指令

        | 指令        | 基于        | 描述 |
        |-----------|-----------|----|
        | CMP S1, S2  | S2 - S1     | 比较 |
        | cmpb        |             | 比较字节 |
        | cmpw        |             | 比较字 |
        | cmpl        |             | 比较双字 |
        | cmpq        |             | 比较四字 |
        |             |             |      |
        | TEST S1, S2 | S1 &amp; S2 | 测试 |
        | testb       |             | 测试字节 |
        | testw       |             | 测试字 |
        | testl       |             | 测试双字 |
        | testq       |             | 测试四字 |

<!--list-separator-->

-  访问条件码

    条件码通常不会直接读取，常用的使用方法有三种：我们将这一豆类指令称为SET指令。

    1.  可以根据条件码的某种组合，将一个字节设置为0或1,2
    2.  可以条件中转到程序的某个其他的部分
    3.  可以有条件地传送数据

    | 指令    | 同义名 | 效果                         | 设置条件        |
    |-------|-----|----------------------------|-------------|
    | sete D  | setz   | D &lt;- ZF                   | 相等/零         |
    | setne D | setnz  | D &lt;- ~ZF                  | 不等/非零       |
    |         |        |                              |                 |
    | sets D  |        | D &lt;- SF                   | 负数            |
    | setns D |        | D &lt;- ~SF                  | 非负数          |
    |         |        |                              |                 |
    | setg D  | setnle | D &lt;- ~(SF ^ OF) &amp; ~ZF | 大于（有符号&gt;） |
    | setge D | setnl  | D &lt;- ~(SF ^ OF)           | 大于等于（有符号&gt;=） |
    | setl D  | setnge | D &lt;- SF ^ OF              | 小于（有符号&lt;） |
    | setle D | setng  | D &lt;- (SF ^ OF) 或 ZF      | 小于等于（有符号&lt;=） |
    |         |        |                              |                 |
    | seta D  | setnbe | D &lt;- ~CF &amp; ~ZF        | 超过（无符号&gt;） |
    | setae D | setnb  | D &lt;- ~CF                  | 超过或相等（无符号&gt;=） |
    | setb D  | setnae | D &lt;- CF                   | 低于（无符号&lt;） |
    | setbe D | setna  | D &lt;- CF 或 ZF             | 低于或相等（无符号&lt;=） |

<!--list-separator-->

-  跳转指令

    正常执行的情况下，指令按照它们出现的顺序一条一条地执行。跳转（jump）指令会导致执行切换到程序中一个全新的位置。这些跳转的目的地通常用一个标号（label）指明。
    下表列举了不同的跳转指令。jmp指令是无条件跳转。它可以是直接跳转，即跳转目标是作为指令的一部分编码的;也可以是间接跳转，即跳转目标是从寄存器或内存位置中读出的。
    汇编语言中，直接跳转是给出一个标号作为跳转目标的，间接跳转的写法是\*后面跟一个操作数指示符。
    例如：jmp \*%rax 用寄存器%rax中的值作为跳转目标
         jmp \*(%rax) 以%rax中的值作为读地址，从内存中读出跳转目标。

    | 指令          | 同义名 | 跳转条件             | 描述   |
    |-------------|-----|------------------|------|
    | jmp Label     |      | 1                    | 直接跳转 |
    | jmp \*Operand |      | 1                    | 间接跳转 |
    | je Label      | jz   | ZF                   | 相等/零 |
    | jne Label     | jnz  | ~ZF                  | 不相等/非零 |
    | js Label      |      | SF                   | 负数   |
    | jns Label     |      | ~SF                  | 非负数 |
    | jg Label      | jnle | ~(SF ^ OF) &amp; ~ZF | 大于   |
    | jge Label     | jnl  | ~(SF ^ OF)           | 大于或等于 |
    | jl Label      | jnge | SF ^ OF              | 小于   |
    | jle Label     | jng  | (SF ^ OF) 或 ZF      | 小于或等于 |
    | ja Label      | jnbe | ~CF &amp; ~ZF        | 超过   |
    | jae Label     | jnb  | ~CF                  | 超过或相等 |
    | jb Label      | jnae | CF                   | 低于   |
    | jbe Label     | jna  | CF 或 ZF             | 低于或相等 |

<!--list-separator-->

-  跳转指令的编码

<!--list-separator-->

-  用条件控制来实现条件分支

<!--list-separator-->

-  用条件传送来实现条件分支

    条件传送指令

    | 指令       | 同义名 | 传送条件 | 描述   |
    |----------|-----|------|------|
    | cmove S,R  | cmovz  | ZF   | 相等/零 |
    | cmovne S,R | cmovnz | ~ZF  | 不相等/非零 |

<!--list-separator-->

-  循环

    C语言提供了多种循环结构，即do-while，while和for。

    <!--list-separator-->

    -  do-while

    <!--list-separator-->

    -  while

    <!--list-separator-->

    -  for

        ```nil
        for (init-expr; test-expr; update-expr) {
          body-statement
        }
        ```

        这样一个循环的行为与下面这段使用while循环的代码的行为一样

        ```nil
        init-expr;
        while (test-expr) {
          body-statement
          update-expr;
        }
        ```

<!--list-separator-->

-  switch语句

    switch(开关)语句可以根据一个整数索引值进行多重分支。在处理具有多种可能结果的测试时，这种语句特别有用。它们不公提高了C代码的可读性，而且通过使用跳转表(jump table)这种数据结构使得实现更加高效。和使用一组很长的if-else语句相比，使用跳转表的优点是执行开关语句的时间与开关情况的数量无关。


#### 过程 {#过程}

过程是软件中一种很重要的抽象。它提供了一种封闭代码的方式，用一组指定的参数和一个可选反返回值实现了某种功能。然后，可以在程序中不同的地方调用这个函数。
要提供对过程的机器级支持，必须要处理许多不同的属性。为了讨论方便，假设过程P调用过程Q,Q执行后返回到P.这些动作包括下面一个或多个机制：

-   传递控制：在进入过程Q的时候，程序计数器必须被设置成Q的代码的起始地址，然后在返回时，要把程序计数器设置为P中调用Q后面那条指令的地址。
-   传递数据：P必须能够向Q提供一个或多个参数，Q必须能够向P返回一个值。
-   分配和释放内存：在开始时，Q可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间。

<!--list-separator-->

-  运行时栈

    C语言过程调用机制的一个关键特性（大多数其他语言也是如此）在于使用了栈数据结构提供的后进先出的内存管理原则。在过程P调用过程Q的例子中，可以看到当Q在执行时，P以及所有在向上追溯到P的调用链中的过程，都是暂时被挂起的。当Q运行时，它只需要为局部变量分配新的存储空间，或者设置到另一个过程的调用。另一方面，当Q返回时，任何它所分配的局部存储空间都可以被释放。因此，程序可以用栈来管理它的过程所需要的存储空间，栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息。当P调用Q时，控制和数据信息添加到栈尾。当P返回时，这些信息会释放掉。
    当X86_64过程需要的存储空间走出寄存器能够存放的大小时，就会在栈上分配空间。这个部分称为过程的栈帧(stack fram)。当前正在执行的过程的帧总是在栈顶。
    通过寄存器，过程P可以传递最多6个整数值（也就是指针和整数），但是如果Q需要更多的参数，P可以在调用Q之前在自己的栈帧里存储好这些参数。
    为了提高空间和时间效率，x86_64过程只分配自己所需要的栈帧部分。例如，许多过程有6个或者更少的参数，那么所有的参数都可以通过寄存器传递。

<!--list-separator-->

-  转移控制

    将控制从函数P转移到函数Q只需要简单地把程序计数器（PC）设置为Q的代码的起始位置。不过，当稍后从Q返回的时候，处理器必须记录好它需要继续P的执行的代码位置。在x86——64机器中，这个信息是用指令call Q调用过程Q来记录的。该指令会把地址A压入栈中，并将PC设置为Q的起始地址。压入的地址A被称为返回地址，是紧跟在call指令后面的那条指令的地址。对应的指令ret会从栈中弹出地址A,并把PC设置为A.
    call指令有一个目标，即指明被调用过程起始的指令地址。同跳转一样，调用可以是直接，也可以是间接的。在汇编代码中，直接调用的目标是一个标号，而间接调用的目标是\*后面跟一个操作数指示符。

<!--list-separator-->

-  数据传送

    当调用一个过程时，除了要把控制传递给它并在过程返回时再传递回来之外，过程调用还可能包括把数据作为参数传递，而从过程返回还有可能包括返回一个值。x86-64中，大部分过程间的数据传送是通过寄存器实现的。
    x86-64中，可以通过寄存器最多传递6个整形（例如整数和指针）参数。寄存器的使用是有特殊顺序的，寄存器使用的名字取决于要传递的数据类型的大小，会根据参数在参数列表中的顺序为它们分配寄存器。

    <div class="table-caption">
      <span class="table-number">Table 1:</span>
      传递函数参数的寄存器。
    </div>

    | 操作数据大小 | 1    | 2    | 3    | 4    | 5    | 6    |
    |--------|------|------|------|------|------|------|
    | 64     | %rdi | %rsi | %rdx | %rcx | %r8  | %r9  |
    | 32     | $edi | %esi | %edx | %ecx | %r8d | %r9d |
    | 16     | %di  | %si  | %dx  | %cx  | %r8w | %r9w |
    | 8      | %dil | %sil | %dl  | %cl  | %r8b | %r9b |

    如果一个函数有大于6个整形参数，走出个的部分就要通过栈来传递。把参数7-N个参数放到栈上，而参数7位于栈顶。通过栈传递参数时，所有的数据大小都向8的倍数对齐。

<!--list-separator-->

-  栈上的局部存储

    e 些时候，局部数据必须存放在内存中，学见的情况包括：

    -   寄存器不足够存放所有的本地数据
    -   对一个局部变量使用地址运算符'&amp;'，因此必须能够为它产生一个地址
    -   某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。

<!--list-separator-->

-  寄存器中的局部存储空间

    寄存器组是唯一被所有过程共享的资源。虽然在给定时刻只有一个过程是活动的，我们仍然必须确保当一个过程（调用者）调用另一个过程（被调用者）时，被调用者不会覆盖调用者稍后会使用的寄存器值。
    根据惯例，寄存器%rbx、%rbp和%r12-%r15被划分为被调用者保存寄存器。当过程P调用过程Q时，Q必须保存这些寄存器的值，保证它们的值在Q返回到P时与Q被调用时是一样的。过程Q保存一个寄存器的值不变，要么就是根据不去改变它，要么就是把原始值压入栈中，改变寄存器的值，然后在返回前从栈中弹出旧值。压入寄存器的值会在栈帧中创建标号为“保存的寄存器”的一部分。
    所有其他的寄存器，除了栈指针%rsp,都分类为调用者保存寄存器。这就意味着任何函数都能修改它们。可以这样来理解“调用者保存”这个名字：过程P在某个此类寄存器中有局部数据，然后调用过程Q。因为Q可以随意修改这个寄存器，所以在调用之前首先保存好这个数据是P（调用者）的现任。

<!--list-separator-->

-  递归过程


#### 数组分配和访问 {#数组分配和访问}

<!--list-separator-->

-  基本原则

    对于数据类型T和整形常数N,声明如下：
    T A[N];
    起始位置表示为x_A。这个声明有两个效果。首先，它在内存中分配一个L\*N字节的连续区域，这里的L是数据类型T的大小（单位为字节）。其次，它引入了标识符A,可以用A来作为指向数组开头的指针，这个指针的值就是x_A。可以用0-N-1的整数索引来访问该数组元素。数组元素i会被存放在地址为x_A + L \* i的地方。

<!--list-separator-->

-  指针运算

    C语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩。也就是说，如果p是一个指向类型为T的数据的指针，p的值为x_p，那么表达式p + i的值为x_p + L \* i，这里的L是数据类型t的大小。
    单操作数操作符"&amp;"t "\*"可以产生指针和间接引用指针。也就是说，对于一个表示某个对象的表达式Expr, &amp;Expr是给出该对象地址的一个指针。对于一个表示地址的表达式AExpr, \*AExpr给出该地址处的值。因此，表达式Expr和\*&amp;Expr是等价的。数组引用A[i]等同于表达式\*(A + i)。

<!--list-separator-->

-  嵌套的数组

<!--list-separator-->

-  定长数组

    C语言编译器能够优化定长多维数组上的操作代码。

<!--list-separator-->

-  变长数组

    C99允许数组的维度是表达式，在数组被分配的时候才计算出来。


#### 异质的数据结构 {#异质的数据结构}

C语言提供了两种将不同匠对象组合到一起创建数据类型的机制：结构(structure)，用关键字struct来声明，将多个对象集合一个单位中; 联合(union)， 用关键字union来声明，允许用几种不同的类型来引用一个对象。

<!--list-separator-->

-  结构

    C语言的struct声明创建一个数据类型，将可能不同类型的对象聚合到一个对象中。用名字来引用结构的各个组成部分。类似于数组的实现，结构的所有组成部分都存放在内存中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址。编译器维护关于每个结构类型的信息，指示每个字段的字节偏移。它以这些偏移作为内存引用指令中的位移，从而产生对结构元素的引用。结构的各个字段的选取完全是在编译时处理的。机器代码不包含关于字段声明或字段名字的信息。

<!--list-separator-->

-  联合

    联合提供了一种方式，能够规避C语言的类型系统，允许以多种类型来引用一个对象。联合声明的语法与结构的语法一样，只不过主义相差比较大。它们是用不同的字段来引用相同的内存块。

<!--list-separator-->

-  数据对齐

    许多计算机系统对基本数据类型的合法地址做出了一些限制，要求某种类型对象的地址必须是某个值K（通常是2、4、8）的倍数。这种对齐限制简化了形成处理器和内存系统之间接口的硬件设计。
    编译器在汇编代码中放入命令，指明僵尸数据所需的对齐。

    ```asm
    .align 8
    ```

    对于包含结构的代码，编译器可能需要在字段的分配中插入间隙，以保证每个结构元素都满足它的对齐要求。而结构本身对它的起始地址也有一些对齐要求。

<!--list-separator-->

-  在机器级程序中将控制与数据结合起来

    <!--list-separator-->

    -  理解指针

        指针是C语言的一个核心特色。它们以一种统一方式，对不同数据结构中的元素产生引用。

        <!--list-separator-->

        -  指针和它们映射到机器代码的关键原则

            -   每个指针都对应一个类型
                通常，如果对象类型为T,那么指针的类型为T\*。特殊的void \*类型代表通用指针。
            -   每个指针都有一个值。
                这个值是某个指定类型的对象的地址。特殊的NULL(0)值表示该指针没有指向任何地方。
            -   指针用'&amp;'运算符创建
                这个运算符可以应用到任何lvalue类的C表达式上，lvalue意指可以出现在同仁语句左边的表达式。
            -   \* 操作衔用于间接引用指针
                其结果是一个值，它的类型与该指针的类型一致。
            -   数组与指针紧密联系
                将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值。
            -   指针也可以指向函数

    <!--list-separator-->

    -  使用GDB调试器

        <div class="table-caption">
          <span class="table-number">Table 2:</span>
          GDB命令示例
        </div>

        | 命令                             | 效果                          |
        |--------------------------------|-----------------------------|
        | 开始和停止                       |                               |
        | quit                             | 退出GDB                       |
        | run                              | 运行程序(在此给出命令行参数)  |
        | kill                             | 停止程序                      |
        |                                  |                               |
        | 断点                             |                               |
        | break multstore                  | 在函数multstore入口处设置断点 |
        | break \* 0x400540                | 在地址0x400540处设置断点      |
        | delete 1                         | 删除断点1                     |
        | delete                           | 删除所有断点                  |
        |                                  |                               |
        | 执行                             |                               |
        | stepi                            | 执行一条指令                  |
        | stepi 4                          | 执行4条指令                   |
        | nexti                            | 类似于stepi,但以函数调用为单位 |
        | continue                         | 继续执行                      |
        | finish                           | 运行到当前函数返回            |
        |                                  |                               |
        | 检查代码                         |                               |
        | disas                            | 反汇编当前函数                |
        | disas multstore                  | 反汇编函数multstore           |
        | disas 0x400540                   | 反汇编位于地址0x400540附近的函数 |
        | disas 0x400540,0x40054d          | 反汇编指定地址范围内的代码    |
        | print /x $rip                    | 以十六进制输出程序计数器的值  |
        |                                  |                               |
        | 检查数据                         |                               |
        | print $rax                       | 以十进制输出%rax的内容        |
        | print /x $rax                    | 以十六进制输出%rax的内容      |
        | print /t $rax                    | 以二进制输出%rax的内容        |
        | print 0x100                      | 输出0x100的十进制表示         |
        | print /x 555                     | 输出555的十六进制表示         |
        | print /x ($rsp + 8)              | 以十六进制输出%rsp的内容加上8 |
        | print \*(long \*) 0x7fffffffe818 | 输出位于地址0x7fffffffe818的长整数 |
        | print \*(long \*)($rsp + 8)      | 输出位于地址%rsp+8处的长整数  |
        | x/2g 0x7fffffffe818              | 检查从地址0x7fffffffe818开始的双(8字节)字 |
        | x/20bmultstore                   | 检查函数multstore的前20个字节 |
        |                                  |                               |
        | 有用的信息                       |                               |
        | info frame                       | 有关当前栈帧的信息            |
        | info registers                   | 所有寄存器的值                |
        | help                             | 获取有关GDB的信息             |

    <!--list-separator-->

    -  内存越界引用和缓冲区溢出

        C对于数组引用不进行任何边界检查，而且局部变量和状态信息（例如保存的寄存器值和返回地址）都存放在栈中。

    <!--list-separator-->

    -  对抗缓冲区举出攻击

        1.  栈随机化
            栈随机化的思想使得栈的位置在程序每次运行时都有变化。在Linux系统中，栈随机化已经变成了标准行为。它是更大的一类技术中的一种，这类技术称为地址空间布局随机化（Address-Space Layout Randomization），或者简称ASLR。
        2.  栈破坏检测
            计算机的第二道防线是能够检测到何时栈已经被破坏。
            最近的GCC版本在产生的代码中加入了一种栈保护者(stack protector)机制，来检测缓冲区越界。其思想是在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的金丝雀值。是在程序每次运行时随机产生的，因此，攻击同有简单的办法能够知道它是什么。在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者该函数调用 的某个函数的某个操作改变了。如果是的，那么程序异常中止。
        3.  限制可执行代码区域

    <!--list-separator-->

    -  支持变长栈帧

        为了管理变长栈帧，x86-64代码使用寄存器%rbp作为帧指针（frame pointer）（有时称为基指针(base pointer)，这也是%rbp中bp两个字母的由来）


#### 浮点代码 {#浮点代码}

处理器的浮点体系结构包括多个方面，会影响对浮点数据操作的程序如何被映射到机器上，包括：

-   如何存储和访问浮点数值。通常是通过某种寄存器方式来完成
-   对浮点数据操作的指令
-   向函数传递浮点数参数和从函数返回浮点数结果的规则
-   函数调用过程中保存寄存器的规则

<!--list-separator-->

-  浮点传送和转换操作

<!--list-separator-->

-  过程中的浮点代码

<!--list-separator-->

-  浮点运算操作

<!--list-separator-->

-  定义和使用浮点常数

<!--list-separator-->

-  在浮点代码中使用位级操作

<!--list-separator-->

-  浮点比较操作

<!--list-separator-->

-  对浮点代码的观察结论


### 处理器体系结构 {#处理器体系结构}

一个处理器支持的指令和指令的字节级编码称为它的指令集体系结构（Instruction-Set Architecture, ISA）


#### Y86-64指令集体系结构 {#y86-64指令集体系结构}

定义一个指令集体系结构包括定义各种状态单元、指令集和它们的编码、一组编程规范和异常事件处理。

<!--list-separator-->

-  程序员可见的状态

    Y86-64程序中的每条指令都会读取或修改处理器状态的某些部分。这称为程序员可见状态，这里的程序员既可以是用汇编代码写程序的人，也可以是产生机器级代码的编译器。在处理器实现中，只要我们保证机器 级程序能够访问程序员可见状态，就不需要完全按照ISA暗示的方式来表示和组织这个处理器状态。

<!--list-separator-->

-  Y86-64指令

<!--list-separator-->

-  指令编码

    <!--list-separator-->

    -  比较CISC和最初的RISC指令集

        | CISC                                                                   | RISC                                                                                          |
        |------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------|
        | 指令数量很多。Intel描述全套指令的文档有1200多页                        | 指令数量少得多，通常少于100个                                                                 |
        | 有些指令的延迟很长。包括将一个整块从内存的一个部分复制到另一部分的指令，以及其他一些将多个寄存器的值复制到内存或从内存复制到多个寄存器的指令 | 没有较长的延迟的指令。有些早期 的RISC机器甚至没有整数乘法指令，要求编译器通过一系列g加法为实现乘法。 |
        | 编码是可变长度的。X86-64的指令长度可以是1-15个字节                     | 编码是固定长度的。通常所有的指令都编码为4个字节                                               |
        | 指定操作数的方式很多样。在X86-64中，内存操作数指示符可以有许多不同的组合，这些组合由领衔量、基址和变址寄存器以及伸缩因子组成 | 简单寻址方式。通常只有基址和统称量寻址                                                        |
        | 可以对内存和寄存器操作数进行算术和逻辑运算。                           | 只能对寄存器操作数进行算术和逻辑运算，允许使用内存引用的只有load和store指令，load是从内存读到寄存器，store是从寄存器写到内存。这种方法被称为load/store体系结构 |
        | 对机器级程序来说实现细节是不可见的。ISA提供了程序和如何执行程序之间的清晰的抽象 | 对机器级程序来说实现细节是可见的。有些RISC机器禁止某些特殊的指令序列，而有些跳转要到下一条指令执行完了以后才会第一次。编译器必须在这些约束条件下进行性能优化。 |
        | 有条件码，作为指令执行的副产品，设置了一些特殊的标志位，可以用于条件分支检测 | 没有条件码。相反，对条件检测来说，要用明确的测试指令，这些指令会将测试结果放在一个普通的寄存器中。 |
        | 栈密集的过程链接。栈被用来存取过程参数和返回地址。                     | 寄存器密集的过程链接。寄存器被用来存取过程参数和返回地址。因此有些过程能完全避免内存引用。通常处理器有更多的（最多的有32个）寄存器 |


#### 逻辑设计和硬件控制语言HCL {#逻辑设计和硬件控制语言hcl}

在硬件设计中，用电子电路来计算对位进行运算的函数，以及在各种存储器单元中存储位。大多数现代电路技术都是用信号线上的高电压和低电压来表示不同的位值。
要实现一个数字系统需要三个主要的组成部分：计算对位进行操作的函数的组合逻辑、存储位的存储器单元，以及控制存储器单元更新的时钟信号。

<!--list-separator-->

-  逻辑门

    逻辑门是数字电路的基本计算单元。它们产生的输出，等于它们输入位值的某个布尔函数。逻辑门总是活动的。一旦一个门的输入变化了，在很短的时间内，输出就会相应的变化。

<!--list-separator-->

-  组合电路和HCL布尔表达式

    将很多的逻辑门组合成一个网，就能构建计算块，称为组合电路。

    <!--list-separator-->

    -  构建这些网有几个限制

        -   每个逻辑门的输入必须连接到下述选项之一
            1.  一个系统输入（称为主输入）
            2.  某个存储器单元的输出
            3.  某个逻辑门的输出
        -   两个或多个逻辑门的输出不能连接在一起。否则它们可能会使线上的信号矛盾，可能会导致一个不合法的电压a中电路故障。
        -   这个网必须是无环的。

<!--list-separator-->

-  字级的组合电路和HCL整数表达式

    通过将逻辑门组合成大的网，可以构造出能计算更加复杂函数的组合电路。

<!--list-separator-->

-  集合关系

    在处理器设计中，很多时候都需要将一个信号与许多可能匹配的信号做比较，以此来检测正在处理的某个指令代码是否属于某一类指令代码。

<!--list-separator-->

-  存储器和时钟

    组合电路从本质上讲，不存储任何信息。相反，它们只是简单地响应输入信号，产生等于输入的某个函数的输出。为了产生时序电路，也就是有状态并且在这个状态上进行计算的系统，我们必须引入按位存储信息的设置。存储设备都是由同一个时钟控制的，时钟是一个周期性信号，决定什么时候要把新值加载到设軠中。

    -   考虑两类存储器设备
        -   时钟寄存器（简称寄存器）：存储单个位或字。时钟信号控制寄存器加载输入值。
        -   随机访问存储器（简称内存）存储多个字，用地址来选择该读或该写哪个字。


#### Y86-64的顺序实现 {#y86-64的顺序实现}

<!--list-separator-->

-  将处理组织成阶段

    通常，处理一条指令包括很多操作。将它们组织成霜个特殊的阶段序列，即使指令的动作差异很大，但所有的指令都遵循统一的序列。每一步的具体处理取决于正在执行的指令。创建这样一个框架，我们就能够设计一个充分利用硬件的处理器。下面是关于各个阶段以及各有阶段内执行操作的简略描述：

    -   取指(fetch): 指从内存读取指令字节，地址为程序计数器（PC）的值。
    -   译码(decode):
    -   执行(execute):
    -   访存(memory):
    -   写回(write back):
    -   更新PC(PC udpate):

<!--list-separator-->

-  SEQ硬件结构

<!--list-separator-->

-  SEQ的时序

<!--list-separator-->

-  SEQ阶段的实现


#### 流水线的通用原理 {#流水线的通用原理}

流水线化的一个重要我就是提高了系统的吞量，也就是单位时间内服务的顾客总数，不过它也会轻微地增加延迟，就是服务一个用户所需要的时间。

<!--list-separator-->

-  计算流水线

<!--list-separator-->

-  流水线操作的详细说明

<!--list-separator-->

-  流水线的局限性

<!--list-separator-->

-  带反馈的流水线系统


#### Y86-64的流水线实现 {#y86-64的流水线实现}


#### 流水线冒险 {#流水线冒险}


### 优化程序性能 {#优化程序性能}

在程序开发和优化的过程中，我们必须考虑代码使用的方式，以及影响它的关键因素。通常程序员必须在实现和维护程序的简单性与它的运行速度之间做出权衡。
研究程序的汇编代码表示是理解编译器以及产生的代码会如何运行的最有效手段之一。
一个很有用的策略是只重写程序到编译器由此就能产生有效代码所需要的程度就好了。这样能尽量避免损害代码的可读性、模块性和可移植性，就好像我们使用的是具有最低能力的编译器。同样，通过测量值和检查生成的汇编代码，反复修改源代码和分析它的性能是很有帮助的。对于新手程序员来说，不断修改源代码，试图欺骗编译器产生有效的代码，看起来很奇怪，但这确实是编写很多高性能程序的方式。


#### 优化编译器的能力和局限性 {#优化编译器的能力和局限性}

现代编译器运用复杂精细的算法来确定一个程序中计算的是什么值，以及它们是被如何使用的。然后会利用一些机会来简化表达式，在几个不同的地方使用同一个计算，以及降低一个给定的计算必须被执行的次数。大多数编译器，包括GCC,向用户提供了一些对它们所使用的优化的控制。
编译器必须很小心地对程序只使用安全的优化，也就是说对于程序可能遇到的所有可能的情况，在C语言标准提供的保证之下，优化后得到的程序和未优化的版本有一样的行为。限制编译器只进行安全的优化，消除了造成不希望的运行时行为的一些可能的原因，但是这也意味着程序员必须花费更大的力气写出编译器能够将之转换成有效机器代码的程序。


#### 表示程序性能 {#表示程序性能}

我们引入试题标准每元素的周期数（Cycles Per Element, CPE），作为一种表示程序性能并指导我们改进代码的方法。CPE这种试题标准帮助我们在更细节的级别上理解迭代程序的循环性能。这样的试题标准对执行重复计算的程序来说是很适当的。
处理器活动的顺序是由时钟控制的，时钟提供了某个频率的规律信号，通常用千兆赫兹（GHz），即十亿周期每秒来表示。每个时钟周期的时间是时钟频率的倒数。通常是以纳秒（nanosecond, 1纳秒等于10^-9秒）或皮秒（picosecond, 1皮秒等于10^-12秒）为单位。用时钟周期来表示，度量值表示的是执行了多少条指令，而不是时钟运行得有多快。


#### 消除循环的低效率 {#消除循环的低效率}

将在循环中不改变的代码放到循环外边。


#### 减少过程调用 {#减少过程调用}


#### 消除不必要的内存引用 {#消除不必要的内存引用}


#### 理解现代处理器 {#理解现代处理器}

<!--list-separator-->

-  整体操作

    ICU从指令高速缓存（instruction cache）中读取指令，指令高速缓存是一个特殊的高速存储器，它包含最近访问的指令。当程序遇到分支时，现代处理器采用了一种分支预测的技术，处理器会猜测是否会选择分支，同时还预测分支的目的地址。
    指令译码逻辑接收实际的程序指令，，并将它们转换成一组基本操作（有时称为微操作）。
    EU接收来自取指单元的操作。通常，每个时钟周期会接收多个操作。这些操作会被分派到一组功能单元中，它们会执行实际的操作。这些功能单元专门用来处理不同类型的操作。
    读写内存是由加载和存储单元实现的。
    在ICU中，退役单元（retirement unit）记录正在进行的处理，并确保它遵守机器级程序的顺序主义。任何对程序寄存器的更新都只会在指令退役时才会发生，只有在处理器能够确信导致这条指令的所有分支都预测正确了，才会这样做。
    控制操作数在执行单元间传送的最常见的机制称为寄存器重命名。

<!--list-separator-->

-  功能单元的性能

    每个运算都是由以下这些数值来刻画的：一个是延迟（latency），它表示完成运算所需要的总时间，另一个是发射时间（issue time），它表示两个 连续的同类型的运算之间需要的最小时钟周期数，还有一个是容量（capactiy），它表示能够执行该运算的功能单元的数量。

<!--list-separator-->

-  处理器操作的抽象模型

    作为分析在现代处理器上执行的机器级程序性能的一个工具，我们会使用程序的数据流（data-flow）表示，这是一种图形化的表示方法，展现了不同操作之间的数据相关是如何限制它们的执行顺序的。这些限制形成了图中的关键路径（critical path），这是执行一组机器指令所需时钟周期数的一个下界。


#### 循环展开 {#循环展开}

循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。


#### 提高并行性 {#提高并行性}

<!--list-separator-->

-  多个累积变量

    对于一个可结合和可交换的合并运算来说，比如说整数加法或乘法，我们可以通过将一组合并运算分割成两个或更多的部分，并在最后合并结果来提高性能。

<!--list-separator-->

-  重新结合变换

    重新结合变换能够减少计算中关键路径上操作的数量，通过更好地利用功能单元的流水线能力得到更好的性能。


#### 理解内存性能 {#理解内存性能}

<!--list-separator-->

-  加载的性能

    一个包含加载操作的程序的性能既依赖于流水线的能力，也依赖于加载单元的延迟。

<!--list-separator-->

-  存储的性能

    与加载操作一样，在大多数情况中，存储操作能够在完全流水线化的模式中工作，每个周期开始一条新的存储。


#### 应用：性能提高技术 {#应用-性能提高技术}

<!--list-separator-->

-  优化性能的基本策略

    -   高级设计：为遇到的问题选择适当的算法和数据结构。
    -   基本编码原则
        -   消除连续的函数调用
        -   消除不必要的内存引用
    -   低级优化
        -   展开循环
        -   通过使用例如多个累积变量和重新结合等技术，找到方法提高指令级并行
        -   用功能性的风格重写条件操作，使得编译采用条件数据传送


#### 确认和消除性能瓶颈 {#确认和消除性能瓶颈}

<!--list-separator-->

-  程序剖析

    程序剖析（profiling）运行程序的一个版本，其中插入了工具代码，以确定程序的各个部分需要多少时间。剖析的一个有力之处在于可以在现实的基准数据（benchmark data）上运行实际程序的同时，进行剖析。
    Unix系统提供了一个剖析程序GPROF.

<!--list-separator-->

-  使用剖析程序来指导优化


### 存储器层次结构 {#存储器层次结构}


## 在系统上运行程序 {#在系统上运行程序}


### 链接 {#链接}
