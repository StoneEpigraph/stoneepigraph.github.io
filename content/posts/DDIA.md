+++
title = "DDIA"
author = ["WhatsUpeng!!!"]
date = 2024-08-22
tags = ["DDIA", "数据密集型应用设计", "设计", "架构"]
categories = ["book"]
draft = false
+++

## 数据密集型应用设计 {#数据密集型应用设计}


### 数据系统基础 {#数据系统基础}


#### 可靠、可扩展与可维护的应用系统 {#可靠-可扩展与可维护的应用系统}

对于数据密集型应用，CPU的处理能力往往不是第一限制性因素，在于数据量、数据的复杂度及数据的快速多变性。数据密集型应用通常也是基于标准模块构建而成，每个模块负责单一的常用功能。例如，许多应用系统都包含以下模块：

-   数据库： 用以存储数据，这样之后应用可以再次访问
-   调整缓存：缓存那些复杂或操作代价昂贵的结果，以加快下一次访问。
-   索引：用户可以按安搜索数据并支持各种过滤。
-   流式处理：持续发送消息臻另一个进程，处理采用异步方式
-   批处理：定期处理大量的累积数据。

<!--list-separator-->

-  可靠性

    当出现意外情况，如硬件、软件故障、人为失误等，系统应可以继续正常运转：虽然性能可能有所降低，但确保功能正确。对于软件,典型的可靠性期望包括:

    -   应用程序执行用户据期望的功能.
    -   可以容忍用户出现错误或者不正确的软件使用方法
    -   性能可以应对典型场景, 合理负载原动力和数据量
    -   系统可防止任何示经授权的访问和滥用

    <!--list-separator-->

    -  硬件故障

    <!--list-separator-->

    -  软件故障

        <!--list-separator-->

        -  原因

            -   由于软件错误
            -   一个应用进程使用了某些共享资源,但却不幸失控
            -   系统统带于某些服务,但该服务突然或无响应
            -   级联故障

    <!--list-separator-->

    -  人为失误

        <!--list-separator-->

        -  如果假定人是不可靠的,那么该如何保证系统的可靠性?

            -   以最小出错的方式来设计系统.
            -   想办法分离最容易出错的地方,容易引发故障的接口.
            -   充分的测试
            -   当出现人为失误时,提供快速的恢复机制以尽量减少故障影响
            -   设置详细而清晰的监控子系统
            -   推行管理流程并加以培训.

    <!--list-separator-->

    -  可靠性的重要性

<!--list-separator-->

-  可扩展性

    随着规模的增长，例如数据量、流量或复杂性，系统应以合理的方式来匹配这种增长。可扩展性是描述系统应对负载增加能力的术语。它并不是衡量一个系统的一维指标，谈论“x是可扩展的”或“y不扩展”没有太大意义。相反，讨论可扩展性通常要考虑这类问题：“如果系统以某种方式增长，我们应对增长的措施有哪些”，“我们该如何添加计算资源来处理额外的负载”。

    <!--list-separator-->

    -  描述负载

        负载可以用称为负载参数的若干数字来描述，参数的最佳选择取决于系统的体系结构。如Web服务器的每秒请示处理次数，数据库中定稿的比例等。

    <!--list-separator-->

    -  描述性能

        <!--list-separator-->

        -  延迟和响应时间

            延迟和响应时间容易混淆使用，通常响应时间是客户端看到的：除了处理请示时间外还包括来回网络延迟和各种排除延迟。延迟是请示花费在处理上的时间。有时，即使所有请示都相同，也会由于其他变量因素而引入一些延迟拉动，这些因素包括上下文切换和进程调度、网络数据包丢失和TCP重传、垃圾回收暂停、缺页中断和磁盘IO,甚至服务器机架的机械振动等。我们经常考察的是服务请示的平均响应时间，然后如果想知道更典型的响应时间，平均值并不是合适的指标，因为它掩盖了一些信息，无法告诉有多少用户实际经历了多少延迟。因此最好使用百分位数(percentiles)。如果已经搜集到了响应时间信息，将其从最快到最慢排序，中位数(median)就是列表中间的响应时间。中位数指标非常适合描述多少用户需要等待多长时间，通常缩写为p50。为了弄清楚异常值有多糟糕，需要关注更大的百分位数，如觉的p95, p99和p999。采用较高的响应时间百分位数很重要，因为它们直接影响用户的总体服务体验。百分位数通常用于描述、定义服务质量目标（Service Level Objectives, SLO）和服务质量协议（Service Level Agreements, SLA），这些是规定服务预期质量和可用性的合同。排队延迟往往在高百分数响应时间中影响很大。由于服务器并行处理的请示有限，正在处理的少数请示可能会阻挡后续请示，这种情况有时被称为队头阻塞。即使后续请示可能处理很简单，但它阻塞在等待先前请示的完成，客户端会观察到极慢的响应时间。

    <!--list-separator-->

    -  应对负载增加的方法

        把无状态服务分布然后扩展臻多台机器相对比较容易，而有状态服务从单个节点扩展到分布式多机环境的复杂性会大大增加。出于这个原因，址到最近通常的做法一直是，将数据库运行在一个节点上（采用垂直扩展策略），直到高扩展性或高可用性的要求近使不得不做水平扩展。超大规模的系统往往针对特定应用而高度定制，很验证有一种通用的架构。背后取舍因素包括数据读取量、写入量、待存储的数据量、的复杂程度、响应时间要求、访问模式等，或者更多的是上述所有因素的叠加，再加上其他更复杂的问题。对于特定应用来说，扩展能力好的架构通常会做出某些假设，然后有针对性地优化设计，如哪些操作是最频繁的，哪 些负载是少数情况。可扩展架构通常都是从通用模块逐步构建而来， 背后往往有规律可循。

<!--list-separator-->

-  可维护性

    随着时间的失衡，许多新的人员参与到系统开发和运维，以维护现有功能或甜酸新场景等，可维护性包括维护与缺陷修复，监控系统来保持正常运行、故障排查、适配新平台、搭配新场景、技术担风险的完善以及增加新功能等。

    <!--list-separator-->

    -  我们需要特别关注软件系统的三个设计原则

        <!--list-separator-->

        -  可运维性

            方便运营团队来保持系统平衡运行。

            <!--list-separator-->

            -  运营团队负责的主要内容

                1.  监视系统的健康状况，并在服务出现异常状态时快速恢复服务。
                2.  追踪问题的原因，例如系统故障或性能下降。
                3.  保持软件和平台臻最新状态
                4.  了解不同系统如何相互影响，避免执行带有破坏性的操作。
                5.  预测未来可能的问题，并在问题发生之前即解决。
                6.  建立用于部署、配置管理待良好的实中规范和工具包。
                7.  执行复杂的维护任务
                8.  当配置更改时，维护系统的安全稳健
                9.  制定流程来规范操作行为，并保持生产环境稳定。
                10. 保持相关知识的传承（如对系统的理解）。

            <!--list-separator-->

            -  数据系统设计要点

                1.  提供对系统运行时行为和内部的可观测性，方便监控。
                2.  支持自动化，与标准工具集成。
                3.  避免绑定特定的机器，这样在整个系统不间断运行的同时，允许机器停机维护。
                4.  提供良好的文档和易于理解的操作模式。
                5.  提供良好的默认配置，且允许管理员在需要时方便地修改默认值。
                6.  尝试自我修复，在需要时让管理员手动控制系统状态。
                7.  行为可预测，减少意外发生。

        <!--list-separator-->

        -  简单性

            简化系统复杂性，使新工程师能够轻松理解系统。复杂性有各种各样的表面方式：状态空间的膨胀，模块紧耦合，令人纠结的相互依赖关系，不一致的命名和术语，为了性能而的特殊片，为解决某特定问题而引入的特殊框架等。简化系统设计并不意味关减少系统功能，而主要意味着意外方面的复杂性。消除意外复杂性最好手段之一是抽象。

        <!--list-separator-->

        -  可演化性

            后续工程师能够轻松地对系统进行改进，并根据需求变化将其适配到非典型场景，也称为可延伸性、易修改性可可塑性。


#### 数据模型与查询语言 {#数据模型与查询语言}

<!--list-separator-->

-  关系模型与文档模型

    <!--list-separator-->

    -  关系模型

        关系模型所做的是定义了所有数据的模式：关系（表）只是元组（行）的分文不值一，公此而已。没有复杂的嵌套结构，也没胡复杂的访问路径。可以读取表中的任何一行或者所有行，支持任意条件查询。可以指定某些列作为键并匹配这些列来读取特定行。可以在任何表中插入新行，而不必担心与其他表之间的外键关系。关系模型的一个核心要点是：只需要构建一次查询优化器，然后使用该数据库的所有应用程序都可以从中受益。

    <!--list-separator-->

    -  NoSQL

        <!--list-separator-->

        -  采用NoSQL数据库的驱动因素

            1.  比关系数据库更好的扩展性需求，錍巴拉圭超 大数据集或超市写入吞量
            2.  普通偏爱免费和开源软件而不是商业数据库产品。
            3.  关系模型不能很好地支持一些特定的查询操作。
            4.  对关系模式一些限制性感到沮丧，渴望更具动态和表达力的数据模型。

    <!--list-separator-->

    -  对象-关系不匹配

    <!--list-separator-->

    -  多对一与多对多的关系

        <!--list-separator-->

        -  使用ID比使用纯文本字符串的优势

            1.  所有的数据保持和输入值一致。
            2.  避免歧义。
            3.  易于更新。
            4.  本地化支持。
            5.  更好的搜索支持。

    <!--list-separator-->

    -  网络模型

        也被称为CODASYL模型，是层次模型的推广。在层次模型的要结构中，每个记录只有一个父结点；而在网络模型中，一个记录可能有多个父结点。

    <!--list-separator-->

    -  关系数据库与文档数据库现状
